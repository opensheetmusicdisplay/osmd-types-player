// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   typescript-collections
//   soundfont-player
//   typescript-collections/dist/lib/Dictionary
//   vexflow

declare module 'opensheetmusicdisplay' {
    export * from "opensheetmusicdisplay/OpenSheetMusicDisplay";
    export * from "opensheetmusicdisplay/MusicalScore";
    export * from "opensheetmusicdisplay/Util";
    export * from "opensheetmusicdisplay/Common";
    export * from "opensheetmusicdisplay/Display";
    export * from "opensheetmusicdisplay/Playback";
    export * from "opensheetmusicdisplay/Plugins";
}

declare module 'opensheetmusicdisplay/OpenSheetMusicDisplay' {
    export * from "opensheetmusicdisplay/OpenSheetMusicDisplay/AJAX";
    export * from "opensheetmusicdisplay/OpenSheetMusicDisplay/Cursor";
    export * from "opensheetmusicdisplay/OpenSheetMusicDisplay/OSMDOptions";
    export * from "opensheetmusicdisplay/OpenSheetMusicDisplay/OpenSheetMusicDisplay";
}

declare module 'opensheetmusicdisplay/MusicalScore' {
    export * from "opensheetmusicdisplay/MusicalScore/Exceptions";
    export * from "opensheetmusicdisplay/MusicalScore/Instrument";
    export * from "opensheetmusicdisplay/MusicalScore/InstrumentNames";
    export * from "opensheetmusicdisplay/MusicalScore/InstrumentalGroup";
    export * from "opensheetmusicdisplay/MusicalScore/Label";
    export * from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    export * from "opensheetmusicdisplay/MusicalScore/SubInstrument";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData";
    export * from "opensheetmusicdisplay/MusicalScore/MusicSource";
    export * from "opensheetmusicdisplay/MusicalScore/MusicParts";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces";
    export * from "opensheetmusicdisplay/MusicalScore/Playback";
}

declare module 'opensheetmusicdisplay/Util' {
    export * from "opensheetmusicdisplay/Util/CollectionUtil";
    export * from "opensheetmusicdisplay/Util/PSMath";
}

declare module 'opensheetmusicdisplay/Common' {
    export * from "opensheetmusicdisplay/Common/DataObjects";
    export * from "opensheetmusicdisplay/Common/Enums";
    export * from "opensheetmusicdisplay/Common/FileIO";
    export * from "opensheetmusicdisplay/Common/Interfaces";
}

declare module 'opensheetmusicdisplay/Display' {
    export * from "opensheetmusicdisplay/Display/AbstractDisplayInteractionManager";
    export * from "opensheetmusicdisplay/Display/AbstractZoomView";
    export * from "opensheetmusicdisplay/Display/PlaybackCursorUserInteractionManager";
    export * from "opensheetmusicdisplay/Display/ScreenViewingRegion";
    export * from "opensheetmusicdisplay/Display/SheetRenderingManager";
    export * from "opensheetmusicdisplay/Display/WebDisplayInteractionManager";
}

declare module 'opensheetmusicdisplay/Playback' {
    export * from "opensheetmusicdisplay/Playback/PlaybackManager";
    export * from "opensheetmusicdisplay/Playback/BasicAudioPlayer";
    export * from "opensheetmusicdisplay/Playback/TimingSources/LinearTimingSource";
    export * from "opensheetmusicdisplay/Playback/UIComponents/ControlPanel/ControlPanel";
}

declare module 'opensheetmusicdisplay/Plugins' {
    export * from "opensheetmusicdisplay/Plugins/Transpose";
}

declare module 'opensheetmusicdisplay/OpenSheetMusicDisplay/AJAX' {
    /**
        * Class with helper methods to handle asynchronous JavaScript requests
        */
    export class AJAX {
            /**
                * Retrieve the content of the file at url
                * @param url
                * @returns {any}
                */
            static ajax(url: string, timeout?: number): Promise<string>;
    }
}

declare module 'opensheetmusicdisplay/OpenSheetMusicDisplay/Cursor' {
    import { MusicPartManagerIterator } from "opensheetmusicdisplay/MusicalScore/MusicParts/MusicPartManagerIterator";
    import { MusicPartManager } from "opensheetmusicdisplay/MusicalScore/MusicParts/MusicPartManager";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { OpenSheetMusicDisplay } from "opensheetmusicdisplay/OpenSheetMusicDisplay/OpenSheetMusicDisplay";
    import { GraphicalMusicSheet } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet";
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { CursorOptions } from "opensheetmusicdisplay/OpenSheetMusicDisplay/OSMDOptions";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { IPlaybackListener } from "opensheetmusicdisplay/Common/Interfaces/IPlaybackListener";
    import { CursorPosChangedData } from "opensheetmusicdisplay/Common/DataObjects/CursorPosChangedData";
    /**
        * A cursor which can iterate through the music sheet.
        */
    export class Cursor implements IPlaybackListener {
            constructor(container: HTMLElement, openSheetMusicDisplay: OpenSheetMusicDisplay, cursorOptions: CursorOptions);
            cursorPositionChanged(timestamp: Fraction, data: CursorPosChangedData): void;
            pauseOccurred(o: object): void;
            selectionEndReached(o: object): void;
            resetOccurred(o: object): void;
            notesPlaybackEventOccurred(o: object): void;
            adjustToBackgroundColor(): void;
            cursorElement: HTMLImageElement;
            /** a unique id of the cursor's HTMLElement in the document.
                * Should be constant between re-renders and backend changes,
                * but different between different OSMD objects on the same page.
                */
            cursorElementId: string;
            /** The desired zIndex (layer) of the cursor when no background color is set.
                *  When a background color is set, using a negative zIndex would make the cursor invisible.
                */
            wantedZIndex: string;
            iterator: MusicPartManagerIterator;
            hidden: boolean;
            currentPageNumber: number;
            /** Where to scroll to when FollowCursor is enabled.
                *  Default center (will scroll so that the current cursor position is in the center of the screen),
                *  alternatively set to "start" to scroll so that the current position is at the top of the screen.
                */
            ScrollPosition: ScrollLogicalPosition;
            /** Initialize the cursor. Necessary before using functions like show() and next(). */
            init(manager: MusicPartManager, graphic: GraphicalMusicSheet): void;
            /**
                * Make the cursor visible
                */
            show(): void;
            resetIterator(): void;
            updateWithTimestamp(timestamp: Fraction): void;
            update(): void;
            updateWidthAndStyle(measurePositionAndShape: BoundingBox, x: number, y: number, height: number): void;
            /**
                * Hide the cursor
                */
            hide(): void;
            /**
                * Go to previous entry
                */
            previous(): void;
            /**
                * Go to next entry
                */
            next(): void;
            /**
                * reset cursor to start
                */
            reset(): void;
            get Iterator(): MusicPartManagerIterator;
            get Hidden(): boolean;
            /** returns voices under the current Cursor position. Without instrument argument, all voices are returned. */
            VoicesUnderCursor(instrument?: Instrument): VoiceEntry[];
            NotesUnderCursor(instrument?: Instrument): Note[];
            GNotesUnderCursor(instrument?: Instrument): GraphicalNote[];
            /** Check if there was a change in current page, and attach cursor element to the corresponding HTMLElement (div).
                *  This is only necessary if using PageFormat (multiple pages).
                */
            updateCurrentPage(): number;
            get SkipInvisibleNotes(): boolean;
            set SkipInvisibleNotes(value: boolean);
            get CursorOptions(): CursorOptions;
            set CursorOptions(value: CursorOptions);
            updateCurrentPageFromSystem(system: MusicSystem): number;
            Dispose(): void;
    }
}

declare module 'opensheetmusicdisplay/OpenSheetMusicDisplay/OSMDOptions' {
    import { ColoringModes } from "opensheetmusicdisplay/Common/Enums/ColoringModes";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { DrawingParametersEnum } from "opensheetmusicdisplay/Common/Enums/DrawingParametersEnum";
    export enum CursorType {
            Standard = 0,
            ThinLeft = 1,
            ShortThinTopLeft = 2,
            CurrentArea = 3,
            CurrentAreaLeft = 4
    }
    /** Possible options for the OpenSheetMusicDisplay constructor and osmd.setOptions(). None are mandatory.
        *  Note that after using setOptions(), you have to call osmd.render() again to make changes visible.
        *  Example: osmd.setOptions({defaultColorRest: "#AAAAAA", drawSubtitle: false}); osmd.render();
        *
        *  Note that some additional, usually more small scale options are available in EngravingRules,
        *  though not all of them are meant to be manipulated.
        *  The OSMDOptions are the main options we support.
        */
    export interface IOSMDOptions {
            /** Whether to let Vexflow align rests to preceding or following notes (Vexflow option). Default false (0).
                * This can naturally reduce collisions of rest notes with other notes.
                * Auto mode (2) only aligns rests when there are multiple voices in a measure,
                * and at least once at the same x-coordinate.
                * Auto is the recommended setting, and would be default,
                * if it couldn't in rare cases deteriorate rest placement for existing users.
                * The on mode (1) always aligns rests,
                * also changing their position when there is no simultaneous note at the same x-coordinate,
                * which is nonstandard.
                */
            alignRests?: AlignRestOption | number;
            /** Whether to automatically create beams for notes that don't have beams set in XML. */
            autoBeam?: boolean;
            /** Options for autoBeaming like whether to beam over rests. See AutoBeamOptions interface. */
            autoBeamOptions?: AutoBeamOptions;
            /** Automatically resize score with canvas size. Default is true. */
            autoResize?: boolean;
            /** Render Backend, will be SVG if given undefined, "SVG" or "svg", otherwise Canvas. */
            backend?: string;
            /** Defines the mode that is used for coloring: XML (0), Boomwhacker(1), CustomColorSet (2). Default XML.
                *  If coloringMode.CustomColorSet (2) is chosen, a coloringSetCustom parameter must be added.
                */
            coloringMode?: ColoringModes;
            /** Set of 8 colors for automatic coloring of 7 notes from C to B + rest note in HTML form (e.g. "#00ff00" for green).  */
            coloringSetCustom?: string[];
            /** Whether to enable coloring noteheads and stems, depending on coloringMode. */
            coloringEnabled?: boolean;
            /** Whether to color the stems of notes the same as their noteheads. Default false. */
            colorStemsLikeNoteheads?: boolean;
            /** Dark mode (black background, white notes). Simply sets defaultColorMusic and EngravingRules.PageBackgroundColor. */
            darkMode?: boolean;
            /** Default color for all musical elements including key signature etc. Can be used for dark mode etc. Default undefined. */
            defaultColorMusic?: string;
            /** Default color for a note head (without stem). Default black (undefined).
                * Only considered before loading a sample, not before render.
                * To change the color after loading a sample and before render, use note(.sourceNote).NoteheadColor.
                * The format is Vexflow format, either "#rrggbb" or "#rrggbboo" where <oo> is opacity (00 = transparent). All hex values.
                * E.g., a half-transparent red would be "#FF000080", invisible/transparent would be "#00000000" or "#12345600".
                */
            defaultColorNotehead?: string;
            /** Default color for a note stem. Default black (undefined). */
            defaultColorStem?: string;
            /** Default color for rests. Default black (undefined). */
            defaultColorRest?: string;
            /** Default color for Labels like title or lyrics. Default black (undefined). */
            defaultColorLabel?: string;
            /** Default color for labels in the title. Overrides defaultColorLabel for title labels like composer. Default black (undefined). */
            defaultColorTitle?: string;
            /** Default font used for text and labels, e.g. title or lyrics. Default Times New Roman
                * Note that OSMD originally always used Times New Roman,
                * so things like layout and spacing may still be optimized for it.
                * Valid options are CSS font families available in the browser used for rendering,
                * e.g. Times New Roman, Helvetica.
                */
            defaultFontFamily?: string;
            /** Default font style, e.g. FontStyles.Bold (1). Default Regular (0). */
            defaultFontStyle?: FontStyles;
            /** Don't show/load cursor. Will override disableCursor in drawingParameters. */
            disableCursor?: boolean;
            /** Follow Cursor: Scroll the page when cursor.next() is called and the cursor moves into a new system outside of the current view frame. */
            followCursor?: boolean;
            /** Broad Parameters like compact or preview mode.
                * Also try "compacttight", which is like compact but also reduces margins.
                * To see what this mode does and maybe adjust the spacing parameters yourself instead of using the mode,
                * see DrawingParameters.ts:setForCompactTightMode().
                */
            drawingParameters?: string | DrawingParametersEnum;
            /** Whether to draw credits (title, subtitle, composer, lyricist) (in future: copyright etc., see <credit>). */
            drawCredits?: boolean;
            /** Whether to draw the title of the piece. If false, disables drawing Subtitle as well. */
            drawTitle?: boolean;
            /** Whether to draw the subtitle of the piece. If true, enables drawing Title as well. */
            drawSubtitle?: boolean;
            /** Whether to draw the composer name (top right of the score). */
            drawComposer?: boolean;
            /** Whether to draw the lyricist's name, if given (top left of the score). */
            drawLyricist?: boolean;
            /** Whether to draw metronome marks. Default true. (currently OSMD can only draw one at the beginning) */
            drawMetronomeMarks?: boolean;
            /** Whether to draw part (instrument) names. Setting this to false also disables drawPartAbbreviations,
                *  unless explicitly enabled (drawPartNames: false, drawPartAbbreviations: true).
                */
            drawPartNames?: boolean;
            /** Whether to draw part (instrument) name abbreviations each system after the first. Only draws if drawPartNames. Default true. */
            drawPartAbbreviations?: boolean;
            /** Whether to draw measure numbers (labels). Default true.
                * Draws a measure number label at first measure, system start measure,
                * and every [measureNumberInterval] measures.
                * See the [measureNumberInterval] option, default is 2.
                */
            drawMeasureNumbers?: boolean;
            /** Whether to only draw measure numbers at the start of a system ("new line"), instead of every [measureNumberInterval] measures. Default false. */
            drawMeasureNumbersOnlyAtSystemStart?: boolean;
            /** Whether to draw time signatures (e.g. 4/4). Default true. */
            drawTimeSignatures?: boolean;
            /** The interval of measure numbers to draw, i.e. it draws the measure number above the beginning label every x measures. Default 2. */
            measureNumberInterval?: number;
            /** Whether to read measure numbers from the "number" attribute in the xml file as opposed to defaulting to start at measure 1. Default true. */
            useXMLMeasureNumbers?: boolean;
            /** Whether to draw fingerings (only left to the note for now). Default true (unless solo part). */
            drawFingerings?: boolean;
            /** Where to draw fingerings (above, below, aboveorbelow, left, right, or auto).
                * Default AboveOrBelow. Auto experimental
                */
            fingeringPosition?: string;
            /** For above/below fingerings, whether to draw them directly above/below notes (default), or above/below staffline. */
            fingeringInsideStafflines?: boolean;
            /** Whether to draw hidden/invisible notes (print-object="no" in XML). Default false. Not yet supported. */ drawHiddenNotes?: boolean;
            /** Whether to draw lyrics (and their extensions and dashes). */
            drawLyrics?: boolean;
            /** Whether to calculate extra slurs with bezier curves not covered by Vexflow slurs. Default true. */
            drawSlurs?: boolean;
            /** Only draw measure n to m, where m is the number specified. (for n, see drawFromMeasureNumber) */
            drawUpToMeasureNumber?: number;
            /** Only draw the first n systems, where n is the number specified. */
            drawUpToSystemNumber?: number;
            /** Only draw the first n pages, where n is the number specified. */
            drawUpToPageNumber?: number;
            /** Only draw measure n to m, where n is the number you specify. (for m, see drawUpToMeasureNumber) */
            drawFromMeasureNumber?: number;
            /** Whether to fill measures that don't have notes given in the XML with whole rests (visible = 1, invisible = 2, for layouting). Default No (0). */
            fillEmptyMeasuresWithWholeRest?: FillEmptyMeasuresWithWholeRests | number;
            /** Whether to set the wanted stem direction by xml (default) or automatically. */
            setWantedStemDirectionByXml?: boolean;
            /** Whether tuplets are labeled with ratio (e.g. 5:2 instead of 5 for quintuplets). Default false. */
            tupletsRatioed?: boolean;
            /** Whether all tuplets should be bracketed (e.g. |--5--| instead of 5). Default false.
                * If false, only tuplets given as bracketed in XML (bracket="yes") will be bracketed.
                */
            tupletsBracketed?: boolean;
            /** Whether all triplets should be bracketed. Overrides tupletsBracketed for triplets.
                * If false, only triplets given as bracketed in XML (bracket="yes") will be bracketed.
                * (Bracketing all triplets can be cluttering)
                */
            tripletsBracketed?: boolean;
            /** See OpenSheetMusicDisplay.PageFormatStandards for standard options like "A4 P" or "Endless".
                *  Default Endless.
                *  Uses OpenSheetMusicDisplay.StringToPageFormat().
                *  Unfortunately it would be error-prone to set a PageFormat type directly.
                */
            pageFormat?: string;
            /** A custom page/canvas background color. Default undefined/transparent.
                *  Example: "#FFFFFF" = white. "#12345600" = transparent.
                *  This can be useful when you want to export an image with e.g. white background color
                * instead of transparent, from a CanvasBackend.
                *  Note: Using a background color will prevent the cursor from being visible for now
                * (will be fixed at some point).
                */
            pageBackgroundColor?: string;
            /** This option enables or disables "performance" mode where skybottom lines are calculated using the SVG bounding box engine
                * instead of the canvas pixel method. This confers a 2-3x performance increase depending on the browser used.
                * This will only be work if the environment supports SVG's getBBox method - Otherwise it will default back to the canvas method.
                * Defaults to off.
                * (Note this won't ever be used in the visual regression headless mode.)
                */
            performanceMode?: boolean;
            /** This makes OSMD render on one single horizontal (staff-)line.
                * This option should be set before loading a score. It only starts working after load(),
                * calling setOptions() after load and then render() doesn't work in this case.
                */
            renderSingleHorizontalStaffline?: boolean;
            /** Whether to begin a new system ("line break") when given in XML ('new-system="yes"').
                *  Default false, because OSMD does its own layout that will do line breaks interactively
                *  at different measures. So this option may result in a system break after a single measure in a system.
                */
            newSystemFromXML?: boolean;
            /** Whether to begin a new system ("line break") when given a new page in XML ('new-page="yes"'), but newPageFromXML is false.
                *  Default false, because OSMD does its own layout that will do line breaks interactively
                *  at different measures. So this option may result in a system break after a single measure in a system.
                */
            newSystemFromNewPageInXML?: boolean;
            /** Whether to begin a new page ("page break") when given in XML ('new-page="yes"').
                *  Default false, because OSMD does its own layout that will do page breaks interactively
                * (when given a PageFormat) at different measures.
                * So this option may result in a page break after a single measure on a page.
                */
            newPageFromXML?: boolean;
            /** A custom function that is executed when the xml is read, modifies it, and returns a new xml string that OSMD then parses. */
            onXMLRead?(xml: string): string;
            /** The cutoff number for rendering percussion clef stafflines as a single line. Default is 4.
                *  This is number of instruments specified, e.g. a drumset:
                *     <score-part id="P1">
                *       <part-name>Drumset</part-name>
                *       <part-abbreviation>D. Set</part-abbreviation>
                *       <score-instrument id="P1-I36">
                *           <instrument-name>Acoustic Bass Drum</instrument-name>
                *           </score-instrument>
                *       <score-instrument id="P1-I37">
                *           <instrument-name>Bass Drum 1</instrument-name>
                *           </score-instrument>
                *       <score-instrument id="P1-I38">
                *           <instrument-name>Side Stick</instrument-name>
                *           </score-instrument>
                *       <score-instrument id="P1-I39">
                *           <instrument-name>Acoustic Snare</instrument-name>
                *           </score-instrument>
                *           ...
                *   Would still render as 5 stafflines by default, since we have 4 (or greater) instruments in this part.
                *   While a snare:
                *   <score-part id="P2">
                *   <part-name>Concert Snare Drum</part-name>
                *   <part-abbreviation>Con. Sn.</part-abbreviation>
                *   <score-instrument id="P2-I38">
                *       <instrument-name>Side Stick</instrument-name>
                *       </score-instrument>
                *   <score-instrument id="P2-I39">
                *       <instrument-name>Acoustic Snare</instrument-name>
                *       </score-instrument>
                *       ...
                *   Would render with 1 line on the staff, since we only have 2 voices.
                *   If this value is 0, the feature is turned off.
                *   If this value is -1, it will render all percussion clefs as a single line.
                */
            percussionOneLineCutoff?: number;
            /** This property is only active if the above property is active (percussionOneLineCutoff)
                *  This is the cutoff for forcing all voices to the single line, instead of rendering them at different
                *  positions above/below the line.
                *  The default is 3, so if a part has less than voices, all of them will be rendered on the line.
                *  This is for cases like a Concert snare, which has multiple 'instruments' available (snare, side stick)
                *  should still render only on the line since there is no ambiguity.
                *  If this value is 0, the feature is turned off.
                *  IF this value is -1, it will render all percussion clef voices on the single line.
                */
            percussionForceVoicesOneLineCutoff?: number;
            /** The softmaxFactor for Vexflow's formatter. Default is 5, default in Vexflow is 100 (voice.js).
                *  Lowering this factor makes the spacing between individual notes smaller (especially from one half note to the next).
                *  So, to get more compact scores, try lowering this value (or set osmd.zoom, which simply scales),
                *  or try 100 for a more expansive layout.
                *  Setting this is the same as setting osmd.EngravingRules.SoftmaxFactorVexFlow.
                */
            spacingFactorSoftmax?: number;
            /**
                * Number in pixels, of spacing between multi-line labels
                */
            spacingBetweenTextLines?: number;
            /**
                * Set to true if the last system line should be streched across the whole page just as the other systems. Default is false
                */
            stretchLastSystemLine?: boolean;
            /**
                * Set to true if subsequent measures full of rests should be auto-converted to multi-rest measure. Default is true
                * This works across instruments- If all instruments have subsequent measures with nothing but rests, multirest measures are generated
                */
            autoGenerateMultipleRestMeasuresFromRestMeasures?: boolean;
            /**
                * Defines multiple simultaneous cursors. If left undefined the standard cursor will be used.
                */
            cursorsOptions?: CursorOptions[];
            /**
                * Defines which skyline and bottom-line batch calculation algorithm to use.
                */
            preferredSkyBottomLineBatchCalculatorBackend?: SkyBottomLineBatchCalculatorBackendType;
            /**
                * Defines the minimum number of measures in the entire sheet music where the skyline and bottom-line batch calculation is enabled.
                */
            skyBottomLineBatchMinMeasures?: number;
    }
    export enum AlignRestOption {
            Never = 0,
            Always = 1,
            Auto = 2
    }
    export enum FillEmptyMeasuresWithWholeRests {
            No = 0,
            YesVisible = 1,
            YesInvisible = 2
    }
    export enum BackendType {
            SVG = 0,
            Canvas = 1
    }
    export enum SkyBottomLineBatchCalculatorBackendType {
            Plain = 0,
            WebGL = 1
    }
    /** Handles [[IOSMDOptions]], e.g. returning default options with OSMDOptionsStandard() */
    export class OSMDOptions {
            /** Returns the default options for OSMD.
                * These are e.g. used if no options are given in the [[OpenSheetMusicDisplay]] constructor.
                */
            static OSMDOptionsStandard(): IOSMDOptions;
            static BackendTypeFromString(value: string): BackendType;
    }
    export interface AutoBeamOptions {
            /** Whether to extend beams over rests. Default false. */
            beam_rests?: boolean;
            /** Whether to extend beams only over rests that are in the middle of a potential beam. Default false. */
            beam_middle_rests_only?: boolean;
            /** Whether to maintain stem direction of autoBeamed notes. Discouraged, reduces beams. Default false. */
            maintain_stem_directions?: boolean;
            /** Groups of notes (fractions) to beam within a measure.
                * List of fractions, each fraction being [nominator, denominator].
                * E.g. [[3,4],[1,4]] will beam the first 3 quarters of a measure, then the last quarter.
                */
            groups?: [number[]];
    }
    export interface CursorOptions {
            /**
                * Type of cursor:
                * 0: Standard highlighting current notes
                * 1: Thin line left to the current notes
                * 2: Short thin line on top of stave and left to the current notes
                * 3: Current measure
                * 4: Current measure to left of current notes
                */
            type: CursorType;
            /**
                * Color to draw the cursor
                */
            color: string;
            /**
                * alpha value to be used with color (0.0 transparent, 0.5 medium, 1.0 opaque).
                */
            alpha: number;
            /**
                * If true, this cursor will be followed.
                */
            follow: boolean;
    }
}

declare module 'opensheetmusicdisplay/OpenSheetMusicDisplay/OpenSheetMusicDisplay' {
    import { VexFlowBackend } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowBackend";
    import { GraphicalMusicSheet } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet";
    import { VexFlowMusicSheetDrawer } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMusicSheetDrawer";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { Cursor } from "opensheetmusicdisplay/OpenSheetMusicDisplay/Cursor";
    import { DrawingParameters } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingParameters";
    import { IOSMDOptions, BackendType } from "opensheetmusicdisplay/OpenSheetMusicDisplay/OSMDOptions";
    import { EngravingRules, PageFormat } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { ITransposeCalculator } from "opensheetmusicdisplay/MusicalScore/Interfaces/ITransposeCalculator";
    import { SheetRenderingManager } from "opensheetmusicdisplay/Display/SheetRenderingManager";
    import { AbstractDisplayInteractionManager } from "opensheetmusicdisplay/Display/AbstractDisplayInteractionManager";
    import { PlaybackManager } from "opensheetmusicdisplay/Playback";
    /**
        * The main class and control point of OpenSheetMusicDisplay.<br>
        * It can display MusicXML sheet music files in an HTML element container.<br>
        * After the constructor, use load() and render() to load and render a MusicXML file.
        */
    export class OpenSheetMusicDisplay {
            /**
                * Creates and attaches an OpenSheetMusicDisplay object to an HTML element container.<br>
                * After the constructor, use load() and render() to load and render a MusicXML file.
                * @param container The container element OSMD will be rendered into.<br>
                *                  Either a string specifying the ID of an HTML container element,<br>
                *                  or a reference to the HTML element itself (e.g. div)
                * @param options An object for rendering options like the backend (svg/canvas) or autoResize.<br>
                *                For defaults see the OSMDOptionsStandard method in the [[OSMDOptions]] class.
                */
            constructor(container: string | HTMLElement, options?: IOSMDOptions, rules?: EngravingRules);
            cursors: Cursor[];
            get cursor(): Cursor;
            zoom: number;
            protected zoomUpdated: boolean;
            /** Timeout in milliseconds used in osmd.load(string) when string is a URL. */
            loadUrlTimeout: number;
            protected container: HTMLElement;
            protected backendType: BackendType;
            protected needBackendUpdate: boolean;
            protected sheet: MusicSheet;
            protected drawer: VexFlowMusicSheetDrawer;
            protected drawBoundingBox: string;
            protected drawSkyLine: boolean;
            protected drawBottomLine: boolean;
            protected graphic: GraphicalMusicSheet;
            protected renderingManager: SheetRenderingManager;
            protected interactionManager: AbstractDisplayInteractionManager;
            protected drawingParameters: DrawingParameters;
            protected rules: EngravingRules;
            protected autoResizeEnabled: boolean;
            protected followCursor: boolean;
            protected OnXMLRead: Function;
            get RenderingManager(): SheetRenderingManager;
            set PlaybackManager(manager: PlaybackManager);
            get PlaybackManager(): PlaybackManager;
            /**
                * Load a MusicXML file
                * @param content is either the url of a file, or the root node of a MusicXML document, or the string content of a .xml/.mxl file
                * @param tempTitle is used as the title for the piece if there is no title in the XML.
                */
            load(content: string | Document, tempTitle?: string): Promise<{}>;
            /**
                * (Re-)creates the graphic sheet from the music sheet
                */
            updateGraphic(): void;
            /**
                * Render the music sheet in the container
                */
            render(): void;
            protected createOrRefreshRenderBackend(): void;
            exportSVG(): void;
            /** States whether the render() function can be safely called. */
            IsReadyToRender(): boolean;
            /** Clears what OSMD has drawn on its canvas. */
            clear(): void;
            /** Dispose listeners created by OSMD */
            dispose(): void;
            /** Set OSMD rendering options using an IOSMDOptions object.
                *  Can be called during runtime. Also called by constructor.
                *  For example, setOptions({autoResize: false}) will disable autoResize even during runtime.
                */
            setOptions(options: IOSMDOptions): void;
            setColoringMode(options: IOSMDOptions): void;
            /**
                * Sets the logging level for this OSMD instance. By default, this is set to `warn`.
                *
                * @param: content can be `trace`, `debug`, `info`, `warn` or `error`.
                */
            setLogLevel(level: string): void;
            getLogLevel(): number;
            /**
                * Initialize this object to default values
                * FIXME: Probably unnecessary
                */
            protected reset(): void;
            /**
                * Attach the appropriate handler to the window.onResize event
                */
            protected autoResize(): void;
            /**
                * Helper function for managing window's onResize events
                * @param startCallback is the function called when resizing starts
                * @param endCallback is the function called when resizing (kind-of) ends
                */
            protected handleResize(startCallback: () => void, endCallback: () => void): void;
            /** Enable or disable (hide) the cursor.
                * @param enable whether to enable (true) or disable (false) the cursor
                */
            enableOrDisableCursors(enable: boolean): void;
            createBackend(type: BackendType, page: GraphicalMusicPage): VexFlowBackend;
            /** Standard page format options like A4 or Letter, in portrait and landscape. E.g. PageFormatStandards["A4_P"] or PageFormatStandards["Letter_L"]. */
            static PageFormatStandards: {
                    [type: string]: PageFormat;
            };
            static StringToPageFormat(pageFormatString: string): PageFormat;
            /** Sets page format by string. Used by setOptions({pageFormat: "A4_P"}) for example. */
            setPageFormat(formatId: string): void;
            setCustomPageFormat(width: number, height: number): void;
            set DrawSkyLine(value: boolean);
            get DrawSkyLine(): boolean;
            set DrawBottomLine(value: boolean);
            get DrawBottomLine(): boolean;
            set DrawBoundingBox(value: string);
            get DrawBoundingBox(): string;
            setDrawBoundingBox(value: string, render?: boolean): void;
            get AutoResizeEnabled(): boolean;
            set AutoResizeEnabled(value: boolean);
            get Zoom(): number;
            set Zoom(value: number);
            set FollowCursor(value: boolean);
            get FollowCursor(): boolean;
            set TransposeCalculator(calculator: ITransposeCalculator);
            get TransposeCalculator(): ITransposeCalculator;
            get Sheet(): MusicSheet;
            get Drawer(): VexFlowMusicSheetDrawer;
            get GraphicSheet(): GraphicalMusicSheet;
            get DrawingParameters(): DrawingParameters;
            get EngravingRules(): EngravingRules;
            get InteractionManager(): AbstractDisplayInteractionManager;
            /** Returns the version of OSMD this object is built from (the version you are using). */
            get Version(): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Exceptions' {
    export class MusicSheetReadingException implements Error {
        name: string;
        message: string;
        constructor(message: string, e?: Error);
    }
    export class ArgumentOutOfRangeException implements Error {
        name: string;
        message: string;
        constructor(message: string);
    }
    export class InvalidEnumArgumentException implements Error {
        name: string;
        message: string;
        constructor(message: string);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Instrument' {
    import { InstrumentalGroup } from "opensheetmusicdisplay/MusicalScore/InstrumentalGroup";
    import { Label } from "opensheetmusicdisplay/MusicalScore/Label";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { SubInstrument } from "opensheetmusicdisplay/MusicalScore/SubInstrument";
    import { MidiInstrument } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    export class Instrument extends InstrumentalGroup {
        constructor(id: number, idString: string, musicSheet: MusicSheet, parent: InstrumentalGroup);
        /** Transposition halftones for this instrument only.
          *  This is additive to osmd.Sheet.Transpose (MusicSheet).
          *  osmd.TransposeCaculator needs to be defined/created for this to take effect. (just set it with new TransposeCalculator())
          * You need to call osmd.updateGraphic() before the next render() (assuming this is set after load()).
          */
        Transpose: number;
        highlight: boolean;
        get Voices(): Voice[];
        get Staves(): Staff[];
        get NameLabel(): Label;
        get HasLyrics(): boolean;
        set HasLyrics(value: boolean);
        get HasChordSymbols(): boolean;
        set HasChordSymbols(value: boolean);
        get LyricVersesNumbers(): string[];
        set LyricVersesNumbers(value: string[]);
        get Name(): string;
        set Name(value: string);
        get IdString(): string;
        get Id(): number;
        get MidiInstrumentId(): MidiInstrument;
        set MidiInstrumentId(value: MidiInstrument);
        get Volume(): number;
        set Volume(value: number);
        get PlaybackTranspose(): number;
        set PlaybackTranspose(value: number);
        get SubInstruments(): SubInstrument[];
        getSubInstrument(subInstrumentIdString: string): SubInstrument;
        get PartAbbreviation(): string;
        set PartAbbreviation(value: string);
        get Visible(): boolean;
        set Visible(value: boolean);
        get Audible(): boolean;
        set Audible(value: boolean);
        get Solo(): boolean;
        set Solo(value: boolean);
        get Following(): boolean;
        set Following(value: boolean);
        SetVoiceAudible(voiceId: number, audible: boolean): void;
        SetVoiceFollowing(voiceId: number, following: boolean): void;
        SetStaffAudible(staffId: number, audible: boolean): void;
        SetStaffFollow(staffId: number, follow: boolean): void;
        areAllVoiceVisible(): boolean;
        createStaves(numberOfStaves: number): void;
        toString(): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/InstrumentNames' {
    import { MidiInstrument } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    /** Collections of instrument names, mapped to MidiInstruments. */
    export class InstrumentNames {
            static MidiInstrument: {
                    [key: string]: MidiInstrument;
            };
            /** A map of MusicXML `instrument-sound` values to MidiInstrument.
                * These should take priority when the MusicXML has both instrument-name and instrument-sound.
                * Sound definitions partially from: https://www.w3.org/2021/06/musicxml40/listings/sounds.xml/
                */
            static MidiInstrumentSounds: {
                    [key: string]: MidiInstrument;
            };
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/InstrumentalGroup' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    export class InstrumentalGroup {
        constructor(name: string, musicSheet: MusicSheet, parent: InstrumentalGroup);
        get InstrumentalGroups(): InstrumentalGroup[];
        get Parent(): InstrumentalGroup;
        get Name(): string;
        set Name(value: string);
        get GetMusicSheet(): MusicSheet;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Label' {
    import { TextAlignmentEnum } from "opensheetmusicdisplay/Common/Enums/TextAlignment";
    import { OSMDColor } from "opensheetmusicdisplay/Common/DataObjects/OSMDColor";
    import { Fonts } from "opensheetmusicdisplay/Common/Enums/Fonts";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    /**
      * A text label on the graphical music sheet.
      * It is used e.g. for titles, composer names, instrument names and dynamic instructions.
      */
    export class Label {
        constructor(text?: string, alignment?: TextAlignmentEnum, font?: Fonts, print?: boolean);
        text: string;
        print: boolean;
        color: OSMDColor;
        colorDefault: string;
        set font(font: Fonts);
        get font(): Fonts;
        fontFamily: string;
        fontStyle: FontStyles;
        fontHeight: number;
        textAlignment: TextAlignmentEnum;
        IsCreditLabel: boolean;
        ToString(): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicSheet' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { MusicPartManager } from "opensheetmusicdisplay/MusicalScore/MusicParts/MusicPartManager";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { Repetition } from "opensheetmusicdisplay/MusicalScore/MusicSource/Repetition";
    import { DynamicsContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/HelperObjects/DynamicsContainer";
    import { InstrumentalGroup } from "opensheetmusicdisplay/MusicalScore/InstrumentalGroup";
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { Label } from "opensheetmusicdisplay/MusicalScore/Label";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { MusicSheetErrors } from "opensheetmusicdisplay/Common/DataObjects/MusicSheetErrors";
    import { MultiTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiTempoExpression";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { Dictionary } from "typescript-collections";
    import { PlaybackEntry } from "opensheetmusicdisplay/MusicalScore/Playback/PlaybackEntry";
    import { PlaybackSettings } from "opensheetmusicdisplay/Common/DataObjects/PlaybackSettings";
    /**
        * This is the representation of a complete piece of sheet music.
        * It includes the contents of a MusicXML file after the reading.
        * Notes: the musicsheet might not need the Rules, e.g. in the testframework. The EngravingRules Constructor
        * fails when no FontInfo exists, which needs a TextMeasurer
        */
    export class MusicSheet {
            constructor();
            static defaultTitle: string;
            userStartTempoInBPM: number;
            pageWidth: number;
            /**
                * Get the global index within the music sheet for this staff.
                * @param staff
                * @returns {number}
                */
            static getIndexFromStaff(staff: Staff): number;
            get SourceMeasures(): SourceMeasure[];
            set SourceMeasures(value: SourceMeasure[]);
            get Repetitions(): Repetition[];
            set Repetitions(value: Repetition[]);
            get DynListStaves(): DynamicsContainer[][];
            get TimestampSortedTempoExpressionsList(): MultiTempoExpression[];
            get TimestampSortedDynamicExpressionsList(): DynamicsContainer[];
            get InstrumentalGroups(): InstrumentalGroup[];
            get Parts(): Instrument[];
            get Instruments(): Instrument[];
            get SheetPlaybackSetting(): PlaybackSettings;
            set SheetPlaybackSetting(value: PlaybackSettings);
            get DrawErroneousMeasures(): boolean;
            set DrawErroneousMeasures(value: boolean);
            get HasBeenOpenedForTheFirstTime(): boolean;
            set HasBeenOpenedForTheFirstTime(value: boolean);
            InitializeStartTempoInBPM(startTempo: number): void;
            get DefaultStartTempoInBpm(): number;
            set DefaultStartTempoInBpm(value: number);
            get Path(): string;
            set Path(value: string);
            get Staves(): Staff[];
            get TitleString(): string;
            set TitleString(value: string);
            get SubtitleString(): string;
            set SubtitleString(value: string);
            get ComposerString(): string;
            set ComposerString(value: string);
            get LyricistString(): string;
            set LyricistString(value: string);
            get CopyrightString(): string;
            set CopyrightString(value: string);
            get Title(): Label;
            set Title(value: Label);
            get Subtitle(): Label;
            set Subtitle(value: Label);
            get Composer(): Label;
            set Composer(value: Label);
            get Lyricist(): Label;
            set Lyricist(value: Label);
            get Copyright(): Label;
            set Copyright(value: Label);
            get Rules(): EngravingRules;
            set Rules(value: EngravingRules);
            get SheetErrors(): MusicSheetErrors;
            get PlaybackDataDict(): Dictionary<Voice, {
                    enrolledTimestamp: Fraction;
                    playbackEntry: PlaybackEntry;
            }[]>;
            get SelectionStart(): Fraction;
            set SelectionStart(value: Fraction);
            get SelectionEnd(): Fraction;
            set SelectionEnd(value: Fraction);
            set HasBPMInfo(value: boolean);
            get HasBPMInfo(): boolean;
            addMeasure(measure: SourceMeasure): void;
            checkForInstrumentWithNoVoice(): void;
            /**
                *
                * @param staffIndexInMusicSheet - The global staff index, iterating through all staves of all instruments.
                * @returns {Staff}
                */
            getStaffFromIndex(staffIndexInMusicSheet: number): Staff;
            fillStaffList(): void;
            get MusicPartManager(): MusicPartManager;
            set MusicPartManager(value: MusicPartManager);
            getCompleteNumberOfStaves(): number;
            /**
                * Return a sourceMeasureList, where the given indices correspond to the whole SourceMeasureList of the MusicSheet.
                * @param start
                * @param end
                * @returns {SourceMeasure[]}
                */
            getListOfMeasuresFromIndeces(start: number, end: number): SourceMeasure[];
            /**
                * Returns the next SourceMeasure from a given SourceMeasure.
                * @param measure
                */
            getNextSourceMeasure(measure: SourceMeasure): SourceMeasure;
            /**
                * Returns the first SourceMeasure of MusicSheet.
                */
            getFirstSourceMeasure(): SourceMeasure;
            /**
                * Returns the last SourceMeasure of MusicSheet.
                */
            getLastSourceMeasure(): SourceMeasure;
            resetAllNoteStates(): void;
            getMusicSheetInstrumentIndex(instrument: Instrument): number;
            getGlobalStaffIndexOfFirstStaff(instrument: Instrument): number;
            /**
                * Set to the index-given Repetition a new (set from user) value.
                * @param index
                * @param value
                */
            setRepetitionNewUserNumberOfRepetitions(index: number, value: number): void;
            /**
                * Return the [[Repetition]] from the given index.
                * @param index
                * @returns {any}
                */
            getRepetitionByIndex(index: number): Repetition;
            CompareTo(other: MusicSheet): number;
            getExpressionsStartTempoInBPM(): number;
            get Errors(): {
                    [n: number]: string[];
            };
            get FirstMeasureNumber(): number;
            get LastMeasureNumber(): number;
            get CurrentEnrolledPosition(): Fraction;
            set CurrentEnrolledPosition(value: Fraction);
            get Transpose(): number;
            /** Sets the number of halftones for transposition.
                * E.g. +1 halftone will transpose Eb major to E major.
                * also see Instrument.Transpose (e.g. osmd.Sheet.Instruments[0].Transpose will additionally transpose this instrument only)
                * osmd.TransposeCaculator needs to be defined/created for this to take effect. (just set it with new TransposeCalculator())
                */
            set Transpose(value: number);
            get FullNameString(): string;
            get IdString(): string;
            set IdString(value: string);
            getEnrolledSelectionStartTimeStampWorkaround(): Fraction;
            get SheetEndTimestamp(): Fraction;
            /**
                * Works only if the [[SourceMeasure]]s are already filled with VerticalStaffEntryContainers!
                * @param timeStamp
                * @returns {SourceMeasure}
                */
            getSourceMeasureFromTimeStamp(timeStamp: Fraction): SourceMeasure;
            findSourceMeasureFromTimeStamp(timestamp: Fraction): SourceMeasure;
            getVisibleInstruments(): Instrument[];
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/SubInstrument' {
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { MidiInstrument } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    export class SubInstrument {
        constructor(parentInstrument: Instrument);
        idString: string;
        midiInstrumentID: MidiInstrument;
        volume: number;
        pan: number;
        fixedKey: number;
        name: string;
        instrumentSound: string;
        get ParentInstrument(): Instrument;
        static isPianoInstrument(instrument: MidiInstrument): boolean;
        setMidiInstrumentSound(instrumentType: string): void;
        setMidiInstrument(instrumentType: string): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData' {
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Arpeggio";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Beam";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/ChordSymbolContainer";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Glissando";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/LinkedVoice";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Notehead";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/NoteType";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/OrnamentContainer";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/StaffEntryLink";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Tie";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Tuplet";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/VerticalSourceStaffEntryContainer";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/NoteType";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/VerticalSourceStaffEntryContainer";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Tie";
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicSource' {
    export * from "opensheetmusicdisplay/MusicalScore/MusicSource/MappingSourceMusicPart";
    export * from "opensheetmusicdisplay/MusicalScore/MusicSource/PartListEntry";
    export * from "opensheetmusicdisplay/MusicalScore/MusicSource/Repetition";
    export * from "opensheetmusicdisplay/MusicalScore/MusicSource/SourceMusicPart";
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicParts' {
    export * from "opensheetmusicdisplay/MusicalScore/MusicParts/MusicPartManager";
    export * from "opensheetmusicdisplay/MusicalScore/MusicParts/MusicPartManagerIterator";
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO' {
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/InstrumentReader";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSheetReader";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModuleFactory";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/VoiceGenerator";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/ReaderPluginManager";
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical' {
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalExpression";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalInstruction";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/AccidentalCalculator";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/AlignmentManager";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/Clickable";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingMode";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingParameters";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalChordSymbolContainer";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalContinuousDynamicExpression";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalCurve";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalGlissando";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalInstantaneousDynamicExpression";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalInstantaneousTempoExpression";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLyricEntry";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLyricWord";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMarkedArea";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalOctaveShift";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalRectangle";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalSlur";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntryLink";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalTie";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/ISqueezable";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSheetCalculator";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSheetDrawer";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSymbol";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystemBuilder";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/OctaveShiftParams";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/SelectionEndSymbol";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/SelectionStartSymbol";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/SkyBottomLineCalculator";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLineActivitySymbol";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLine";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinePosition";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VerticalGraphicalStaffEntryContainer";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow";
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces' {
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/IAfterSheetReadingModule";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/IGraphicalSymbolFactory";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/IQualityFeedbackTone";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/ITextMeasurer";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/ITextTranslation";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/ITransposeCalculator";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/AUIController";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/IVoiceMeasureReadPlugin";
    export * from "opensheetmusicdisplay/MusicalScore/Interfaces/IStafflineNoteCalculator";
}

declare module 'opensheetmusicdisplay/MusicalScore/Playback' {
    export * from "opensheetmusicdisplay/MusicalScore/Playback/PlaybackNoteGenerator";
}

declare module 'opensheetmusicdisplay/Util/CollectionUtil' {
    import { Dictionary } from "typescript-collections";
    global {
            interface Array<T> {
                    /** Returns the last element from an array */
                    last(): T;
                    /** Deletes all elements from an array */
                    clear(): void;
                    /** Returns true if the element is found in the array */
                    contains(elem: T): boolean;
            }
    }
    /**
        * This class implements static methods to perform useful operations on lists, dictionaries, ...
        */
    export class CollectionUtil {
            static contains2(array: any[], object: any): boolean;
            static last(array: any[]): any;
            /** Array.flat(), introduced in ES2019, polyfilled here to stick with ES2017 target in tsconfig.json.
                *  Performance tests: https://github.com/opensheetmusicdisplay/opensheetmusicdisplay/issues/1299#issuecomment-1399062038
                */
            static flat(array: any[]): any;
            /**
                * Iterates through a dictionary and calls iterationFunction.
                * If iterationFunction returns true the key gets stored.
                * all stored key will finally be removed from the dictionary.
                * @param dict
                * @param iterationFunction
                */
            static removeDictElementIfTrue<S, T, V>(thisPointer: S, dict: Dictionary<T, V>, iterationFunction: (thisPointer: S, key: T, value: V) => boolean): void;
            static getLastElement<T>(array: T[]): T;
            static binarySearch<T>(array: T[], element: T, cmp: (elem1: T, elem2: T) => number, startIndex?: number, endIndex?: number): number;
    }
}

declare module 'opensheetmusicdisplay/Util/PSMath' {
    /**
      * Some useful Maths methods.
      */
    export class PSMath {
        static log(base: number, x: number): number;
        static log10(x: number): number;
        static meanSimple(values: number[]): number;
        static meanWeighted(values: number[], weights: number[]): number;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects' {
    export * from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    export * from "opensheetmusicdisplay/Common/DataObjects/Matrix2D";
    export * from "opensheetmusicdisplay/Common/DataObjects/MusicSheetErrors";
    export * from "opensheetmusicdisplay/Common/DataObjects/OSMDColor";
    export * from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    export * from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    export * from "opensheetmusicdisplay/Common/DataObjects/RectangleF2D";
    export * from "opensheetmusicdisplay/Common/DataObjects/SizeF2D";
}

declare module 'opensheetmusicdisplay/Common/Enums' {
    export * from "opensheetmusicdisplay/Common/Enums/ColoringModes";
    export * from "opensheetmusicdisplay/Common/Enums/DrawingParametersEnum";
    export * from "opensheetmusicdisplay/Common/Enums/FontStyles";
    export * from "opensheetmusicdisplay/Common/Enums/Fonts";
    export * from "opensheetmusicdisplay/Common/Enums/TextAlignment";
    export * from "opensheetmusicdisplay/Common/Enums/TieTypes";
    export * from "opensheetmusicdisplay/Common/Enums/PsEnums";
}

declare module 'opensheetmusicdisplay/Common/FileIO' {
    export * from "opensheetmusicdisplay/Common/FileIO/Mxl";
    export * from "opensheetmusicdisplay/Common/FileIO/Xml";
}

declare module 'opensheetmusicdisplay/Common/Interfaces' {
    export * from "opensheetmusicdisplay/Common/Interfaces/AClassHierarchyTrackable";
    export * from "opensheetmusicdisplay/Common/Interfaces/IAudioMetronomePlayer";
    export * from "opensheetmusicdisplay/Common/Interfaces/IAudioPlayer";
    export * from "opensheetmusicdisplay/Common/Interfaces/IControllerOutputListener";
    export * from "opensheetmusicdisplay/Common/Interfaces/IDisplayInteractionListener";
    export * from "opensheetmusicdisplay/Common/Interfaces/IInstrument";
    export * from "opensheetmusicdisplay/Common/Interfaces/IMessageViewer";
    export * from "opensheetmusicdisplay/Common/Interfaces/IPlaybackListener";
    export * from "opensheetmusicdisplay/Common/Interfaces/IPlaybackParametersListener";
    export * from "opensheetmusicdisplay/Common/Interfaces/IRepetition";
    export * from "opensheetmusicdisplay/Common/Interfaces/ISettableInstrument";
    export * from "opensheetmusicdisplay/Common/Interfaces/ITimingSource";
    export * from "opensheetmusicdisplay/Common/Interfaces/IUserDisplayInteractionListener";
    export * from "opensheetmusicdisplay/Common/Interfaces/IZoomView";
}

declare module 'opensheetmusicdisplay/Display/AbstractDisplayInteractionManager' {
    import { IDisplayInteractionListener } from "opensheetmusicdisplay/Common/Interfaces/IDisplayInteractionListener";
    export abstract class AbstractDisplayInteractionManager {
        protected listeners: IDisplayInteractionListener[];
        protected touchCount: number;
        protected touchActive: boolean;
        protected touchMoving: boolean;
        protected lastPixelX: number;
        protected lastPixelY: number;
        protected displayWidth: number;
        protected displayHeight: number;
        protected displayDpi: number;
        protected maxNumerOfFingers: number;
        protected movementThreshInch: number;
        protected interactionWasZoomGesture: boolean;
        constructor();
        addListener(listener: IDisplayInteractionListener): void;
        get ZoomGestureActive(): boolean;
        get WasZoomGestureActive(): boolean;
        displaySizeChanged(displayWidthInPixel: number, displayHeightInPixel: number): void;
        Dispose(): void;
        Initialize(): void;
        get DisplayDpi(): number;
        get TouchActive(): boolean;
        get TouchMoving(): boolean;
        protected abstract dispose(): void;
        protected abstract initialize(): void;
        protected touchDown(positionInPixelX: number, positionInPixelY: number, leftMouseButton: boolean): void;
        protected move(positionInPixelX: number, positionInPixelY: number): void;
        protected zoomGestureStarted(): void;
        protected zoomGestureCompleted(): void;
        protected zoomGestureMove(scale: number): void;
        protected touchUp(positionInPixelX: number, positionInPixelY: number): void;
        protected click(positionInPixelX: number, positionInPixelY: number): void;
        protected doubleClick(positionInPixelX: number, positionInPixelY: number): void;
        protected mouseDidMove(oldPosX: number, newPosX: number, oldPosY: number, newPosY: number): boolean;
    }
}

declare module 'opensheetmusicdisplay/Display/AbstractZoomView' {
    import { IControllerOutputListener } from "opensheetmusicdisplay/Common/Interfaces/IControllerOutputListener";
    import { IDisplayInteractionListener } from "opensheetmusicdisplay/Common/Interfaces/IDisplayInteractionListener";
    import { IZoomView } from "opensheetmusicdisplay/Common/Interfaces/IZoomView";
    import { AbstractDisplayInteractionManager } from "opensheetmusicdisplay/Display/AbstractDisplayInteractionManager";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects";
    export abstract class AbstractZoomView implements IControllerOutputListener, IDisplayInteractionListener {
        constructor(displayInteractionManager: AbstractDisplayInteractionManager);
        protected displayInteractionManager: AbstractDisplayInteractionManager;
        protected rangeX: number;
        protected offsetX: number;
        protected rangeY: number;
        protected offsetY: number;
        protected lastRangeX: number;
        protected lastOffsetX: number;
        protected lastRangeY: number;
        protected lastOffsetY: number;
        protected aspectRatio: number;
        protected zoomViews: IZoomView[];
        protected mouseZoomMode: boolean;
        protected usesManuallyControlledZoomMode: boolean;
        protected abstract convertToUnitsReady(): boolean;
        protected abstract getPositionInUnits(relativePositionX: number, relativePositionY: number): PointF2D;
        protected abstract unitPosTouched(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
        protected abstract unitPosDoubleTouched(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
        protected abstract unitPosTouchDown(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
        protected abstract unitPosTouchUp(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
        protected abstract unitPosMove(PosInUnits: PointF2D, relativeDisplayPositionX: number, relativeDisplayPositionY: number): void;
        positionTouched(relativePositionX: number, relativePositionY: number): void;
        get TouchActive(): boolean;
        get TouchMoving(): boolean;
        positionDoubleTouched(relativePositionX: number, relativePositionY: number): void;
        get UsesManuallyControlledZoomMode(): boolean;
        set UsesManuallyControlledZoomMode(value: boolean);
        mouseDown(relativePositionX: number, relativePositionY: number, activateZoomOnRightMouseButton?: boolean): void;
        mouseUp(relativePositionX: number, relativePositionY: number): void;
        mouseMove(relativeDisplayPositionX: number, relativeDisplayPositionY: number, deltaX: number, deltaY: number): void;
        zoom(scale: number): void;
        addZoomView(zoomable: IZoomView): void;
        XScrollingEnabled: boolean;
        YScrollingEnabled: boolean;
        offsetXMin: number;
        offsetYMin: number;
        rangeXMin: number;
        rangeYMin: number;
        offsetXMax: number;
        offsetYMax: number;
        rangeXMax: number;
        rangeYMax: number;
        lockRanges: boolean;
        get OffsetX(): number;
        set OffsetX(value: number);
        get OffsetY(): number;
        set OffsetY(value: number);
        get RangeX(): number;
        set RangeX(value: number);
        get RangeY(): number;
        set RangeY(value: number);
        protected set AspectRatio(value: number);
        initialize(offsetX: number, rangeX: number, offsetY: number, rangeY: number): void;
        setHorizontalViewport(offsetX: number, rangeX: number): void;
        setVerticalViewport(offsetY: number, rangeY: number): void;
        viewSizeChanged(displayWidthInPixel: number, displayHeightInPixel: number): void;
        outputChanged(directlySet: boolean, currentValue: number, expectedValue: number): void;
        setOffsetXValueOnly(offsetX: number): void;
        setXOffset(offsetX: number, animated: boolean): void;
        setOffsetYValueOnly(offsetY: number): void;
        setYOffset(offsetY: number, animated: boolean): void;
        displaySizeChanged(width: number, height: number): void;
    }
}

declare module 'opensheetmusicdisplay/Display/PlaybackCursorUserInteractionManager' {
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects";
    import { InteractionType } from "opensheetmusicdisplay/Common/Enums/InteractionType";
    import { IUserDisplayInteractionListener } from "opensheetmusicdisplay/Common/Interfaces/IUserDisplayInteractionListener";
    import { GraphicalMusicSheet } from "opensheetmusicdisplay/MusicalScore";
    import { Cursor } from "opensheetmusicdisplay/OpenSheetMusicDisplay/Cursor";
    export class PlaybackCursorUserInteractionManager implements IUserDisplayInteractionListener {
        constructor(graphic: GraphicalMusicSheet, cursor: Cursor);
        userDisplayInteraction(relativePosition: PointF2D, positionInSheetUnits: PointF2D, type: InteractionType): void;
    }
}

declare module 'opensheetmusicdisplay/Display/ScreenViewingRegion' {
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical";
    import { SizeF2D, PointF2D } from "opensheetmusicdisplay/Common/DataObjects";
    export class ScreenViewingRegion {
            constructor(displaySizeInPixel: SizeF2D, relativeSizeOfRegionInDisplay: SizeF2D, relativePositionOfRegionInDisplay: PointF2D, regionWidthInUnits: number);
            static createWithRelativeDefaults(displaySizeInPixel: SizeF2D, regionWidthInUnits: number): ScreenViewingRegion;
            static createWithDefaults(): ScreenViewingRegion;
            RelativeDisplayPosition: PointF2D;
            get UpperLeftPositionInUnits(): PointF2D;
            set UpperLeftPositionInUnits(value: PointF2D);
            get DisplaySizeInPixel(): SizeF2D;
            set DisplaySizeInPixel(value: SizeF2D);
            get RelativeDisplaySize(): SizeF2D;
            set RelativeDisplaySize(value: SizeF2D);
            get RegionSizeInPixel(): SizeF2D;
            get WidthInUnits(): number;
            set WidthInUnits(value: number);
            get ViewRegionInUnits(): SizeF2D;
            isVisible(psi: BoundingBox, isCompletelyInside: boolean): boolean;
            /** This visible check takes care of the 4 ClipOnIntersectionWith.... flags
                * If a flag is set, all objects that reach over the corresponding border will not be "visible" and the method returns false.
                */
            isInsideDisplayArea(relativeDisplayPosX: number, relativeDisplayPosY: number): boolean;
            /**
                * @param relativeScreenPosition The relative position on the whole screen,
                * not on the ScreenViewingRegion (only if the region stretches over the whole screen).
                */
            transformToUnitCoordinates(relativeScreenPosition: PointF2D): PointF2D;
            transformLengthXToUnitCoordinates(lengthXInPixels: number): number;
            transformLengthYToUnitCoordinates(lengthYInPixels: number): number;
    }
}

declare module 'opensheetmusicdisplay/Display/SheetRenderingManager' {
    import { IZoomView } from "opensheetmusicdisplay/Common/Interfaces/IZoomView";
    import { MusicSheetDrawer, GraphicalMusicSheet, BoundingBox, DrawingParameters, MusicSystem, EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical";
    import { ScreenViewingRegion } from "opensheetmusicdisplay/Display/ScreenViewingRegion";
    import { PointF2D, Fraction } from "opensheetmusicdisplay/Common/DataObjects";
    import { AbstractZoomView } from "opensheetmusicdisplay/Display/AbstractZoomView";
    import { InteractionType } from "opensheetmusicdisplay/Common/Enums/InteractionType";
    import { AbstractDisplayInteractionManager } from "opensheetmusicdisplay/Display/AbstractDisplayInteractionManager";
    import { IUserDisplayInteractionListener } from "opensheetmusicdisplay/Common/Interfaces/IUserDisplayInteractionListener";
    import { PlaybackManager } from "opensheetmusicdisplay/Playback";
    export class SheetRenderingManager extends AbstractZoomView implements IZoomView {
            protected musicSheetDrawer: MusicSheetDrawer;
            protected graphicalMusicSheet: GraphicalMusicSheet;
            protected mainViewingRegion: ScreenViewingRegion;
            protected tryAgainToRenderCount: number;
            protected internalPreviewImageScale: number;
            protected listeners: IUserDisplayInteractionListener[];
            PlaybackManager: PlaybackManager;
            constructor(displayInteractionManager: AbstractDisplayInteractionManager, rules: EngravingRules);
            addListener(listener: IUserDisplayInteractionListener): void;
            get Listeners(): IUserDisplayInteractionListener[];
            SingleTouchDisabled: boolean;
            DoubleTouchDisabled: boolean;
            LockDisplayToCursor: boolean;
            ZoomActive: boolean;
            protected convertToUnitsReady(): boolean;
            protected unitPosTouched(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
            protected unitPosDoubleTouched(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
            protected unitPosTouchDown(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
            protected unitPosTouchUp(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
            protected unitPosMove(PosInUnits: PointF2D, relPosX: number, relPosY: number): void;
            get MainViewingRegion(): ScreenViewingRegion;
            TopBarHeightInPixel: number;
            BottomBarHeightInPixel: number;
            setMusicSheet(musicSheet: GraphicalMusicSheet): void;
            viewportXChanged(offsetX: number, rangeX: number): void;
            /**
                * Sets the vertical position and viewing height of the displayed area on the music score.
                */
            viewportYChanged(offsetY: number, rangeY: number): void;
            displaySizeChanged(width: number, height: number): void;
            calcDisplayYPosition(system: MusicSystem): number;
            /**
                * The display scroll y-position to show the given system completely on the bottom of the screen
                */
            yPositionForLastSystem(lastSystem: MusicSystem): number;
            scorePositionChanged(upperCursorPoint: PointF2D, enrolledTimeStamp: Fraction, sheetTimeStamp: Fraction, system: MusicSystem, resetOccurred: boolean, smoothAnimation: boolean): void;
            setXPosition(positionXInUnits: number, animated: boolean): void;
            setYPosition(positionYInUnits: number, animated: boolean): void;
            get DrawingParameters(): DrawingParameters;
            topBarHeightInUnits(): number;
            bottomBarHeightInUnits(): number;
            heightWithoutTopBottomBarsInUnits(): number;
            activePositionToBottomBarHeight(): number;
            getClickPosition(relativePositionX: number, relativePositionY: number): PointF2D;
            graphicalObjectIsVisible(boundingBox: BoundingBox): boolean;
            /**
                * sets the size of the maximal musicpage seen including the extensions on top resp. bottom
                * !Caution!: settings/offsets have been changed for ScrollIndicator.. won't work anymore if changed again
                */
            adaptDisplayLimitsToSheet(): void;
            protected horizontalViewportChanged(offsetX: number, rangeX: number): void;
            protected verticalViewportChanged(offsetY: number, rangeY: number): void;
            protected getPositionInUnits(relativePositionX: number, relativePositionY: number): PointF2D;
            protected handleUserDisplayInteraction(relativePositionOnDisplay: PointF2D, positionOnMusicSheet: PointF2D, type: InteractionType): void;
            setStartPosition(newStartPosition: Fraction): void;
            get GraphicalMusicSheet(): GraphicalMusicSheet;
    }
}

declare module 'opensheetmusicdisplay/Display/WebDisplayInteractionManager' {
    import { AbstractDisplayInteractionManager } from "opensheetmusicdisplay/Display/AbstractDisplayInteractionManager";
    import { Dictionary } from "typescript-collections";
    export class WebDisplayInteractionManager extends AbstractDisplayInteractionManager {
        protected osmdSheetMusicContainer: HTMLElement;
        protected fullOffsetLeft: number;
        protected fullOffsetTop: number;
        protected fullScrollTop: number;
        protected fullScrollLeft: number;
        protected parentScrollMap: Map<HTMLElement, number[]>;
        protected scrollCallbackMap: Map<HTMLElement, (this: HTMLElement, ev: Event) => any>;
        constructor(osmdContainer: HTMLElement);
        get FullOffsetTop(): number;
        get FullScrollTop(): number;
        get FullOffsetLeft(): number;
        get FullScrollLeft(): number;
        protected timeout: NodeJS.Timeout;
        protected static resizeCallback(entries: ResizeObserverEntry[] | HTMLElement[], self: WebDisplayInteractionManager): void;
        protected registerScrollOffsets(): void;
        protected deregisterScrollOffsets(): void;
        protected disposeResizeListener: Function;
        protected resizeObserver: ResizeObserver;
        protected initialize(): void;
        protected dispose(): void;
        protected get downEventName(): string;
        protected get moveEventName(): string;
        protected EventCallbackMap: Dictionary<string, [HTMLElement | Document, EventListener]>;
    }
}

declare module 'opensheetmusicdisplay/Playback/PlaybackManager' {
    import { ITimingSource } from "opensheetmusicdisplay/Common/Interfaces/ITimingSource";
    import { IMessageViewer } from "opensheetmusicdisplay/Common/Interfaces/IMessageViewer";
    import { IAudioPlayer } from "opensheetmusicdisplay/Common/Interfaces/IAudioPlayer";
    import { MusicPartManager, MusicPartManagerIterator } from "opensheetmusicdisplay/MusicalScore/MusicParts";
    import { Dictionary } from "typescript-collections";
    import { VoiceEntry, MidiInstrument } from "opensheetmusicdisplay/MusicalScore/VoiceData";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects";
    import { Instrument } from "opensheetmusicdisplay/MusicalScore";
    import { PlaybackNote } from "opensheetmusicdisplay/MusicalScore/Playback/PlaybackNote";
    import { IAudioMetronomePlayer } from "opensheetmusicdisplay/Common/Interfaces/IAudioMetronomePlayer";
    import { ISettableInstrument } from "opensheetmusicdisplay/Common/Interfaces/ISettableInstrument";
    import { PlaybackState } from "opensheetmusicdisplay/Common/Enums/PsEnums";
    import { IPlaybackListener } from "opensheetmusicdisplay/Common/Interfaces/IPlaybackListener";
    import { IPlaybackParametersListener } from "opensheetmusicdisplay/Common/Interfaces/IPlaybackParametersListener";
    export class ChannelNote {
            note: PlaybackNote;
            key: number;
            channel: number;
            constructor(k: number, c: number, n?: PlaybackNote);
    }
    export class PlaybackManager implements IPlaybackParametersListener {
            protected timingSource: ITimingSource;
            protected resetRequested: boolean;
            protected loopTriggeredReset: boolean;
            protected tempoUserFactor: number;
            protected currentBPM: number;
            protected overrideBPM: number;
            protected listeners: IPlaybackListener[];
            addListener(listener: IPlaybackListener): void;
            removeListener(listenerToRemove: IPlaybackListener): void;
            get CursorIterator(): MusicPartManagerIterator;
            get InstrumentIdMapping(): Dictionary<number, Instrument>;
            protected runningState: PlaybackState;
            /** Whether a dummy sound was played to initialize the audio context / enable sound (on iOS). */
            DummySoundPlayed: boolean;
            StopAtUnrenderedMeasures: boolean;
            MoveCursorDuringPrecount: boolean;
            IgnoreFixedInstrumentKeysForPercussion: boolean;
            constructor(timingSource: ITimingSource, audioMetronomePlayer: IAudioMetronomePlayer, audioPlayer: IAudioPlayer<any>, messageViewer: IMessageViewer);
            get RunningState(): PlaybackState;
            set RunningState(value: PlaybackState);
            DoPlayback: boolean;
            /** Do the initial pre-count */
            get DoPreCount(): boolean;
            set DoPreCount(value: boolean);
            PreCountMeasures: number;
            PreCountBeats: number;
            get Metronome(): ISettableInstrument;
            get MetronomeOnlyBPM(): number;
            set MetronomeOnlyBPM(value: number);
            get OriginalBpm(): number;
            /** will be activated when any solo flag of an Instrument, Voice or Staff is set to true. */
            SoloActive: boolean;
            SoloAttenuationValue: number;
            /** Play dummy sound to initialize audio context (e.g. on user click for iOS) */
            playDummySound(): void;
            playVoiceEntry(voiceEntry: VoiceEntry): void;
            initialize(musicPartMng: MusicPartManager): void;
            play(): Promise<void>;
            pause(): Promise<void>;
            /** Effectively resets the playback to osmd.Sheet.SelectionStart.
                *  If you want to reset to the start of the sheet,
                *    call osmd.Sheet.SelectionStart = osmd.Sheet.sourceMeasures[0].AbsoluteTimestamp beforehand.
                */
            reset(): void;
            /** Starts play() from a time in milliseconds.*/
            playFromMs(timeInMs: number): Promise<void>;
            getTimestampFromMs(timeInMs: number): Fraction;
            /** Sets the cursor and MusicSheet.SelectionStart to the target timestamp (fraction),
                *  but does not start playback if it was not started already.
                *  To get the timestamp from milliseconds, use getTimestampFromMs().
                *  To reset the playback start to the beginning of the sheet, call the function without arguments.
                */
            setPlaybackStart(timestamp?: Fraction): void;
            Dispose(): void;
            setSound(instrumentId: number, newSoundId: MidiInstrument): boolean;
            protected setBpm(bpm: number): void;
            handlePlaybackEvent(): void;
            calculateFinalVolume(volume: number): number;
            protected doReset(shallPrecount: boolean, preCountMeasures?: number): void;
            protected handleEndReached(): void;
            bpmChanged(newBpm: number, sheetOverride: boolean): void;
            volumeChanged(instrument: number, newVolume: number): void;
            volumeMute(instrument: number): void;
            volumeUnmute(instrument: number): void;
            protected setTempo(): void;
            protected getCurrentReferenceBPM(): number;
            checkForSoloDeactivated(): void;
            /** Returns the duration of the piece in ms (by each measure's bpm, without repeats).
                *  The result may be inaccurate if you haven't set the bpm to the first measure's bpm before playback (or the other way round).
                *  In that case, getSheetDurationInMsEvenBpm() can be more accurate (previous version of this method)
                */
            getSheetDurationInMs(withRepeats?: boolean): number;
            getSheetDurationInMsWithRepeats(): number;
            /** Returns the sheet duration of the piece in ms given the tempo set via setBpm() doesn't change. */
            getSheetDurationInMsEvenBpm(): number;
    }
}

declare module 'opensheetmusicdisplay/Playback/BasicAudioPlayer' {
    import { MidiInstrument } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { IAudioPlayer } from "opensheetmusicdisplay/Common/Interfaces/IAudioPlayer";
    import * as SoundfontPlayer from "soundfont-player";
    export class BasicAudioPlayer implements IAudioPlayer<SoundfontPlayer.Player> {
        ac: AudioContext;
        protected memoryLoadedSoundFonts: Map<MidiInstrument, SoundfontPlayer.Player>;
        protected channelToSoundFont: Map<number, number>;
        SoundfontInstrumentOptions: {
            from: any;
            nameToUrl: any;
        };
        /** Multiplicator for gain (volume output). 1 represents the maximum volume in OSMD (100%),
          *  but it looks like soundfont-player is louder with volumes > 1.
          *  E.g. set osmd.PlaybackManager.audioPlayer.GainMultiplier to 3 if you think the player is too quiet. */
        GainMultiplier: number;
        constructor();
        open(uniqueInstruments: number[], numberOfinstruments?: number): Promise<void>;
        close(): void;
        tuningChanged(tuningInHz: number): void;
        playSound(instrumentChannel: number, key: number, volume: number, lengthInMs: number): void;
        stopSound(instrumentChannel: number, volume: number): void;
        setSound(instrumentChannel: number, soundId: MidiInstrument): Promise<void>;
        loadSoundFont(soundId: MidiInstrument): Promise<SoundfontPlayer.Player>;
        /** Returns the url for the instrument name's soundfont to be loaded. */
        nameToSoundfontUrl(name: string, font: string, format: string): string;
        setVolume(instrumentChannel: number, volume: number): void;
        setSoundFontFilePath(soundId: MidiInstrument, path: string): void;
        playbackHasStopped(): void;
        getMemoryLoadedSoundFonts(): SoundfontPlayer.Player[];
    }
}

declare module 'opensheetmusicdisplay/Playback/TimingSources/LinearTimingSource' {
    import { AbstractTimingSource } from "opensheetmusicdisplay/Playback/TimingSources/AbstractTimingSource";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects";
    export class LinearTimingSource extends AbstractTimingSource {
        logEnabled: boolean;
        constructor();
        getCurrentTimeInMs(): number;
        getCurrentAudioDelayRevisedTimestamp(): Fraction;
        getTimestampForTimeInMs(timesInMs: number): Fraction;
        start(): Promise<void>;
        pause(): Promise<void>;
        reset(): void;
    }
}

declare module 'opensheetmusicdisplay/Playback/UIComponents/ControlPanel/ControlPanel' {
    import { AUIController } from "opensheetmusicdisplay/MusicalScore/Interfaces/AUIController";
    import { IPlaybackParametersListener } from "opensheetmusicdisplay/Common/Interfaces/IPlaybackParametersListener";
    import { CursorPosChangedData } from "opensheetmusicdisplay/Common/DataObjects/CursorPosChangedData";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { IPlaybackListener } from "opensheetmusicdisplay/Common/Interfaces/IPlaybackListener";
    export class ControlPanel extends AUIController<IPlaybackParametersListener> implements IPlaybackParametersListener, IPlaybackListener {
        volumeMute(instrument: number): void;
        volumeUnmute(instrument: number): void;
        bpmChanged(newNpm: number, sheetOverride: boolean): void;
        volumeChanged(channels: number, newVolume: number): void;
        play(): Promise<void>;
        pause(): Promise<void>;
        reset(): void;
        get IsClosed(): boolean;
        clearVolumeTracks(): void;
        addVolumeTrack(name: string, id: number, value?: number): void;
        protected initialize(): void;
        hideAndClear(): void;
        show(): void;
        cursorPositionChanged(timestamp: Fraction, data: CursorPosChangedData): void;
        pauseOccurred(o: object): void;
        selectionEndReached(o: object): void;
        resetOccurred(o: object): void;
        notesPlaybackEventOccurred(o: object): void;
    }
}

declare module 'opensheetmusicdisplay/Plugins/Transpose' {
    export * from "opensheetmusicdisplay/Plugins/Transpose/TransposeCalculator";
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicParts/MusicPartManagerIterator' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { Repetition } from "opensheetmusicdisplay/MusicalScore/MusicSource/Repetition";
    import { DynamicsContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/HelperObjects/DynamicsContainer";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { MultiTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiTempoExpression";
    import { AbstractExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { PlaybackSettings } from "opensheetmusicdisplay/Common/DataObjects/PlaybackSettings";
    export class MusicPartManagerIterator {
            constructor(musicSheet: MusicSheet, startTimestamp?: Fraction, endTimestamp?: Fraction);
            backJumpOccurred: boolean;
            forwardJumpOccurred: boolean;
            currentTimeStamp: Fraction;
            SkipInvisibleNotes: boolean;
            get EndReached(): boolean;
            get FrontReached(): boolean;
            get CurrentMeasure(): SourceMeasure;
            get CurrentRepetition(): Repetition;
            get CurrentRepetitionIteration(): number;
            get CurrentJumpResponsibleRepetitionIterationBeforeJump(): number;
            get CurrentBpm(): number;
            get CurrentVoiceEntries(): VoiceEntry[];
            get CurrentMeasureIndex(): number;
            get CurrentEnrolledTimestamp(): Fraction;
            get CurrentSourceTimestamp(): Fraction;
            get CurrentRelativeInMeasureTimestamp(): Fraction;
            get JumpOccurred(): boolean;
            get ActiveTempoExpression(): MultiTempoExpression;
            get ActiveDynamicExpressions(): AbstractExpression[];
            get CurrentTempoChangingExpression(): MultiTempoExpression;
            get JumpResponsibleRepetition(): Repetition;
            /**
                * Creates a clone of this iterator which has the same actual position.
                */
            clone(startTimeStamp?: Fraction, endTimeStamp?: Fraction): MusicPartManagerIterator;
            /**
                * Returns the visible voice entries for the provided instrument of the current iterator position.
                * @param instrument
                * Returns: A List of voiceEntries. If there are no entries the List has a Count of 0 (it does not return null).
                */
            CurrentVisibleVoiceEntries(instrument?: Instrument): VoiceEntry[];
            /**
                * Returns the audible voice entries for the provided instrument of the current iterator position.
                * @param instrument
                * Returns: A List of voiceEntries. If there are no entries the List has a Count of 0 (it does not return null).
                */
            CurrentAudibleVoiceEntries(instrument?: Instrument): VoiceEntry[];
            /**
                * Returns the audible dynamics of the current iterator position.
                * Returns: A List of Dynamics. If there are no entries the List has a Count of 0 (it does not return null).
                */
            getCurrentDynamicChangingExpressions(): DynamicsContainer[];
            /**
                * Returns the score following voice entries for the provided instrument of the current iterator position.
                * @param instrument
                * Returns: A List of voiceEntries. If there are no entries the List has a Count of 0
                * (it does not return null).
                */
            CurrentScoreFollowingVoiceEntries(instrument?: Instrument): VoiceEntry[];
            currentPlaybackSettings(): PlaybackSettings;
            moveToPrevious(): void;
            moveToPreviousVisibleVoiceEntry(notesOnly: boolean): void;
            moveToNext(): void;
            moveToNextVisibleVoiceEntry(notesOnly: boolean): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicParts/MusicPartManager' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { PartListEntry } from "opensheetmusicdisplay/MusicalScore/MusicSource/PartListEntry";
    import { Repetition } from "opensheetmusicdisplay/MusicalScore/MusicSource/Repetition";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { MusicPartManagerIterator } from "opensheetmusicdisplay/MusicalScore/MusicParts/MusicPartManagerIterator";
    export class MusicPartManager {
            constructor(musicSheet: MusicSheet);
            /**
                * This method is called from CoreContainer when the user changes a Repetitions's userNumberOfRepetitions.
                */
            reInit(): void;
            /**
                * Main initialize method for MusicPartManager.
                */
            init(): void;
            getCurrentRepetitionTimestampTransform(curEnrolledTimestamp: Fraction): TimestampTransform;
            absoluteEnrolledToSheetTimestamp(timestamp: Fraction): Fraction;
            get Parts(): PartListEntry[];
            get MusicSheet(): MusicSheet;
            getIterator(start?: Fraction): MusicPartManagerIterator;
            setSelectionStart(beginning: Fraction): void;
            setSelectionRange(start: Fraction, end: Fraction): void;
    }
    export class TimestampTransform {
            constructor(sourceTimestamp: Fraction, enrolledTimestamp: Fraction, repetition: Repetition, curRepetitionIteration: number);
            from: Fraction;
            to: Fraction;
            nextBackJump: Fraction;
            nextForwardJump: Fraction;
            curRepetition: Repetition;
            curRepetitionIteration: number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { LyricsEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsEntry";
    import { TechnicalInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/TechnicalInstruction";
    import { OrnamentContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/OrnamentContainer";
    import { Dictionary } from "typescript-collections";
    import { Arpeggio } from "opensheetmusicdisplay/MusicalScore/VoiceData/Arpeggio";
    import { PlaybackEntry } from "opensheetmusicdisplay/MusicalScore/Playback/PlaybackEntry";
    import { Articulation } from "opensheetmusicdisplay/MusicalScore/VoiceData/Articulation";
    /**
        * A [[VoiceEntry]] contains the notes in a voice at a timestamp.
        */
    export class VoiceEntry {
            /**
                *
                * @param timestamp The relative timestamp within the source measure.
                * @param parentVoice
                * @param parentSourceStaffEntry
                * @param isGrace States whether the VoiceEntry has (only) grace notes.
                * @param graceNoteSlash States whether the grace note(s) have a slash (Acciaccatura, played before the beat)
                */
            constructor(timestamp: Fraction, parentVoice: Voice, parentSourceStaffEntry: SourceStaffEntry, addToStaffEntry?: boolean, isGrace?: boolean, graceNoteSlash?: boolean, graceSlur?: boolean);
            get ParentSourceStaffEntry(): SourceStaffEntry;
            get ParentVoice(): Voice;
            get Timestamp(): Fraction;
            set Timestamp(value: Fraction);
            get Notes(): Note[];
            addNote(note: Note): void;
            get GraceVoiceEntriesBefore(): VoiceEntry[];
            set GraceVoiceEntriesBefore(value: VoiceEntry[]);
            get GraceVoiceEntriesAfter(): VoiceEntry[];
            set GraceVoiceEntriesAfter(value: VoiceEntry[]);
            get IsGrace(): boolean;
            set IsGrace(value: boolean);
            get GraceAfterMainNote(): boolean;
            set GraceAfterMainNote(value: boolean);
            get GraceNoteSlash(): boolean;
            set GraceNoteSlash(value: boolean);
            get GraceSlur(): boolean;
            set GraceSlur(value: boolean);
            get Articulations(): Articulation[];
            /** Stores all playback entries (e.g. extra grace and ornament entries).
                * Also holds the main playback entry.
                * The entries are sorted in ascending timestamp.
                */
            get PlaybackEntries(): PlaybackEntry[];
            get Fermata(): Articulation;
            get MainPlaybackEntry(): PlaybackEntry;
            set MainPlaybackEntry(value: PlaybackEntry);
            removeMainPlaybackEntry(): void;
            removePlaybackEntry(value: PlaybackEntry): void;
            set Articulations(value: Articulation[]);
            get TechnicalInstructions(): TechnicalInstruction[];
            get LyricsEntries(): Dictionary<string, LyricsEntry>;
            get Arpeggio(): Arpeggio;
            set Arpeggio(value: Arpeggio);
            get OrnamentContainer(): OrnamentContainer;
            set OrnamentContainer(value: OrnamentContainer);
            set WantedStemDirection(value: StemDirectionType);
            get WantedStemDirection(): StemDirectionType;
            set StemDirectionXml(value: StemDirectionType);
            get StemDirectionXml(): StemDirectionType;
            set StemDirection(value: StemDirectionType);
            get StemDirection(): StemDirectionType;
            get StemColorXml(): string;
            set StemColorXml(value: string);
            get StemColor(): string;
            set StemColor(value: string);
            get VolumeModifier(): Articulation;
            set VolumeModifier(value: Articulation);
            get DurationModifier(): Articulation;
            set DurationModifier(value: Articulation);
            hasArticulation(articulation: Articulation): boolean;
            static isSupportedArticulation(articulation: ArticulationEnum): boolean;
            hasTie(): boolean;
            hasSlur(): boolean;
            isStaccato(): boolean;
            isAccent(): boolean;
            getVerseNumberForLyricEntry(lyricsEntry: LyricsEntry): string;
    }
    export enum ArticulationEnum {
            accent = 0,
            strongaccent = 1,
            softaccent = 2,
            marcatoup = 3,
            marcatodown = 4,
            invertedstrongaccent = 5,
            staccato = 6,
            staccatissimo = 7,
            spiccato = 8,
            tenuto = 9,
            fermata = 10,
            invertedfermata = 11,
            breathmark = 12,
            caesura = 13,
            lefthandpizzicato = 14,
            naturalharmonic = 15,
            snappizzicato = 16,
            upbow = 17,
            downbow = 18,
            scoop = 19,
            plop = 20,
            doit = 21,
            falloff = 22,
            stress = 23,
            unstress = 24,
            detachedlegato = 25,
            otherarticulation = 26,
            bend = 27
    }
    export enum StemDirectionType {
            Undefined = -1,
            Up = 0,
            Down = 1,
            None = 2,
            Double = 3
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem' {
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { InstrumentalGroup } from "opensheetmusicdisplay/MusicalScore/InstrumentalGroup";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { SystemLinesEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    import Dictionary from "typescript-collections/dist/lib/Dictionary";
    import { GraphicalMarkedArea } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMarkedArea";
    import { SystemLine } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLine";
    import { SystemLinePosition } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinePosition";
    /**
        * A MusicSystem contains the [[StaffLine]]s for all instruments, until a line break
        */
    export abstract class MusicSystem extends GraphicalObject {
            needsToBeRedrawn: boolean;
            rules: EngravingRules;
            protected parent: GraphicalMusicPage;
            protected id: number;
            protected staffLines: StaffLine[];
            protected graphicalMeasures: GraphicalMeasure[][];
            /** Dictionary of (Instruments and) labels.
                * note that the key needs to be unique, GraphicalLabel is not unique yet.
                * That is why the labels are labels.values() and not labels.keys().
                */
            protected labels: Dictionary<Instrument, GraphicalLabel>;
            protected measureNumberLabels: GraphicalLabel[];
            protected maxLabelLength: number;
            protected objectsToRedraw: [Object[], Object][];
            protected instrumentBrackets: GraphicalObject[];
            protected groupBrackets: GraphicalObject[];
            protected graphicalMarkedAreas: GraphicalMarkedArea[];
            protected systemLines: SystemLine[];
            breaksPage: boolean;
            constructor(id: number);
            get Parent(): GraphicalMusicPage;
            set Parent(value: GraphicalMusicPage);
            get NextSystem(): MusicSystem;
            get StaffLines(): StaffLine[];
            get GraphicalMeasures(): GraphicalMeasure[][];
            get MeasureNumberLabels(): GraphicalLabel[];
            get Labels(): GraphicalLabel[];
            get ObjectsToRedraw(): [Object[], Object][];
            get InstrumentBrackets(): GraphicalObject[];
            get GroupBrackets(): GraphicalObject[];
            get GraphicalMarkedAreas(): GraphicalMarkedArea[];
            get SystemLines(): SystemLine[];
            get Id(): number;
            /**
                * Create the left vertical Line connecting all staves of the [[MusicSystem]].
                * @param lineWidth
                * @param systemLabelsRightMargin
                */
            createSystemLeftLine(lineWidth: number, systemLabelsRightMargin: number, isFirstSystem: boolean): void;
            /**
                * Create the vertical Lines after the End of all [[StaffLine]]'s Measures
                * @param xPosition
                * @param lineWidth
                * @param lineType
                * @param linePosition indicates if the line belongs to start or end of measure
                * @param measureIndex the measure index within the staffline
                * @param measure
                */
            createVerticalLineForMeasure(xPosition: number, lineWidth: number, lineType: SystemLinesEnum, linePosition: SystemLinePosition, measureIndex: number, measure: GraphicalMeasure): void;
            /**
                * Set the y-Positions of all the system lines in the system and creates the graphical Lines and dots within.
                * @param rules
                */
            setYPositionsToVerticalLineObjectsAndCreateLines(rules: EngravingRules): void;
            calculateBorders(rules: EngravingRules): void;
            alignBeginInstructions(): void;
            GetLeftBorderAbsoluteXPosition(): number;
            GetRightBorderAbsoluteXPosition(): number;
            AddGraphicalMeasures(graphicalMeasures: GraphicalMeasure[]): void;
            GetSystemsFirstTimeStamp(): Fraction;
            GetSystemsLastTimeStamp(): Fraction;
            /**
                * Create an InstrumentBracket for each multiStave Instrument.
                * @param instruments
                * @param staffHeight
                */
            createInstrumentBrackets(instruments: Instrument[], staffHeight: number): void;
            /**
                * Create a GroupBracket for an [[InstrumentalGroup]].
                * @param instrumentGroups
                * @param staffHeight
                * @param recursionDepth
                */
            createGroupBrackets(instrumentGroups: InstrumentalGroup[], staffHeight: number, recursionDepth: number): void;
            /**
                * Create the Instrument's Labels (only for the first [[MusicSystem]] of the first MusicPage).
                * @param instrumentLabelTextHeight
                * @param systemLabelsRightMargin
                * @param labelMarginBorderFactor
                */
            createMusicSystemLabel(instrumentLabelTextHeight: number, systemLabelsRightMargin: number, labelMarginBorderFactor: number, isFirstSystem?: boolean): void;
            /**
                * Set the Y-Positions for the MusicSystem's Labels.
                */
            setMusicSystemLabelsYPosition(): void;
            /**
                * Check if two "adjacent" StaffLines have BOTH a StaffEntry with a StaffEntryLink.
                * This is needed for the y-spacing algorithm.
                * @returns {boolean}
                */
            checkStaffEntriesForStaffEntryLink(): boolean;
            getBottomStaffLine(topStaffLine: StaffLine): StaffLine;
            /**
                * Here the system line is generated, which acts as the container of graphical lines and dots that will be finally rendered.
                * It holds al the logical parameters of the system line.
                * @param xPosition The x position within the system
                * @param lineWidth The total x width
                * @param lineType The line type enum
                * @param linePosition indicates if the line belongs to start or end of measure
                * @param musicSystem
                * @param topMeasure
                * @param bottomMeasure
                */
            protected createSystemLine(xPosition: number, lineWidth: number, lineType: SystemLinesEnum, linePosition: SystemLinePosition, musicSystem: MusicSystem, topMeasure: GraphicalMeasure, bottomMeasure?: GraphicalMeasure): SystemLine;
            /**
                * Create all the graphical lines and dots needed to render a system line (e.g. bold-thin-dots..).
                * @param systemLine
                */
            protected createLinesForSystemLine(systemLine: SystemLine): void;
            /**
                * Calculates the summed x-width of a possibly given Instrument Brace and/or Group Bracket(s).
                * @returns {number} the x-width
                */
            protected calcBracketsWidth(): number;
            protected createInstrumentBracket(firstStaffLine: StaffLine, lastStaffLine: StaffLine): void;
            protected createGroupBracket(firstStaffLine: StaffLine, lastStaffLine: StaffLine, recursionDepth: number): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { VerticalGraphicalStaffEntryContainer } from "opensheetmusicdisplay/MusicalScore/Graphical/VerticalGraphicalStaffEntryContainer";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { GraphicalLine } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { MusicSheetCalculator } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSheetCalculator";
    import { SelectionStartSymbol } from "opensheetmusicdisplay/MusicalScore/Graphical/SelectionStartSymbol";
    import { SelectionEndSymbol } from "opensheetmusicdisplay/MusicalScore/Graphical/SelectionEndSymbol";
    import { OutlineAndFillStyleEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums";
    import { Clickable } from "opensheetmusicdisplay/MusicalScore/Graphical/Clickable";
    import { MusicSheetDrawer } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSheetDrawer";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    /**
        * The graphical counterpart of a [[MusicSheet]]
        */
    export class GraphicalMusicSheet {
            constructor(musicSheet: MusicSheet, calculator: MusicSheetCalculator);
            drawer: MusicSheetDrawer;
            get ParentMusicSheet(): MusicSheet;
            get GetCalculator(): MusicSheetCalculator;
            get MusicPages(): GraphicalMusicPage[];
            set MusicPages(value: GraphicalMusicPage[]);
            get MeasureList(): GraphicalMeasure[][];
            set MeasureList(value: GraphicalMeasure[][]);
            get VerticalGraphicalStaffEntryContainers(): VerticalGraphicalStaffEntryContainer[];
            set VerticalGraphicalStaffEntryContainers(value: VerticalGraphicalStaffEntryContainer[]);
            get Title(): GraphicalLabel;
            set Title(value: GraphicalLabel);
            get Subtitle(): GraphicalLabel;
            set Subtitle(value: GraphicalLabel);
            get Composer(): GraphicalLabel;
            set Composer(value: GraphicalLabel);
            get Lyricist(): GraphicalLabel;
            set Lyricist(value: GraphicalLabel);
            get Copyright(): GraphicalLabel;
            set Copyright(value: GraphicalLabel);
            get Cursors(): GraphicalLine[];
            get SelectionStartSymbol(): SelectionStartSymbol;
            get SelectionEndSymbol(): SelectionEndSymbol;
            get MinAllowedSystemWidth(): number;
            set MinAllowedSystemWidth(value: number);
            get NumberOfStaves(): number;
            get LeadSheet(): boolean;
            set LeadSheet(value: boolean);
            /**
                * Calculate the Absolute Positions from the Relative Positions.
                * @param graphicalMusicSheet
                */
            static transformRelativeToAbsolutePosition(graphicalMusicSheet: GraphicalMusicSheet): void;
            Initialize(): void;
            reCalculate(): void;
            EnforceRedrawOfMusicSystems(): void;
            getClickedObject<T>(positionOnMusicSheet: PointF2D): T;
            findGraphicalMeasure(measureIndex: number, staffIndex: number): GraphicalMeasure;
            /**
                * Search the MeasureList for a certain GraphicalStaffEntry with the given SourceStaffEntry,
                * at a certain verticalIndex (eg a corresponding Staff), starting at a specific horizontalIndex (eg specific GraphicalMeasure).
                * @param staffIndex
                * @param measureIndex
                * @param sourceStaffEntry
                * @returns {any}
                */
            findGraphicalStaffEntryFromMeasureList(staffIndex: number, measureIndex: number, sourceStaffEntry: SourceStaffEntry): GraphicalStaffEntry;
            /**
                * Return the next (to the right) not null GraphicalStaffEntry from a given Index.
                * @param staffIndex
                * @param measureIndex
                * @param graphicalStaffEntry
                * @returns {any}
                */
            findNextGraphicalStaffEntry(staffIndex: number, measureIndex: number, graphicalStaffEntry: GraphicalStaffEntry): GraphicalStaffEntry;
            getFirstVisibleMeasuresListFromIndices(start: number, end: number): GraphicalMeasure[];
            orderMeasuresByStaffLine(measures: GraphicalMeasure[]): GraphicalMeasure[][];
            /**
                * Return the active Clefs at the start of the first SourceMeasure.
                * @returns {ClefInstruction[]}
                */
            initializeActiveClefs(): ClefInstruction[];
            GetMainKey(): KeyInstruction;
            /**
                * Create the VerticalContainer and adds it to the List at the correct Timestamp position.
                * @param timestamp
                * @returns {any}
                */
            getOrCreateVerticalContainer(timestamp: Fraction): VerticalGraphicalStaffEntryContainer;
            /**
                * Does a binary search on the container list and returns the VerticalContainer with the given Timestamp.
                * The search begins at startIndex, if given.
                * If the timestamp cannot be found, null is returned.
                * @param timestamp - The timestamp for which the container shall be found.
                * @param startIndex - The index from which the search starts in the container list.
                * @returns {any}
                * @constructor
                */
            GetVerticalContainerFromTimestamp(timestamp: Fraction, startIndex?: number): VerticalGraphicalStaffEntryContainer;
            /**
                * Perform a binary search for the absolute given Timestamp in all the GraphicalVerticalContainers.
                * @param musicTimestamp
                * @returns {number}
                * @constructor
                */
            GetInterpolatedIndexInVerticalContainers(musicTimestamp: Fraction): number;
            /**
                * Get a List with the indices of all the visible GraphicalMeasures and calculates their
                * corresponding indices in the first SourceMeasure, taking into account Instruments with multiple Staves.
                * @param visibleMeasures
                * @returns {number[]}
                */
            getVisibleStavesIndicesFromSourceMeasure(visibleMeasures: GraphicalMeasure[]): number[];
            /**
                * Returns the GraphicalMeasure with the given SourceMeasure as Parent at the given staff index.
                * @param sourceMeasure
                * @param staffIndex
                * @returns {any}
                */
            getGraphicalMeasureFromSourceMeasureAndIndex(sourceMeasure: SourceMeasure, staffIndex: number): GraphicalMeasure;
            getLastGraphicalMeasureFromIndex(staffIndex: number, lastRendered?: boolean): GraphicalMeasure;
            getMeasureIndex(graphicalMeasure: GraphicalMeasure, measureIndex: number, inListIndex: number): boolean;
            GetNearestVoiceEntry(clickPosition: PointF2D): GraphicalVoiceEntry;
            GetNearestNote(clickPosition: PointF2D, maxClickDist: PointF2D): GraphicalNote;
            domToSvg(point: PointF2D): PointF2D;
            svgToDom(point: PointF2D): PointF2D;
            svgToOsmd(point: PointF2D): PointF2D;
            GetClickableLabel(clickPosition: PointF2D): GraphicalLabel;
            GetPossibleCommentAnchor(clickPosition: PointF2D): SourceStaffEntry;
            GetClickedObjectOfType<T>(positionOnMusicSheet: PointF2D): T;
            GetClickedClickable(positionOnMusicSheet: PointF2D): Clickable;
            tryGetTimestampFromPosition(positionOnMusicSheet: PointF2D): Fraction;
            tryGetClickableLabel(positionOnMusicSheet: PointF2D): GraphicalLabel;
            tryGetTimeStampFromPosition(positionOnMusicSheet: PointF2D): Fraction;
            /**
                * Get visible staffentry for the container given by the index.
                * @param index
                * @returns {GraphicalStaffEntry}
                */
            getStaffEntry(index: number): GraphicalStaffEntry;
            /**
                * Returns the index of the closest previous (earlier) vertical container which has at least some visible staff entry, with respect to the given index.
                * @param index
                * @returns {number}
                * @constructor
                */
            GetPreviousVisibleContainerIndex(index: number): number;
            /**
                * Returns the index of the closest next (later) vertical container which has at least some visible staff entry, with respect to the given index.
                * @param index
                * @returns {number}
                * @constructor
                */
            GetNextVisibleContainerIndex(index: number): number;
            findClosestLeftStaffEntry(fractionalIndex: number, searchOnlyVisibleEntries: boolean): GraphicalStaffEntry;
            findClosestRightStaffEntry(fractionalIndex: number, returnOnlyVisibleEntries: boolean): GraphicalStaffEntry;
            calculateCursorLineAtTimestamp(musicTimestamp: Fraction, styleEnum: OutlineAndFillStyleEnum): GraphicalLine;
            calculateXPositionFromTimestamp(timeStamp: Fraction): [number, MusicSystem, GraphicalStaffEntry];
            calculateCursorPoints(xPos: number, correspondingSystem: MusicSystem): [PointF2D, PointF2D];
            GetNumberOfVisibleInstruments(): number;
            GetNumberOfFollowedInstruments(): number;
            GetGraphicalFromSourceStaffEntry(sourceStaffEntry: SourceStaffEntry): GraphicalStaffEntry;
    }
    export class SystemImageProperties {
            positionInPixels: PointF2D;
            systemImageId: number;
            system: MusicSystem;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Note' {
    import { VoiceEntry, StemDirectionType } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { NoteEnum, Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { Beam } from "opensheetmusicdisplay/MusicalScore/VoiceData/Beam";
    import { Tuplet } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tuplet";
    import { Tie } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tie";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { Slur } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Slur";
    import { NoteState } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums";
    import { Notehead } from "opensheetmusicdisplay/MusicalScore/VoiceData/Notehead";
    import { Arpeggio } from "opensheetmusicdisplay/MusicalScore/VoiceData/Arpeggio";
    import { NoteType } from "opensheetmusicdisplay/MusicalScore/VoiceData/NoteType";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { TechnicalInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions";
    import { Glissando } from "opensheetmusicdisplay/MusicalScore/VoiceData/Glissando";
    import { PlaybackNote } from "opensheetmusicdisplay/MusicalScore/Playback/PlaybackNote";
    /**
        * Represents a single pitch with a duration (length)
        */
    export class Note {
            constructor(voiceEntry: VoiceEntry, parentStaffEntry: SourceStaffEntry, length: Fraction, pitch: Pitch, sourceMeasure: SourceMeasure, isRest?: boolean);
            /**
                * The transposed (!!!) HalfTone of this note.
                */
            halfTone: number;
            state: NoteState;
            DotsXml: number;
            IsWholeMeasureRest: boolean;
            /** The transposed pitch, if the score is transposed, otherwise undefined. */
            TransposedPitch: Pitch;
            displayStepUnpitched: NoteEnum;
            displayOctaveUnpitched: number;
            get NoteAsString(): string;
            IsGraceNote: boolean;
            /** The number of tremolo strokes this note has (16th tremolo = 2 strokes).
                * Could be a Tremolo object in future when there is more data like tremolo between two notes.
                */
            TremoloInfo: TremoloInfo;
            Fingering: TechnicalInstruction;
            StringInstruction: TechnicalInstruction;
            /** Used by GraphicalNote.FromNote(note) and osmd.rules.GNote(note) to get a GraphicalNote from a Note.
                *  Note that we don't want the data model (Note) to be dependent on the graphical implementation (GraphicalNote),
                *    and have (potentially circular) import dependencies of graphical parts, which also applies to other non-graphical classes.
                *    That's why we don't save a GraphicalNote reference directly in Note.
                */
            NoteToGraphicalNoteObjectId: number;
            ToStringShort(octaveOffset?: number): string;
            get ToStringShortGet(): string;
            get ParentVoiceEntry(): VoiceEntry;
            set ParentVoiceEntry(value: VoiceEntry);
            get ParentStaffEntry(): SourceStaffEntry;
            get ParentStaff(): Staff;
            get Length(): Fraction;
            set PlaybackNote(value: PlaybackNote);
            get PlaybackNote(): PlaybackNote;
            set Length(value: Fraction);
            get SourceMeasure(): SourceMeasure;
            get TypeLength(): Fraction;
            set TypeLength(value: Fraction);
            get NoteTypeXml(): NoteType;
            set NoteTypeXml(value: NoteType);
            get NormalNotes(): number;
            set NormalNotes(value: number);
            get Pitch(): Pitch;
            get NoteBeam(): Beam;
            set NoteBeam(value: Beam);
            set Notehead(value: Notehead);
            get Notehead(): Notehead;
            get NoteTuplet(): Tuplet;
            set NoteTuplet(value: Tuplet);
            get NoteGlissando(): Glissando;
            set NoteGlissando(value: Glissando);
            get NoteTie(): Tie;
            set NoteTie(value: Tie);
            get NoteSlurs(): Slur[];
            set NoteSlurs(value: Slur[]);
            get PlaybackInstrumentId(): string;
            set PlaybackInstrumentId(value: string);
            get PrintObject(): boolean;
            set PrintObject(value: boolean);
            get Arpeggio(): Arpeggio;
            set Arpeggio(value: Arpeggio);
            get IsCueNote(): boolean;
            set IsCueNote(value: boolean);
            get StemDirectionXml(): StemDirectionType;
            set StemDirectionXml(value: StemDirectionType);
            get TremoloStrokes(): number;
            get StemColorXml(): string;
            set StemColorXml(value: string);
            get NoteheadColorXml(): string;
            set NoteheadColorXml(value: string);
            /** The desired notehead color for the next render. */
            get NoteheadColor(): string;
            set NoteheadColor(value: string);
            get NoteheadColorCurrentlyRendered(): string;
            set NoteheadColorCurrentlyRendered(value: string);
            isRest(): boolean;
            /** Note: May be dangerous to use if ParentStaffEntry.VerticalContainerParent etc is not set.
                * better calculate this directly when you have access to the note's measure.
                * whole rest: length = measure length. (4/4 in a 4/4 time signature, 3/4 in a 3/4 time signature, 1/4 in a 1/4 time signature, etc.)
                */
            isWholeRest(): boolean;
            /** Whether the note fills the whole measure. */
            isWholeMeasureNote(): boolean;
            ToString(): string;
            getAbsoluteTimestamp(): Fraction;
            isDuplicateSlur(slur: Slur): boolean;
            hasTabEffects(): boolean;
    }
    export enum Appearance {
            Normal = 0,
            Grace = 1,
            Cue = 2
    }
    export interface TremoloInfo {
            tremoloStrokes: number;
            /** Buzz roll (type="unmeasured" in XML) */
            tremoloUnmeasured: boolean;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/Fraction' {
    /**
        * A class representing mathematical fractions, which have a numerator and a denominator.
        */
    export class Fraction {
            /**
                * Returns the maximum of two fractions (does not clone)
                * @param f1
                * @param f2
                * @returns {Fraction}
                */
            static max(f1: Fraction, f2: Fraction): Fraction;
            static Equal(f1: Fraction, f2: Fraction): boolean;
            /**
                * The same as Fraction.clone
                * @param fraction
                * @returns {Fraction}
                */
            static createFromFraction(fraction: Fraction): Fraction;
            static plus(f1: Fraction, f2: Fraction): Fraction;
            static minus(f1: Fraction, f2: Fraction): Fraction;
            static multiply(f1: Fraction, f2: Fraction): Fraction;
            /**
                *
                * @param numerator
                * @param denominator
                * @param wholeValue - the integer number, needed for values greater than 1
                * @param simplify - If simplify is true, then the fraction is simplified
                * to make both the numerator and denominator coprime, and less than maximumAllowedNumber.
                */
            constructor(numerator?: number, denominator?: number, wholeValue?: number, simplify?: boolean);
            toString(): string;
            clone(): Fraction;
            get Numerator(): number;
            set Numerator(value: number);
            get Denominator(): number;
            set Denominator(value: number);
            get WholeValue(): number;
            set WholeValue(value: number);
            /**
                * Returns the unified numerator where the whole value will be expanded
                * with the denominator and added to the existing numerator.
                */
            GetExpandedNumerator(): number;
            calculateNumberOfNeededDots(): number;
            IsNegative(): boolean;
            get RealValue(): number;
            expand(expansionValue: number): void;
            /**
                * Adds a Fraction to this Fraction.
                * Attention: This changes the already existing Fraction, which might be referenced elsewhere!
                * Use Fraction.plus() for creating a new Fraction object being the sum of two Fractions.
                * @param fraction the Fraction to add.
                */
            Add(fraction: Fraction): Fraction;
            /**
                * Subtracts a Fraction from this Fraction.
                * Attention: This changes the already existing Fraction, which might be referenced elsewhere!
                * Use Fraction.minus() for creating a new Fraction object being the difference of two Fractions.
                * @param fraction the Fraction to subtract.
                */
            Sub(fraction: Fraction): Fraction;
            /**
                * Creates a new Fraction which is half as long as this Fraction
                */
            getHalfLength(): Fraction;
            /**
                * Brute Force quanization by searching incremental with the numerator until the denominator is
                * smaller/equal than the desired one.
                * @param maxAllowedDenominator
                */
            Quantize(maxAllowedDenominator: number): Fraction;
            Equals(obj: Fraction): boolean;
            CompareTo(obj: Fraction): number;
            lt(frac: Fraction): boolean;
            lte(frac: Fraction): boolean;
            gt(frac: Fraction): boolean;
            gte(frac: Fraction): boolean;
            static FloatInaccuracyTolerance: number;
            isOnBeat(timeSignature: Fraction): boolean;
            distanceFromBeat(timeSignature: Fraction): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox' {
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { SizeF2D } from "opensheetmusicdisplay/Common/DataObjects/SizeF2D";
    import { RectangleF2D } from "opensheetmusicdisplay/Common/DataObjects/RectangleF2D";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { Clickable } from "opensheetmusicdisplay/MusicalScore/Graphical/Clickable";
    /**
        * A bounding box delimits an area on the 2D plane.
        * @param dataObject Graphical object where the bounding box will be attached
        * @param parent Parent bounding box of an object in a higher hierarchy position
        * @param connectChildToParent Create a child to parent relationship too. Will be true by default
        */
    export class BoundingBox {
            protected isSymbol: boolean;
            protected relativePositionHasBeenSet: boolean;
            protected xBordersHaveBeenSet: boolean;
            protected yBordersHaveBeenSet: boolean;
            protected absolutePosition: PointF2D;
            protected relativePosition: PointF2D;
            protected size: SizeF2D;
            protected marginSize: SizeF2D;
            protected upperLeftCorner: PointF2D;
            protected upperLeftMarginCorner: PointF2D;
            protected borderLeft: number;
            protected borderRight: number;
            protected borderTop: number;
            protected borderBottom: number;
            protected borderMarginLeft: number;
            protected borderMarginRight: number;
            protected borderMarginTop: number;
            protected borderMarginBottom: number;
            protected boundingRectangle: RectangleF2D;
            protected boundingMarginRectangle: RectangleF2D;
            protected childElements: BoundingBox[];
            protected parent: BoundingBox;
            protected dataObject: Object;
            /**
                * Create a bounding box
                * @param dataObject Graphical object where the bounding box will be attached
                * @param parent Parent bounding box of an object in a higher hierarchy position
                * @param isSymbol Defines the bounding box to be symbol thus not calculating its boundaries by itself. NOTE: Borders need to be set!
                */
            constructor(dataObject?: Object, parent?: BoundingBox, isSymbol?: boolean);
            get RelativePositionHasBeenSet(): boolean;
            get XBordersHaveBeenSet(): boolean;
            set XBordersHaveBeenSet(value: boolean);
            get YBordersHaveBeenSet(): boolean;
            set YBordersHaveBeenSet(value: boolean);
            get AbsolutePosition(): PointF2D;
            set AbsolutePosition(value: PointF2D);
            get RelativePosition(): PointF2D;
            set RelativePosition(value: PointF2D);
            get Size(): SizeF2D;
            set Size(value: SizeF2D);
            get MarginSize(): SizeF2D;
            get UpperLeftCorner(): PointF2D;
            get UpperLeftMarginCorner(): PointF2D;
            get BorderLeft(): number;
            set BorderLeft(value: number);
            get BorderRight(): number;
            set BorderRight(value: number);
            get BorderTop(): number;
            set BorderTop(value: number);
            get BorderBottom(): number;
            set BorderBottom(value: number);
            get BorderMarginLeft(): number;
            set BorderMarginLeft(value: number);
            get BorderMarginRight(): number;
            set BorderMarginRight(value: number);
            get BorderMarginTop(): number;
            set BorderMarginTop(value: number);
            get BorderMarginBottom(): number;
            set BorderMarginBottom(value: number);
            get BoundingRectangle(): RectangleF2D;
            get BoundingMarginRectangle(): RectangleF2D;
            get ChildElements(): BoundingBox[];
            set ChildElements(value: BoundingBox[]);
            get Parent(): BoundingBox;
            set Parent(value: BoundingBox);
            get DataObject(): Object;
            /**
                * Get the center of a bounding box
                * @param boundingBox Bounding box to check
                */
            get Center(): PointF2D;
            setAbsolutePositionFromParent(): void;
            /**
                * Calculate the the absolute position by adding up all relative positions of all parents (including the own rel. pos.)
                */
            calculateAbsolutePosition(): void;
            /**
                * This method calculates the Absolute Positions recursively
                */
            calculateAbsolutePositionsRecursiveWithoutTopelement(): void;
            /**
                * This method calculates the Absolute Positions recursively
                * from the root element down to the leaf elements
                * @param x
                * @param y
                */
            calculateAbsolutePositionsRecursive(x: number, y: number): void;
            /**
                * calculates the absolute positions of all children of this boundingBox
                */
            calculateAbsolutePositionsOfChildren(): void;
            /**
                * This method calculates the BoundingBoxes
                */
            calculateBoundingBox(): void;
            calculateTopBottomBorders(): void;
            /**
                * This method computes the first non-overlapping position in the placementPsi Element for the current (this) positionAndShapeInfo
                * @param placementPsi
                * @param direction
                * @param position
                */
            computeNonOverlappingPositionWithMargin(placementPsi: BoundingBox, direction: ColDirEnum, position: PointF2D): void;
            /**
                * This method detects a collision (without margins)
                * @param psi
                * @returns {boolean}
                */
            collisionDetection(psi: BoundingBox): boolean;
            /**
                * This method checks if the given Psi's Margins lie inside the current Psi's Margins.
                * @param psi
                * @returns {boolean}
                */
            liesInsideBorders(psi: BoundingBox): boolean;
            pointLiesInsideBorders(position: PointF2D): boolean;
            /**
                * This method detects a collision (margin-wide)
                * @param psi
                * @returns {boolean}
                */
            marginCollisionDetection(psi: BoundingBox): boolean;
            /**
                * This method checks if the given Psi's Margins lie inside the current Psi's Margins
                * @param psi
                * @returns {boolean}
                */
            liesInsideMargins(psi: BoundingBox): boolean;
            pointLiesInsideMargins(position: PointF2D): boolean;
            /**
                * This method computes the first non-overlapping position in the placementPsi Element for the current (this) positionAndShapeInfo
                * @param placementPsi
                * @param direction
                * @param position
                */
            computeNonOverlappingPosition(placementPsi: BoundingBox, direction: ColDirEnum, position: PointF2D): void;
            getClickedObjectOfType<T>(clickPosition: PointF2D): T;
            getClickedClickable(clickPosition: PointF2D): Clickable;
            getObjectsInRegion<T extends GraphicalObject>(region: BoundingBox, liesInside?: boolean, className?: string): T[];
            protected calculateRectangle(): void;
            protected calculateMarginRectangle(): void;
    }
    export enum ColDirEnum {
            Left = 0,
            Right = 1,
            Up = 2,
            Down = 3,
            NotYetDefined = 4
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { OctaveEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { AccidentalEnum, Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    /**
        * The graphical counterpart of a [[Note]]
        */
    export class GraphicalNote extends GraphicalObject {
            constructor(note: Note, parent: GraphicalVoiceEntry, rules: EngravingRules, graphicalNoteLength?: Fraction);
            sourceNote: Note;
            DrawnAccidental: AccidentalEnum;
            graphicalNoteLength: Fraction;
            parentVoiceEntry: GraphicalVoiceEntry;
            numberOfDots: number;
            rules: EngravingRules;
            staffLine: number;
            baseFingeringXOffset: number;
            baseStringNumberXOffset: number;
            lineShift: number;
            Transpose(keyInstruction: KeyInstruction, activeClef: ClefInstruction, halfTones: number, octaveEnum: OctaveEnum): Pitch;
            get ParentMusicPage(): GraphicalMusicPage;
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IPlaybackListener' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects";
    import { CursorPosChangedData } from "opensheetmusicdisplay/Common/DataObjects/CursorPosChangedData";
    export interface IPlaybackListener {
        cursorPositionChanged(timestamp: Fraction, data: CursorPosChangedData): void;
        pauseOccurred(o: object): void;
        selectionEndReached(o: object): void;
        resetOccurred(o: object): void;
        notesPlaybackEventOccurred(o: object): void;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/CursorPosChangedData' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { IRepetition } from "opensheetmusicdisplay/Common/Interfaces/IRepetition";
    export class CursorPosChangedData {
        constructor(currentMeasureIndex?: number, currentRepetition?: IRepetition, currentRepetitionIteration?: number, predictedPosition?: Fraction, beatsPerMinute?: number);
        ResetOccurred: boolean;
        CurrentMeasureIndex: number;
        CurrentRepetition: IRepetition;
        CurrentRepetitionIteration: number;
        PredictedPosition: Fraction;
        CurrentBpm: number;
    }
}

declare module 'opensheetmusicdisplay/Common/Enums/ColoringModes' {
    export enum ColoringModes {
        XML = 0,
        AutoColoring = 1,
        CustomColorSet = 2
    }
}

declare module 'opensheetmusicdisplay/Common/Enums/FontStyles' {
    /**
      * The styles available to write text on the music sheet
      */
    export enum FontStyles {
        Regular = 0,
        Bold = 1,
        Italic = 2,
        BoldItalic = 3,
        Underlined = 4
    }
    export const FontStyleString: Object;
}

declare module 'opensheetmusicdisplay/Common/Enums/DrawingParametersEnum' {
    export enum DrawingParametersEnum {
        allon = "allon",
        compact = "compact",
        compacttight = "compacttight",
        default = "default",
        leadsheet = "leadsheet",
        preview = "preview",
        thumbnail = "thumbnail"
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowBackend' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { Fonts } from "opensheetmusicdisplay/Common/Enums/Fonts";
    import { RectangleF2D } from "opensheetmusicdisplay/Common/DataObjects/RectangleF2D";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { BackendType } from "opensheetmusicdisplay/OpenSheetMusicDisplay/OSMDOptions";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class VexFlowBackends {
            static CANVAS: 0;
            static RAPHAEL: 1;
            static SVG: 2;
            static VML: 3;
    }
    export abstract class VexFlowBackend {
            /** The GraphicalMusicPage the backend is drawing from. Each backend only renders one GraphicalMusicPage, to which the coordinates are relative. */
            graphicalMusicPage: GraphicalMusicPage;
            protected rules: EngravingRules;
            width: number;
            height: number;
            abstract initialize(container: HTMLElement, zoom: number): void;
            getInnerElement(): HTMLElement;
            getCanvas(): HTMLElement;
            abstract getCanvasSize(): number;
            getRenderElement(): HTMLElement;
            getRenderer(): VF.Renderer;
            removeAllChildrenFromContainer(container: HTMLElement): void;
            removeFromContainer(container: HTMLElement): void;
            abstract getContext(): Vex.IRenderContext;
            abstract scale(k: number): void;
            resize(width: number, height: number): void;
            abstract clear(): void;
            /** (Try to) free memory. Currently only relevant on iOS. */
            abstract free(): void;
            abstract translate(x: number, y: number): void;
            abstract renderText(fontHeight: number, fontStyle: FontStyles, font: Fonts, text: string, heightInPixel: number, screenPosition: PointF2D, color?: string, fontFamily?: string): Node;
            /**
                * Renders a rectangle with the given style to the screen.
                * It is given in screen coordinates.
                * @param rectangle the rect in screen coordinates
                * @param layer is the current rendering layer. There are many layers on top of each other to which can be rendered. Not needed for now.
                * @param styleId the style id
                * @param alpha alpha value between 0 and 1
                */
            abstract renderRectangle(rectangle: RectangleF2D, styleId: number, colorHex: string, alpha: number): Node;
            abstract renderLine(start: PointF2D, stop: PointF2D, color: string, lineWidth: number, id?: string): Node;
            abstract renderCurve(points: PointF2D[]): Node;
            abstract renderPath(points: PointF2D[], fill: boolean, id?: string): Node;
            abstract getVexflowBackendType(): VF.Renderer.Backends;
            /** The general type of backend: Canvas or SVG.
                * This is not used for now (only VexflowBackendType used), but it may be useful when we don't want to use a Vexflow class.
                */
            abstract getOSMDBackendType(): BackendType;
            protected renderer: VF.Renderer;
            protected inner: HTMLElement;
            protected canvas: HTMLElement;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMusicSheetDrawer' {
    import { LabelRenderSpecs, MusicSheetDrawer } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSheetDrawer";
    import { RectangleF2D } from "opensheetmusicdisplay/Common/DataObjects/RectangleF2D";
    import { VexFlowMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMeasure";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { GraphicalLayers } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { VexFlowBackend } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowBackend";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { GraphicalInstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalInstantaneousDynamicExpression";
    import { VexFlowContinuousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowContinuousDynamicExpression";
    import { DrawingParameters } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingParameters";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { GraphicalMusicSheet } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet";
    /**
        * This is a global constant which denotes the height in pixels of the space between two lines of the stave
        * (when zoom = 1.0)
        * @type number
        */
    export const unitInPixels: number;
    export class VexFlowMusicSheetDrawer extends MusicSheetDrawer {
            get Zoom(): number;
            constructor(drawingParameters?: DrawingParameters);
            get Backends(): VexFlowBackend[];
            protected initializeBackendForPage(page: GraphicalMusicPage): void;
            drawSheet(graphicalMusicSheet: GraphicalMusicSheet): void;
            protected drawPage(page: GraphicalMusicPage): void;
            clear(): void;
            setZoom(zoom: number): void;
            /**
                * Converts a distance from unit to pixel space.
                * @param unitDistance the distance in units
                * @returns {number} the distance in pixels
                */
            calculatePixelDistance(unitDistance: number): number;
            protected drawStaffLine(staffLine: StaffLine): void;
            protected drawMeasure(measure: VexFlowMeasure): void;
            protected drawBuzzRolls(staffEntry: GraphicalStaffEntry, newBuzzRollId: any): number;
            /** Draws a line in the current backend. Only usable while pages are drawn sequentially, because backend reference is updated in that process.
                *  To add your own lines after rendering, use DrawOverlayLine.
                */
            protected drawLine(start: PointF2D, stop: PointF2D, color?: string, lineWidth?: number): Node;
            /** Lets a user/developer draw an overlay line on the score. Use this instead of drawLine, which is for OSMD internally only.
                *  The MusicPage has to be specified, because each page and Vexflow backend has its own relative coordinates.
                *  (the AbsolutePosition of a GraphicalNote is relative to its backend)
                *  To get a MusicPage, use GraphicalNote.ParentMusicPage.
                */
            DrawOverlayLine(start: PointF2D, stop: PointF2D, musicPage: GraphicalMusicPage, color?: string, lineWidth?: number, id?: string): Node;
            DrawPath(inputPoints: PointF2D[], musicPage: GraphicalMusicPage, fill?: boolean, id?: string): Node;
            protected drawSkyLine(staffline: StaffLine): void;
            protected drawBottomLine(staffline: StaffLine): void;
            protected drawInstrumentBrace(brace: GraphicalObject, system: MusicSystem): void;
            protected drawGroupBracket(bracket: GraphicalObject, system: MusicSystem): void;
            protected drawOctaveShifts(staffLine: StaffLine): void;
            protected drawPedals(staffLine: StaffLine): void;
            protected drawWavyLines(staffLine: StaffLine): void;
            protected drawExpressions(staffline: StaffLine): void;
            protected drawInstantaneousDynamic(instantaneousDynamic: GraphicalInstantaneousDynamicExpression): void;
            protected drawContinuousDynamic(graphicalExpression: VexFlowContinuousDynamicExpression): void;
            /**
                * Renders a Label to the screen (e.g. Title, composer..)
                * @param graphicalLabel holds the label string, the text height in units and the font parameters
                * @param layer is the current rendering layer. There are many layers on top of each other to which can be rendered. Not needed for now.
                * @param bitmapWidth Not needed for now.
                * @param bitmapHeight Not needed for now.
                * @param heightInPixel the height of the text in screen coordinates
                * @param screenPosition the position of the lower left corner of the text in screen coordinates
                */
            protected renderLabel(graphicalLabel: GraphicalLabel, layer: GraphicalLayers, specs: LabelRenderSpecs): Node;
            /**
                * Renders a rectangle with the given style to the screen.
                * It is given in screen coordinates.
                * @param rectangle the rect in screen coordinates
                * @param layer is the current rendering layer. There are many layers on top of each other to which can be rendered. Not needed for now.
                * @param styleId the style id
                * @param alpha alpha value between 0 and 1
                */
            protected renderRectangle(rectangle: RectangleF2D, layer: number, styleId: number, colorHex: string, alpha: number): Node;
            /**
                * Converts a point from unit to pixel space.
                * @param point
                * @returns {PointF2D}
                */
            protected applyScreenTransformation(point: PointF2D): PointF2D;
            /**
                * Converts a rectangle from unit to pixel space.
                * @param rectangle
                * @returns {RectangleF2D}
                */
            protected applyScreenTransformationForRect(rectangle: RectangleF2D): RectangleF2D;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/DrawingParameters' {
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { DrawingParametersEnum } from "opensheetmusicdisplay/Common/Enums/DrawingParametersEnum";
    import { ColoringModes } from "opensheetmusicdisplay/Common/Enums/ColoringModes";
    /** Internal drawing/rendering parameters and broad modes like compact and thumbnail. Overlap with EngravingRules. */
    export class DrawingParameters {
        drawHighlights: boolean;
        drawErrors: boolean;
        drawSelectionStartSymbol: boolean;
        drawSelectionEndSymbol: boolean;
        drawCursors: boolean;
        drawActivitySymbols: boolean;
        drawScrollIndicator: boolean;
        drawAnnotations: boolean;
        drawComments: boolean;
        drawMarkedAreas: boolean;
        drawTitle: boolean;
        drawSubtitle: boolean;
        drawLyricist: boolean;
        drawComposer: boolean;
        drawCopyright: boolean;
        drawCredits: boolean;
        drawPartNames: boolean;
        coloringMode: ColoringModes;
        fingeringPosition: PlacementEnum;
        /** Draw notes set to be invisible (print-object="no" in XML). */
        drawHiddenNotes: boolean;
        constructor(drawingParameters?: DrawingParametersEnum, rules?: EngravingRules);
        /** Sets drawing parameters enum and changes settings flags accordingly. */
        set DrawingParametersEnum(drawingParametersEnum: DrawingParametersEnum);
        get DrawingParametersEnum(): DrawingParametersEnum;
        setForAllOn(): void;
        setForDefault(): void;
        setForThumbnail(): void;
        setForCompactMode(): void;
        setForCompactTightMode(): void;
        setForLeadsheet(): void;
        get DrawCredits(): boolean;
        set DrawCredits(value: boolean);
        get DrawTitle(): boolean;
        /** Enable or disable drawing the Title of the piece. If disabled, will disable drawing Subtitle as well. */
        set DrawTitle(value: boolean);
        get DrawSubtitle(): boolean;
        /** Enable or disable drawing the Subtitle of the piece. If enabled, will enable drawing Title as well. */
        set DrawSubtitle(value: boolean);
        get DrawComposer(): boolean;
        /** Enable or disable drawing a label for the Composer of the piece. */
        set DrawComposer(value: boolean);
        get DrawLyricist(): boolean;
        set DrawLyricist(value: boolean);
        get DrawCopyright(): boolean;
        set DrawCopyright(value: boolean);
        get DrawPartNames(): boolean;
        set DrawPartNames(value: boolean);
        get FingeringPosition(): PlacementEnum;
        set FingeringPosition(value: PlacementEnum);
        get Rules(): EngravingRules;
        set Rules(value: EngravingRules);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules' {
    import { PagePlacementEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { TextAlignmentEnum } from "opensheetmusicdisplay/Common/Enums/TextAlignment";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { AutoBeamOptions, AlignRestOption, FillEmptyMeasuresWithWholeRests, SkyBottomLineBatchCalculatorBackendType } from "opensheetmusicdisplay/OpenSheetMusicDisplay/OSMDOptions";
    import { ColoringModes as ColoringMode } from "opensheetmusicdisplay/Common/Enums/ColoringModes";
    import { Dictionary } from "typescript-collections";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums";
    import { NoteEnum, AccidentalEnum } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { ChordSymbolEnum, CustomChord } from "opensheetmusicdisplay/MusicalScore/VoiceData/ChordSymbolContainer";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    /** Rendering and Engraving options, more fine-grained than [[IOSMDOptions]].
        *  Not all of these options are meant to be modified by users of the library,
        *  full support is only given for [[IOSMDOptions]].
        *  Nevertheless, there are many useful options here,
        *  like Render* to (not) render certain elements (e.g. osmd.rules.RenderRehearsalMarks = false)
        */
    export class EngravingRules {
            /** A unit of distance. 1.0 is the distance between lines of a stave for OSMD, which is 10 pixels in Vexflow. */
            static unit: number;
            SamplingUnit: number;
            StaccatoShorteningFactor: number;
            /** Height (size) of the sheet title. */
            SheetTitleHeight: number;
            SheetSubtitleHeight: number;
            SheetMinimumDistanceBetweenTitleAndSubtitle: number;
            SheetComposerHeight: number;
            SheetAuthorHeight: number;
            SheetCopyrightHeight: number;
            SheetCopyrightMargin: number;
            /** Whether to use the (deprecated) OSMD < 1.8.6 way of parsing and displaying subtitles and composer,
                * which did not read multiple lines from XML credit-words tags.
                * Option will probably be removed soon.
                * @deprecated
                */
            SheetComposerSubtitleUseLegacyParsing: boolean;
            CompactMode: boolean;
            PagePlacementEnum: PagePlacementEnum;
            PageHeight: number;
            PageTopMargin: number;
            PageTopMarginNarrow: number;
            PageBottomMargin: number;
            PageLeftMargin: number;
            PageRightMargin: number;
            TitleTopDistance: number;
            TitleBottomDistance: number;
            SystemLeftMargin: number;
            SystemRightMargin: number;
            SystemLabelsRightMargin: number;
            SystemComposerDistance: number;
            SystemLyricistDistance: number;
            InstrumentLabelTextHeight: number;
            MinimumDistanceBetweenSystems: number;
            MinSkyBottomDistBetweenSystems: number;
            LastSystemMaxScalingFactor: number;
            StaffDistance: number;
            BetweenStaffDistance: number;
            StaffHeight: number;
            TabStaffInterlineHeight: number;
            BetweenStaffLinesDistance: number;
            /** Whether to automatically beam notes that don't already have beams in XML. */
            AutoBeamNotes: boolean;
            /** Options for autoBeaming like whether to beam over rests. See AutoBeamOptions interface. */
            AutoBeamOptions: AutoBeamOptions;
            /** Whether to automatically generate new beams for tabs. Also see TabBeamsRendered for existing XML beams. */
            AutoBeamTabs: boolean;
            BeamWidth: number;
            BeamSpaceWidth: number;
            BeamForwardLength: number;
            FlatBeams: boolean;
            FlatBeamOffset: number;
            FlatBeamOffsetPerBeam: number;
            ClefLeftMargin: number;
            ClefRightMargin: number;
            /** How many unique note positions a percussion score needs to have to not be rendered on one line.
                * To always use 5 lines for percussion, set this to 0. (works unless the XML says <staff-lines>1)
                */
            PercussionOneLineCutoff: number;
            PercussionForceVoicesOneLineCutoff: number;
            PercussionUseXMLDisplayStep: boolean;
            PercussionXMLDisplayStepNoteValueShift: number;
            PercussionOneLineXMLDisplayStepOctaveOffset: number;
            /** Makes the score position notes on the 2 cajon stafflines, and use 2 stafflines even if PercussionOneLineCutoff set.
                * Should only be set for cajon scores, as this will disable the PercussionOneLineCutoff.
                */
            PercussionUseCajon2NoteSystem: boolean;
            BetweenKeySymbolsDistance: number;
            KeyRightMargin: number;
            RhythmRightMargin: number;
            ShowRhythmAgainAfterPartEndOrFinalBarline: boolean;
            NewPartAndSystemAfterFinalBarline: boolean;
            InStaffClefScalingFactor: number;
            DistanceBetweenNaturalAndSymbolWhenCancelling: number;
            NoteHelperLinesOffset: number;
            MeasureLeftMargin: number;
            MeasureRightMargin: number;
            DistanceBetweenLastInstructionAndRepetitionBarline: number;
            ArpeggioDistance: number;
            IdealStemLength: number;
            StemNoteHeadBorderYOffset: number;
            StemWidth: number;
            StemMargin: number;
            StemMinLength: number;
            StemMaxLength: number;
            BeamSlopeMaxAngle: number;
            StemMinAllowedDistanceBetweenNoteHeadAndBeamLine: number;
            SetWantedStemDirectionByXml: boolean;
            GraceNoteScalingFactor: number;
            GraceNoteXOffset: number;
            GraceNoteGroupXMargin: number;
            WedgeOpeningLength: number;
            WedgeMeasureEndOpeningLength: number;
            WedgeMeasureBeginOpeningLength: number;
            WedgePlacementAboveY: number;
            WedgePlacementBelowY: number;
            WedgeHorizontalMargin: number;
            WedgeVerticalMargin: number;
            DistanceOffsetBetweenTwoHorizontallyCrossedWedges: number;
            WedgeMinLength: number;
            WedgeEndDistanceBetweenTimestampsFactor: number;
            SoftAccentWedgePadding: number;
            SoftAccentSizeFactor: number;
            DistanceBetweenAdjacentDynamics: number;
            TempoChangeMeasureValidity: number;
            TempoContinousFactor: number;
            StaccatoScalingFactor: number;
            BetweenDotsDistance: number;
            OrnamentAccidentalScalingFactor: number;
            ChordSymbolTextHeight: number;
            ChordSymbolTextAlignment: TextAlignmentEnum;
            ChordSymbolRelativeXOffset: number;
            /** Additional x-shift for short chord symbols (e.g. C, but not Eb/7), to appear more centered. */
            ChordSymbolExtraXShiftForShortChordSymbols: number;
            /** Threshold width below which to apply ChordSymbolExtraXShiftForShortChordSymbols. */
            ChordSymbolExtraXShiftWidthThreshold: number;
            ChordSymbolXSpacing: number;
            ChordOverlapAllowedIntoNextMeasure: number;
            ChordSymbolYOffset: number;
            ChordSymbolYPadding: number;
            ChordSymbolYAlignment: boolean;
            ChordSymbolYAlignmentScope: string;
            /** Offset to start of measure (barline) when chord symbol is on whole measure rest.
                * An offset of 0 would place the chord symbol directly above the barline, so the default is ~1.2.
                */
            ChordSymbolWholeMeasureRestXOffset: number;
            ChordSymbolWholeMeasureRestXOffsetMeasure1: number;
            ChordSymbolLabelTexts: Dictionary<ChordSymbolEnum, string>;
            ChordAccidentalTexts: Dictionary<AccidentalEnum, string>;
            CustomChords: CustomChord[];
            /** Not always a symbol, can also be text (RepetitionInstruction). Keeping the name for backwards compatibility. */
            RepetitionSymbolsYOffset: number;
            /** Adds a percent of the stave's width (e.g. 0.4 = 40%) to the x position of end instructions like Fine or D.C. al fine */
            RepetitionEndInstructionXShiftAsPercentOfStaveWidth: number;
            RehearsalMarkXOffset: number;
            RehearsalMarkXOffsetDefault: number;
            RehearsalMarkXOffsetSystemStartMeasure: number;
            RehearsalMarkYOffset: number;
            RehearsalMarkYOffsetDefault: number;
            RehearsalMarkFontSize: number;
            MeasureNumberLabelHeight: number;
            MeasureNumberLabelOffset: number;
            MeasureNumberLabelXOffset: number;
            /** Whether tuplets should display ratio (3:2 instead of 3 for triplet). Default false. */
            TupletsRatioed: boolean;
            /** Whether tuplets (except triplets) should be bracketed (e.g. |--5--| instead of 5). Default false.
                * Note that this doesn't affect triplets (|--3--|), which have their own setting TripletsBracketed.
                * If false, only tuplets given as bracketed in XML (bracket="yes") will be bracketed.
                * (If not given in XML, bracketing is implementation-dependent according to standard)
                */
            TupletsBracketed: boolean;
            /** Whether all triplets should be bracketed. Overrides tupletsBracketed for triplets.
                * If false, only triplets given as bracketed in XML (bracket="yes") will be bracketed.
                * (Bracketing all triplets can be cluttering)
                */
            TripletsBracketed: boolean;
            /** Whether to bracket like the XML says when 'bracket="no"' or "yes" is given.
                * Otherwise, OSMD decides bracket usage.
                * Note that sometimes the XML doesn't have any 'bracket' value. */
            TupletsBracketedUseXMLValue: boolean;
            TupletNumberLabelHeight: number;
            TupletNumberYOffset: number;
            TupletNumberLimitConsecutiveRepetitions: boolean;
            TupletNumberMaxConsecutiveRepetitions: number;
            TupletNumberAlwaysDisableAfterFirstMax: boolean;
            /** Whether to use the <tuplet show-number="value"> value or to ignore it. */
            TupletNumberUseShowNoneXMLValue: boolean;
            LabelMarginBorderFactor: number;
            TupletVerticalLineLength: number;
            /** Whether to show tuplet numbers (and brackets) in tabs. Brackets can be disabled via TabTupletsBracketed. */
            TupletNumbersInTabs: boolean;
            /** Whether to show brackets in tab tuplets. To not render tab tuplets entirely, set TupletNumbersInTabs = false. */
            TabTupletsBracketed: boolean;
            TabTupletYOffsetBottom: number;
            /** Additional offset applied to top tuplets (added to TabTupletYOffset).
                * You could apply a negative offset if the piece doesn't have effects like bends,
                * which often take some vertical space.
                */
            TabTupletYOffsetTop: number;
            TabTupletYOffsetEffects: number;
            TabBeamsRendered: boolean;
            TabKeySignatureRendered: boolean;
            /** Whether space should be reserved as if there was a key signature.
                * False basically only works for tab-only scores, as it prevents vertical x-alignment with other staves.
                * False is more compact for tab-only scores.
                */
            TabKeySignatureSpacingAdded: boolean;
            TabTimeSignatureRendered: boolean;
            /** Whether space should be reserved as if there was a key signature.
                * False basically only works for tab-only scores, as it prevents vertical x-alignment with other staves.
                * False is more compact for tab-only scores.
                */
            TabTimeSignatureSpacingAdded: boolean;
            TabFingeringsRendered: boolean;
            RepetitionAllowFirstMeasureBeginningRepeatBarline: boolean;
            RepetitionEndingLabelHeight: number;
            RepetitionEndingLabelXOffset: number;
            RepetitionEndingLabelYOffset: number;
            RepetitionEndingLineYLowerOffset: number;
            RepetitionEndingLineYUpperOffset: number;
            VoltaOffset: number;
            /** Default alignment of lyrics.
                * Left alignments will extend text to the right of the bounding box,
                * which facilitates spacing by extending measure width.
                */
            LyricsAlignmentStandard: TextAlignmentEnum;
            LyricsHeight: number;
            LyricsYOffsetToStaffHeight: number;
            LyricsYMarginToBottomLine: number;
            /** Extra x-shift (to the right) for short lyrics to be better vertically aligned.
                * Also see ChordSymbolExtraXShiftForShortChordSymbols, same principle, same default value.
                */
            LyricsExtraXShiftForShortLyrics: number;
            /** Threshold of the lyric entry's width below which the x-shift is applied. Default 1.4. */
            LyricsExtraXShiftForShortLyricsWidthThreshold: number;
            /** Whether to enable x padding (to the right) for notes with long lyrics, see LyricsXPaddingFactorForLongLyrics for the degree.
                * This helps avoid overlaps and shorten measures, because otherwise the whole measure needs to be stretched to avoid overlaps,
                * see MaximumLyricsElongationFactor */
            LyricsUseXPaddingForLongLyrics: boolean;
            /** How much spacing/padding should be added after notes with long lyrics on short notes
                * (>4 characters on <8th note),
                * so that the measure doesn't need to be elongated too much to avoid lyrics collisions.
                * Default 1 = 10 pixels */
            LyricsXPaddingFactorForLongLyrics: number;
            /** How wide a text needs to be to trigger lyrics padding for short notes.
                * This is visual width, not number of characters, as e.g. 'zzz' is wider than 'iii'.
                * Default 3.3.
                */
            LyricsXPaddingWidthThreshold: number;
            /** Long notes need less padding than short ones, by default we use 0.7 less padding. */
            LyricsXPaddingReductionForLongNotes: number;
            /** Last note in measure needs less padding because of measure bar and bar start/end padding. */
            LyricsXPaddingReductionForLastNoteInMeasure: number;
            LyricsXPaddingForLastNoteInMeasure: boolean;
            VerticalBetweenLyricsDistance: number;
            HorizontalBetweenLyricsDistance: number;
            BetweenSyllableMaximumDistance: number;
            BetweenSyllableMinimumDistance: number;
            LyricOverlapAllowedIntoNextMeasure: number;
            MinimumDistanceBetweenDashes: number;
            MaximumLyricsElongationFactor: number;
            SlurPlacementFromXML: boolean;
            SlurPlacementAtStems: boolean;
            SlurPlacementUseSkyBottomLine: boolean;
            BezierCurveStepSize: number;
            TPower3: number[];
            OneMinusTPower3: number[];
            FactorOne: number[];
            FactorTwo: number[];
            TieGhostObjectWidth: number;
            TieYPositionOffsetFactor: number;
            MinimumNeededXspaceForTieGhostObject: number;
            TieHeightMinimum: number;
            TieHeightMaximum: number;
            TieHeightInterpolationK: number;
            TieHeightInterpolationD: number;
            SlurNoteHeadYOffset: number;
            SlurEndArticulationYOffset: number;
            SlurStartArticulationYOffsetOfArticulation: number;
            SlurStemXOffset: number;
            SlurSlopeMaxAngle: number;
            SlurTangentMinAngle: number;
            SlurTangentMaxAngle: number;
            SlurHeightFactor: number;
            SlurHeightFlattenLongSlursFactorByWidth: number;
            SlurHeightFlattenLongSlursFactorByAngle: number;
            SlurHeightFlattenLongSlursCutoffAngle: number;
            SlurHeightFlattenLongSlursCutoffWidth: number;
            SlursStartingAtSameStaffEntryYOffset: number;
            SlurMaximumYControlPointDistance: number;
            GlissandoNoteOffset: number;
            GlissandoStafflineStartMinimumWidth: number;
            GlissandoStafflineStartYDistanceToNote: number;
            GlissandoStafflineEndOffset: number;
            GlissandoDefaultWidth: number;
            TempoYSpacing: number;
            InstantaneousTempoTextHeight: number;
            ContinuousDynamicTextHeight: number;
            MoodTextHeight: number;
            UnknownTextHeight: number;
            ContinuousTempoTextHeight: number;
            VexFlowDefaultNotationFontScale: number;
            VexFlowDefaultTabFontScale: number;
            TremoloStrokeScale: number;
            TremoloYSpacingScale: number;
            TremoloBuzzRollThickness: number;
            StaffLineWidth: number;
            StaffLineColor: string;
            LedgerLineWidth: number;
            LedgerLineStrokeStyle: string;
            LedgerLineColorDefault: string;
            WedgeLineWidth: number;
            TupletLineWidth: number;
            LyricUnderscoreLineWidth: number;
            SystemThinLineWidth: number;
            SystemBoldLineWidth: number;
            SystemRepetitionEndingLineWidth: number;
            SystemDotWidth: number;
            MultipleRestMeasureDefaultWidth: number;
            MultipleRestMeasureAddKeySignature: boolean;
            /** Use the same measure width for all measures (experimental).
                *  Note that this will use the largest width of all measures,
                *  as Vexflow will mess up the layout with overlays if using less than minimum width.
                *  See formatter.preCalculateMinTotalWidth()
                */
            FixedMeasureWidth: boolean;
            /** Use a fixed width for all measures (experimental).
                *  This is mostly for debugging or for when you already know how big the measures
                *  in the target score are, because using a too low width will cause overlaps in Vexflow.
                */
            FixedMeasureWidthFixedValue: number;
            FixedMeasureWidthUseForPickupMeasures: boolean;
            DistanceBetweenVerticalSystemLines: number;
            DistanceBetweenDotAndLine: number;
            RepeatEndStartPadding: number;
            OctaveShiftLineWidth: number;
            OctaveShiftVerticalLineLength: number;
            OctaveShiftOnWholeMeasureNoteUntilEndOfMeasure: boolean;
            GraceLineWidth: number;
            MinimumStaffLineDistance: number;
            MinSkyBottomDistBetweenStaves: number;
            MinimumCrossedBeamDifferenceMargin: number;
            /** Maximum width of sheet / HTMLElement containing the score. Canvas is limited to 32767 in current browsers, though SVG isn't.
                *  Setting this to > 32767 will break the canvas backend (no problem if you only use SVG).
                */
            SheetMaximumWidth: number;
            VoiceSpacingMultiplierVexflow: number;
            VoiceSpacingAddendVexflow: number;
            PickupMeasureWidthMultiplier: number;
            /** The spacing between a repetition that is followed by an implicit/pickup/incomplete measure.
                *  (E.g. in a 4/4 time signature, a measure that repeats after the 3rd beat, continuing with a pickup measure)
                */
            PickupMeasureRepetitionSpacing: number;
            /** Multiplier for PickupMeasureRepetitionSpacing if there is only one note in the pickup measure. This usually needs a lot more space. */
            PickupMeasureSpacingSingleNoteAddend: number;
            DisplacedNoteMargin: number;
            MinNoteDistance: number;
            SubMeasureXSpacingThreshold: number;
            MeasureDynamicsMaxScalingFactor: number;
            WholeRestXShiftVexflow: number;
            MetronomeMarksDrawn: boolean;
            MetronomeMarkXShift: number;
            MetronomeMarkYShift: number;
            SoftmaxFactorVexFlow: number;
            /** Stagger (x-shift) whole notes that are the same note, but in different voices (show 2 instead of 1). */
            StaggerSameWholeNotes: boolean;
            MaxInstructionsConstValue: number;
            NoteDistances: number[];
            NoteDistancesScalingFactors: number[];
            DurationDistanceDict: {
                    [_: number]: number;
            };
            DurationScalingDistanceDict: {
                    [_: number]: number;
            };
            /** Whether to align rests. 0 = Never, 1 = Always, 2 = Auto.
                * Currently not recommended because rests are now positioned to avoid collisions with notes. */
            AlignRests: AlignRestOption;
            RestCollisionYPadding: number;
            FillEmptyMeasuresWithWholeRest: FillEmptyMeasuresWithWholeRests | number;
            ArpeggiosGoAcrossVoices: boolean;
            RenderArpeggios: boolean;
            RenderSlurs: boolean;
            RenderGlissandi: boolean;
            ColoringMode: ColoringMode;
            ColoringEnabled: boolean;
            ColorStemsLikeNoteheads: boolean;
            ColorFlags: boolean;
            ColorBeams: boolean;
            ColoringSetCurrent: Dictionary<NoteEnum | number, string>;
            /** Default color for all musical elements including key signature etc. Default undefined. */
            DefaultColorMusic: string;
            DefaultColorNotehead: string;
            DefaultColorRest: string;
            DefaultColorStem: string;
            DefaultColorLabel: string;
            DefaultColorLyrics: string;
            DefaultColorChordSymbol: string;
            DefaultColorTitle: string;
            DefaultColorCursor: string;
            DefaultFontFamily: string;
            DefaultFontStyle: FontStyles;
            DefaultVexFlowNoteFont: string;
            MaxMeasureToDrawIndex: number;
            MinMeasureToDrawIndex: number;
            MaxPageToDrawNumber: number;
            MaxSystemToDrawNumber: number;
            /** Whether to render a label for the composer of the piece at the top of the sheet. */
            RenderComposer: boolean;
            RenderTitle: boolean;
            RenderSubtitle: boolean;
            RenderLyricist: boolean;
            RenderCopyright: boolean;
            RenderPartNames: boolean;
            RenderPartAbbreviations: boolean;
            /** Whether two render system labels on page 2+. This doesn't affect the default endless PageFormat. */
            RenderSystemLabelsAfterFirstPage: boolean;
            RenderFingerings: boolean;
            RenderMeasureNumbers: boolean;
            RenderMeasureNumbersOnlyAtSystemStart: boolean;
            UseXMLMeasureNumbers: boolean;
            RenderLyrics: boolean;
            RenderChordSymbols: boolean;
            RenderMultipleRestMeasures: boolean;
            AutoGenerateMultipleRestMeasuresFromRestMeasures: boolean;
            RenderRehearsalMarks: boolean;
            RenderClefsAtBeginningOfStaffline: boolean;
            RenderKeySignatures: boolean;
            RenderTimeSignatures: boolean;
            RenderPedals: boolean;
            RenderWavyLines: boolean;
            DynamicExpressionMaxDistance: number;
            DynamicExpressionSpacer: number;
            IgnoreRepeatedDynamics: boolean;
            ExpressionsUseXMLColor: boolean;
            MpatMode: boolean;
            ArticulationPlacementFromXML: boolean;
            /** Percent distance of breath marks to next note or end of staff, e.g. 0.8 = 80%. */
            BreathMarkDistance: number;
            /** Where to draw fingerings (Above, Below, AboveOrBelow, Left, Right, or Auto).
                * Default AboveOrBelow. Auto experimental. */
            FingeringPosition: PlacementEnum;
            FingeringPositionFromXML: boolean;
            FingeringPositionGrace: PlacementEnum;
            FingeringInsideStafflines: boolean;
            FingeringLabelFontHeight: number;
            FingeringOffsetX: number;
            FingeringOffsetY: number;
            FingeringPaddingY: number;
            FingeringTextSize: number;
            /** Whether to render string numbers in classical scores, i.e. not the string numbers in tabs, but e.g. for violin. */
            RenderStringNumbersClassical: boolean;
            /** This is not for tabs, but for classical scores, especially violin. */
            StringNumberOffsetY: number;
            NewSystemAtXMLNewSystemAttribute: boolean;
            /** Whether to begin a new system when a page break is given in XML ('new-page="yes"'), but newPageFromXML is false.
                *  Default false, because it can lead to nonsensical system breaks after a single measure,
                *  as OSMD does a different layout than the original music program exported from.
                * */
            NewSystemAtXMLNewPageAttribute: boolean;
            NewPageAtXMLNewPageAttribute: boolean;
            UseJustifiedBuilder: boolean;
            PageFormat: PageFormat;
            PageBackgroundColor: string;
            PerformanceMode: boolean;
            RenderSingleHorizontalStaffline: boolean;
            RestoreCursorAfterRerender: boolean;
            StretchLastSystemLine: boolean;
            /** Ignore brackets - e.g. `( )` - that were supposed to be around a note,
                * but were inserted as a words element in the MusicXML, which can't be matched to the note anymore,
                * and would otherwise just be placed somewhere else. See OSMD Issue 1251. */
            IgnoreBracketsWords: boolean;
            PlaceWordsInsideStafflineFromXml: boolean;
            PlaceWordsInsideStafflineYOffset: number;
            SpacingBetweenTextLines: number;
            NoteToGraphicalNoteMap: Dictionary<number, GraphicalNote>;
            NoteToGraphicalNoteMapObjectCount: number;
            /** How many times osmd.render() was already called on the currently loaded score.
                * Resets after osmd.load() (via osmd.reset()).
                * Can be relevant for transposition or generally informative.
                */
            RenderCount: number;
            /** The skyline and bottom-line batch calculation algorithm to use.
                *  Note that this can be overridden if AlwaysSetPreferredSkyBottomLineBackendAutomatically is true (which is the default).
                */
            PreferredSkyBottomLineBatchCalculatorBackend: SkyBottomLineBatchCalculatorBackendType;
            /** Whether to consider using WebGL in Firefox in EngravingRules.setPreferredSkyBottomLineBackendAutomatically() */
            DisableWebGLInFirefox: boolean;
            /** Whether to consider using WebGL in Safari/iOS in EngravingRules.setPreferredSkyBottomLineBackendAutomatically() */
            DisableWebGLInSafariAndIOS: boolean;
            /** The minimum number of measures in the sheet where the skyline and bottom-line batch calculation is enabled.
                *  Batch is faster for medium to large size scores, but slower for very short scores.
                */
            SkyBottomLineBatchMinMeasures: number;
            /** The minimum number of measures in the sheet where WebGL will be used. WebGL is slower for short scores, but much faster for large ones.
                * Note that WebGL is currently never used in Safari and Firefox, because it's always slower there.
                */
            SkyBottomLineWebGLMinMeasures: number;
            /** Whether to always set preferred backend (WebGL or Plain) automatically, depending on browser and number of measures. */
            AlwaysSetPreferredSkyBottomLineBackendAutomatically: boolean;
            PlayAlreadyStartedNotesFromCursorPosition: boolean;
            /** The interval between current timer position and note timestamp beyond which notes are not played.
                * If you experience notes being skipped during playback, try increasing this interval slightly (e.g. 0.02 -> 0.03).
                */
            PlaybackSkipNotesSafetyInterval: number;
            /** Whether to use OSMD's default voice entry interaction listener that plays voice entry on click etc. */
            UseDefaultVoiceInteractionListener: boolean;
            LimitCursorPositionToCurrentMeasure: boolean;
            constructor();
            loadDefaultValues(): void;
            setPreferredSkyBottomLineBackendAutomatically(numberOfGraphicalMeasures?: number): void;
            /** Makes it so that all musical elements (including key/time signature)
                *  are colored with the given color by default,
                *  unless an element has a different color set (e.g. VoiceEntry.StemColor).
                */
            applyDefaultColorMusic(color: string): void;
            addGraphicalNoteToNoteMap(note: Note, graphicalNote: GraphicalNote): void;
            /** Returns the GraphicalNote corresponding to (its) note. Also used by Cursor.GNotesUnderCursor().
                *  We don't want to save a GraphicalNote reference in Note, see Note.NoteToGraphicalNoteObjectId.
                */
            GNote(note: Note): GraphicalNote;
            /** This should be done before a new sheet is loaded, not each re-render (otherwise the map would end empty). */
            clearMusicSheetObjects(): void;
            resetChordAccidentalTexts(chordAccidentalTexts: Dictionary<AccidentalEnum, string>, useChordAccidentalsUnicode: boolean): void;
            setChordSymbolLabelText(key: ChordSymbolEnum, value: string): void;
            resetChordSymbolLabelTexts(chordtexts: Dictionary<ChordSymbolEnum, string>): Dictionary<ChordSymbolEnum, string>;
            addChordName(altName: string, chordKindText: string, adds: string[], alts: string[], subs: string[]): void;
            renameChord(altName: string, newAltName: string): void;
            resetChordNames(): void;
    }
    export class PageFormat {
            constructor(width: number, height: number, idString?: string);
            width: number;
            height: number;
            idString: string;
            get aspectRatio(): number;
            /** Undefined page format: use default page format. */
            get IsUndefined(): boolean;
            static get UndefinedPageFormat(): PageFormat;
            Equals(otherPageFormat: PageFormat): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage' {
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { GraphicalMusicSheet } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet";
    export class GraphicalMusicPage extends GraphicalObject {
        constructor(parent: GraphicalMusicSheet);
        get MusicSystems(): MusicSystem[];
        set MusicSystems(value: MusicSystem[]);
        get Labels(): GraphicalLabel[];
        set Labels(value: GraphicalLabel[]);
        get Parent(): GraphicalMusicSheet;
        set Parent(value: GraphicalMusicSheet);
        get PageNumber(): number;
        set PageNumber(value: number);
        /**
          * This method calculates the absolute Position of each GraphicalMusicPage according to a given placement
          * @param pageIndex
          * @param rules
          * @returns {PointF2D}
          */
        setMusicPageAbsolutePosition(pageIndex: number, rules: EngravingRules): PointF2D;
    }
    export enum PagePlacementEnum {
        Down = 0,
        Right = 1,
        RightDown = 2
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/ITransposeCalculator' {
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    export interface ITransposeCalculator {
        transposePitch(pitch: Pitch, currentKeyInstruction: KeyInstruction, halftones: number): Pitch;
        transposeKey(keyInstruction: KeyInstruction, transpose: number): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Voice' {
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    /**
        * A [[Voice]] contains all the [[VoiceEntry]]s in a voice in a [[StaffLine]].
        */
    export class Voice {
            constructor(parent: Instrument, voiceId: number);
            get VoiceEntries(): VoiceEntry[];
            get Parent(): Instrument;
            get Visible(): boolean;
            set Visible(value: boolean);
            get Audible(): boolean;
            set Audible(value: boolean);
            get Following(): boolean;
            set Following(value: boolean);
            get Solo(): boolean;
            set Solo(value: boolean);
            get VoiceId(): number;
            get Volume(): number;
            set Volume(value: number);
            /**
                * This is needed for using the Voice as a key in a dictionary,
                * where a unique identifier is expected.
                */
            toString(): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Staff' {
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { Tie } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tie";
    export class Staff {
        constructor(parentInstrument: Instrument, instrumentStaffId: number);
        idInMusicSheet: number;
        audible: boolean;
        following: boolean;
        isTab: boolean;
        hasLyrics: boolean;
        openTieDict: {
            [_: number]: Tie;
        };
        get ParentInstrument(): Instrument;
        set ParentInstrument(value: Instrument);
        get Voices(): Voice[];
        get Solo(): boolean;
        set Solo(value: boolean);
        get Id(): number;
        get Volume(): number;
        set Volume(value: number);
        get StafflineCount(): number;
        set StafflineCount(value: number);
        toString(): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction' {
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { AbstractNotationInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/AbstractNotationInstruction";
    /**
      * A [[ClefInstruction]] is the clef placed at the beginning of the stave, which indicates the pitch of the notes.
      */
    export class ClefInstruction extends AbstractNotationInstruction {
        constructor(clefType?: ClefEnum, octaveOffset?: number, line?: number);
        static getDefaultClefFromMidiInstrument(instrument: MidiInstrument): ClefInstruction;
        static getAllPossibleClefs(): ClefInstruction[];
        static isSupportedClef(clef: ClefEnum): boolean;
        get ClefType(): ClefEnum;
        set ClefType(value: ClefEnum);
        get Line(): number;
        set Line(value: number);
        get OctaveOffset(): number;
        set OctaveOffset(value: number);
        get ClefPitch(): Pitch;
        set ClefPitch(value: Pitch);
        get ReferenceCyPosition(): number;
        set ReferenceCyPosition(value: number);
        Equals(other: ClefInstruction): boolean;
        NotEqual(clef2: ClefInstruction): boolean;
        ToString(): string;
    }
    export enum ClefEnum {
        G = 0,
        F = 1,
        C = 2,
        percussion = 3,
        TAB = 4
    }
    export enum MidiInstrument {
        None = -1,
        Acoustic_Grand_Piano = 0,
        Bright_Acoustic_Piano = 1,
        Electric_Grand_Piano = 2,
        Honky_tonk_Piano = 3,
        Electric_Piano_1 = 4,
        Electric_Piano_2 = 5,
        Harpsichord = 6,
        Clavinet = 7,
        Celesta = 8,
        Glockenspiel = 9,
        Music_Box = 10,
        Vibraphone = 11,
        Marimba = 12,
        Xylophone = 13,
        Tubular_Bells = 14,
        Dulcimer = 15,
        Drawbar_Organ = 16,
        Percussive_Organ = 17,
        Rock_Organ = 18,
        Church_Organ = 19,
        Reed_Organ = 20,
        Accordion = 21,
        Harmonica = 22,
        Tango_Accordion = 23,
        Acoustic_Guitar_nylon = 24,
        Acoustic_Guitar_steel = 25,
        Electric_Guitar_jazz = 26,
        Electric_Guitar_clean = 27,
        Electric_Guitar_muted = 28,
        Overdriven_Guitar = 29,
        Distortion_Guitar = 30,
        Guitar_harmonics = 31,
        Acoustic_Bass = 32,
        Electric_Bass_finger = 33,
        Electric_Bass_pick = 34,
        Fretless_Bass = 35,
        Slap_Bass_1 = 36,
        Slap_Bass_2 = 37,
        Synth_Bass_1 = 38,
        Synth_Bass_2 = 39,
        Violin = 40,
        Viola = 41,
        Cello = 42,
        Contrabass = 43,
        Tremolo_Strings = 44,
        Pizzicato_Strings = 45,
        Orchestral_Harp = 46,
        Timpani = 47,
        String_Ensemble_1 = 48,
        String_Ensemble_2 = 49,
        Synth_Strings_1 = 50,
        Synth_Strings_2 = 51,
        Choir_Aahs = 52,
        Voice_Oohs = 53,
        Synth_Voice = 54,
        Orchestra_Hit = 55,
        Trumpet = 56,
        Trombone = 57,
        Tuba = 58,
        Muted_Trumpet = 59,
        French_Horn = 60,
        Brass_Section = 61,
        Synth_Brass_1 = 62,
        Synth_Brass_2 = 63,
        Soprano_Sax = 64,
        Alto_Sax = 65,
        Tenor_Sax = 66,
        Baritone_Sax = 67,
        Oboe = 68,
        English_Horn = 69,
        Bassoon = 70,
        Clarinet = 71,
        Piccolo = 72,
        Flute = 73,
        Recorder = 74,
        Pan_Flute = 75,
        Blown_Bottle = 76,
        Shakuhachi = 77,
        Whistle = 78,
        Ocarina = 79,
        Lead_1_square = 80,
        Lead_2_sawtooth = 81,
        Lead_3_calliope = 82,
        Lead_4_chiff = 83,
        Lead_5_charang = 84,
        Lead_6_voice = 85,
        Lead_7_fifths = 86,
        Lead_8_bass_lead = 87,
        Pad_1_new_age = 88,
        Pad_2_warm = 89,
        Pad_3_polysynth = 90,
        Pad_4_choir = 91,
        Pad_5_bowed = 92,
        Pad_6_metallic = 93,
        Pad_7_halo = 94,
        Pad_8_sweep = 95,
        FX_1_rain = 96,
        FX_2_soundtrack = 97,
        FX_3_crystal = 98,
        FX_4_atmosphere = 99,
        FX_5_brightness = 100,
        FX_6_goblins = 101,
        FX_7_echoes = 102,
        FX_8_scifi = 103,
        Sitar = 104,
        Banjo = 105,
        Shamisen = 106,
        Koto = 107,
        Kalimba = 108,
        Bag_pipe = 109,
        Fiddle = 110,
        Shanai = 111,
        Tinkle_Bell = 112,
        Agogo = 113,
        Steel_Drums = 114,
        Woodblock = 115,
        Taiko_Drum = 116,
        Melodic_Tom = 117,
        Synth_Drum = 118,
        Reverse_Cymbal = 119,
        Guitar_Fret_Noise = 120,
        Breath_Noise = 121,
        Seashore = 122,
        Bird_Tweet = 123,
        Telephone_Ring = 124,
        Helicopter = 125,
        Applause = 126,
        Gunshot = 127,
        Percussion = 128
    }
}

declare module 'opensheetmusicdisplay/Common/Enums/TextAlignment' {
    /**
      * The Alignment of a TextLabel.
      * Specifically the label's position coordinates within the Bounding Box.
      * For LeftBottom, the label's position is at the left bottom corner of its Bounding Box.
      * (used for example with title, composer, author, etc.)
      * (see Show Bounding Box For -> Labels in the local demo)
      */
    export enum TextAlignmentEnum {
        LeftTop = 0,
        LeftCenter = 1,
        LeftBottom = 2,
        CenterTop = 3,
        CenterCenter = 4,
        CenterBottom = 5,
        RightTop = 6,
        RightCenter = 7,
        RightBottom = 8
    }
    export class TextAlignment {
        static IsLeft(textAlignment: TextAlignmentEnum): boolean;
        static IsCenterAligned(textAlignment: TextAlignmentEnum): boolean;
        static IsRight(textAlignment: TextAlignmentEnum): boolean;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/OSMDColor' {
    /**
      * Represents a color in RGBA
      */
    export class OSMDColor {
        alpha: number;
        red: number;
        green: number;
        blue: number;
        constructor(red: number, green: number, blue: number);
        static get Black(): OSMDColor;
        static get DeepSkyBlue(): OSMDColor;
        static get Green(): OSMDColor;
        static get Magenta(): OSMDColor;
        static get Orange(): OSMDColor;
        static get Red(): OSMDColor;
        static get Disabled(): OSMDColor;
        static get DarkBlue(): OSMDColor;
        static get Debug1(): OSMDColor;
        static get Debug2(): OSMDColor;
        static get Debug3(): OSMDColor;
        toHexString(): string;
        toString(): string;
    }
}

declare module 'opensheetmusicdisplay/Common/Enums/Fonts' {
    /**
      * The fonts available for writing on the sheet music
      */
    export enum Fonts {
        TimesNewRoman = 0,
        Kokila = 1,
        Gonville = 2
    }
    export const FontString: Object;
    export const FontStringNames: Object;
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { VerticalSourceStaffEntryContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/VerticalSourceStaffEntryContainer";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { RepetitionInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    import { MultiTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiTempoExpression";
    import { RehearsalExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/RehearsalExpression";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { SystemLinesEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { RhythmInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions";
    /**
        * The Source Measure represents the source data of a unique measure, including all instruments with their staves.
        * There exists one source measure per XML measure or per paper sheet measure (e.g. the source measures are not doubled in repetitions)
        */
    export class SourceMeasure {
            /**
                * The data entries and data lists will be filled with null values according to the total number of staves,
                * so that existing objects can be referred to by staff index.
                * @param completeNumberOfStaves
                * @param rules
                */
            constructor(completeNumberOfStaves: number, rules: EngravingRules);
            /**
                * The unique measure list index starting with 0.
                */
            measureListIndex: number;
            /**
                * The style of the ending bar line.
                */
            endingBarStyleXml: string;
            endingBarStyleEnum: SystemLinesEnum;
            /** Whether the MusicXML says to print a new system (line break). See OSMDOptions.newSystemFromXML */
            printNewSystemXml: boolean;
            /** Whether the MusicXML says to print a new page (page break). See OSMDOptions.newPageFromXML */
            printNewPageXml: boolean;
            IsSystemStartMeasure: boolean;
            MeasureNumberXML: number;
            MeasureNumberPrinted: number;
            RhythmPrinted: RhythmInstruction;
            multipleRestMeasures: number;
            hasLyrics: boolean;
            hasMoodExpressions: boolean;
            /** Whether the SourceMeasure only has rests, no other entries.
                *  Not the same as GraphicalMeasure.hasOnlyRests, because one SourceMeasure can have many GraphicalMeasures (staffs).
                */
            allRests: boolean;
            isReducedToMultiRest: boolean;
            /** If this measure is a MultipleRestMeasure, this is the number of the measure in that sequence of measures. */
            multipleRestMeasureNumber: number;
            rehearsalExpression: RehearsalExpression;
            hasEndClef: boolean;
            WasRendered: boolean;
            get MeasureNumber(): number;
            set MeasureNumber(value: number);
            getPrintedMeasureNumber(): number;
            get AbsoluteTimestamp(): Fraction;
            set AbsoluteTimestamp(value: Fraction);
            get CompleteNumberOfStaves(): number;
            get Duration(): Fraction;
            set Duration(value: Fraction);
            get ActiveTimeSignature(): Fraction;
            set ActiveTimeSignature(value: Fraction);
            get ImplicitMeasure(): boolean;
            set ImplicitMeasure(value: boolean);
            get HasEndLine(): boolean;
            set HasEndLine(value: boolean);
            get StaffLinkedExpressions(): MultiExpression[][];
            get TempoExpressions(): MultiTempoExpression[];
            get VerticalSourceStaffEntryContainers(): VerticalSourceStaffEntryContainer[];
            get FirstInstructionsStaffEntries(): SourceStaffEntry[];
            get LastInstructionsStaffEntries(): SourceStaffEntry[];
            get FirstRepetitionInstructions(): RepetitionInstruction[];
            get LastRepetitionInstructions(): RepetitionInstruction[];
            getErrorInMeasure(staffIndex: number): boolean;
            setErrorInGraphicalMeasure(staffIndex: number, hasError: boolean): void;
            getNextMeasure(measures: SourceMeasure[]): SourceMeasure;
            getPreviousMeasure(measures: SourceMeasure[]): SourceMeasure;
            get Rules(): EngravingRules;
            get VerticalMeasureList(): GraphicalMeasure[];
            set VerticalMeasureList(value: GraphicalMeasure[]);
            get TempoInBPM(): number;
            set TempoInBPM(value: number);
            /**
                * Check at the given timestamp if a VerticalContainer exists, if not creates a new, timestamp-ordered one,
                * and at the given index, if a [[SourceStaffEntry]] exists, and if not, creates a new one.
                * @param inMeasureTimestamp
                * @param inSourceMeasureStaffIndex
                * @param staff
                * @returns {{createdNewContainer: boolean, staffEntry: SourceStaffEntry}}
                */
            findOrCreateStaffEntry(inMeasureTimestamp: Fraction, inSourceMeasureStaffIndex: number, staff: Staff): {
                    createdNewContainer: boolean;
                    staffEntry: SourceStaffEntry;
            };
            /**
                * Check if a VerticalContainer, a staffEntry and a voiceEntry exist at the given timestamp.
                * If not, create the necessary entries.
                * @param sse
                * @param voice
                * @returns {{createdVoiceEntry: boolean, voiceEntry: VoiceEntry}}
                */
            findOrCreateVoiceEntry(sse: SourceStaffEntry, voice: Voice): {
                    createdVoiceEntry: boolean;
                    voiceEntry: VoiceEntry;
            };
            /**
                * Search for a non-null [[SourceStaffEntry]] at the given verticalIndex,
                * starting from the given horizontalIndex and moving backwards. If none is found, then return undefined.
                * @param verticalIndex
                * @param horizontalIndex
                * @returns {any}
                */
            getPreviousSourceStaffEntryFromIndex(verticalIndex: number, horizontalIndex: number): SourceStaffEntry;
            /**
                * Return the index of the existing VerticalContainer at the given timestamp.
                * @param musicTimestamp
                * @returns {number}
                */
            getVerticalContainerIndexByTimestamp(musicTimestamp: Fraction): number;
            /**
                * Return the existing VerticalContainer at the given timestamp.
                * @param musicTimestamp
                * @returns {any}
                */
            getVerticalContainerByTimestamp(musicTimestamp: Fraction): VerticalSourceStaffEntryContainer;
            /**
                * Check the [[SourceMeasure]] for a possible VerticalContainer with all of its [[StaffEntry]]s undefined,
                * and if found, remove the VerticalContainer from the [[SourceMeasure]].
                * @param index
                */
            checkForEmptyVerticalContainer(index: number): void;
            /**
                * This method is used for handling a measure with the following error (in the procedure of finding out the Instrument's Duration):
                * If the LastStaffEntry is missing (implied restNote or error), then go back the StaffEntries until you find a TiedNote (tie Start),
                * which gives the correct MeasureDuration.
                * @param musicSheet
                * @param maxInstDuration
                * @returns {Fraction}
                */
            reverseCheck(musicSheet: MusicSheet, maxInstDuration: Fraction): Fraction;
            /**
                * Calculate all the [[Instrument]]'s NotesDurations for this Measures.
                * @param musicSheet
                * @param instrumentMaxTieNoteFractions
                * @returns {Fraction[]}
                */
            calculateInstrumentsDuration(musicSheet: MusicSheet, instrumentMaxTieNoteFractions: Fraction[]): Fraction[];
            getEntriesPerStaff(staffIndex: number): SourceStaffEntry[];
            /**
                *
                * @returns {boolean} true iff some measure begin instructions have been found for at least one staff
                */
            hasBeginInstructions(): boolean;
            beginsWithLineRepetition(): boolean;
            /**
                * Check if this measure is a Repetition Ending.
                * @returns {boolean}
                */
            endsWithLineRepetition(): boolean;
            /**
                * Check if a Repetition starts at the next Measure.
                * @returns {boolean}
                */
            beginsWithWordRepetition(): boolean;
            /**
                * Check if this Measure ends a Repetition.
                * @returns {boolean}
                */
            endsWithWordRepetition(): boolean;
            beginsRepetitionEnding(): boolean;
            endsRepetitionEnding(): boolean;
            getKeyInstruction(staffIndex: number): KeyInstruction;
            canBeReducedToMultiRest(): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicSource/Repetition' {
    import { SourceMusicPart } from "opensheetmusicdisplay/MusicalScore/MusicSource/SourceMusicPart";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { RepetitionInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction";
    import { PartListEntry } from "opensheetmusicdisplay/MusicalScore/MusicSource/PartListEntry";
    export class Repetition extends PartListEntry {
        constructor(musicSheet: MusicSheet, virtualOverallRepetition?: boolean);
        startMarker: RepetitionInstruction;
        endMarker: RepetitionInstruction;
        forwardJumpInstruction: RepetitionInstruction;
        get BackwardJumpInstructions(): RepetitionInstruction[];
        get EndingIndexDict(): {
            [_: number]: RepetitionEndingPart;
        };
        get EndingParts(): RepetitionEndingPart[];
        get Visibles(): boolean[];
        set Visibles(value: boolean[]);
        get DefaultNumberOfRepetitions(): number;
        get UserNumberOfRepetitions(): number;
        set UserNumberOfRepetitions(value: number);
        getForwardJumpTargetForIteration(iteration: number): number;
        getBackwardJumpTarget(): number;
        setEndingsStartIndex(endingNumbers: number[], startIndex: number): void;
        setEndingStartIndex(endingNumber: number, startIndex: number): void;
        setEndingEndIndex(endingNumber: number, endIndex: number): void;
        get NumberOfEndings(): number;
        get FromWords(): boolean;
        set FromWords(value: boolean);
        get AbsoluteTimestamp(): Fraction;
        get StartIndex(): number;
        get EndIndex(): number;
        get FirstSourceMeasureNumber(): number;
        get LastSourceMeasureNumber(): number;
        coversIdenticalMeasures(other: Repetition): boolean;
        removeFromRepetitionInstructions(): void;
    }
    export class RepetitionEndingPart {
        constructor(endingPart: SourceMusicPart);
        part: SourceMusicPart;
        endingIndices: number[];
        ToString(): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/HelperObjects/DynamicsContainer' {
    import { ContinuousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/ContinuousDynamicExpression";
    import { InstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousDynamicExpression";
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    export class DynamicsContainer {
        constructor(dynamicExpression: ContinuousDynamicExpression | InstantaneousDynamicExpression, staffNumber: number);
        static Compare(a: DynamicsContainer, b: DynamicsContainer): number;
        continuousDynamicExpression: ContinuousDynamicExpression;
        instantaneousDynamicExpression: InstantaneousDynamicExpression;
        staffNumber: number;
        parMultiExpression(): MultiExpression;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/MusicSheetErrors' {
    export class MusicSheetErrors {
        measureErrors: {
            [n: number]: string[];
        };
        finalizeMeasure(measureNumber: number): void;
        pushMeasureError(errorMsg: string): void;
        push(errorMsg: string): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiTempoExpression' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { InstantaneousTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousTempoExpression";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { AbstractTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractTempoExpression";
    import { ContinuousTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/ContinuousTempoExpression";
    export class MultiTempoExpression {
        constructor(sourceMeasure: SourceMeasure, timestamp: Fraction);
        get Timestamp(): Fraction;
        get AbsoluteTimestamp(): Fraction;
        get SourceMeasureParent(): SourceMeasure;
        set SourceMeasureParent(value: SourceMeasure);
        get InstantaneousTempo(): InstantaneousTempoExpression;
        get ContinuousTempo(): ContinuousTempoExpression;
        get EntriesList(): TempoExpressionEntry[];
        get CombinedExpressionsText(): string;
        set CombinedExpressionsText(value: string);
        getPlacementOfFirstEntry(): PlacementEnum;
        getFontstyleOfFirstEntry(): FontStyles;
        addExpression(abstractTempoExpression: AbstractTempoExpression, prefix: string): void;
        CompareTo(other: MultiTempoExpression): number;
    }
    export class TempoExpressionEntry {
        prefix: string;
        protected expression: AbstractTempoExpression;
        label: string;
        get Expression(): AbstractTempoExpression;
        set Expression(value: AbstractTempoExpression);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Playback/PlaybackEntry' {
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects";
    import { PlaybackNote } from "opensheetmusicdisplay/MusicalScore/Playback/PlaybackNote";
    export class PlaybackEntry {
        constructor(parentVoiceEntry: VoiceEntry);
        get ParentVoiceEntry(): VoiceEntry;
        /** The relative timestamp shift compared to the parent voice entry (graphical) timestamp */
        TimestampShift: Fraction;
        get Notes(): PlaybackNote[];
        get Length(): Fraction;
        set Length(value: Fraction);
        get HasNotes(): boolean;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/PlaybackSettings' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    export class PlaybackSettings {
        rhythm: Fraction;
        /** The denominator of the fraction of the rhythm is 1 beat long
          * --> By knowing the rhythm and the beatsPerMinute the length of notes can be calculated.
          */
        constructor(rhythm?: Fraction, beatsPerMinute?: number);
        static createFrom(from: PlaybackSettings): PlaybackSettings;
        get BeatsPerMinute(): number;
        set BeatsPerMinute(value: number);
        get Rhythm(): Fraction;
        set Rhythm(value: Fraction);
        get BeatRealValue(): number;
        get BeatLengthInMilliseconds(): number;
        getDurationInMilliseconds(duration: number | Fraction): number;
        getDurationAsNoteDuration(milliseconds: number, fractionPrecision?: number): Fraction;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Arpeggio' {
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    export class Arpeggio {
        constructor(parentVoiceEntry: VoiceEntry, type?: ArpeggioType);
        parentVoiceEntry: VoiceEntry;
        notes: Note[];
        type: ArpeggioType;
        addNote(note: Note): void;
    }
    /** Corresponds to VF.Stroke.Type for now. But we don't want VexFlow as a dependency here. */
    export enum ArpeggioType {
        BRUSH_DOWN = 1,
        BRUSH_UP = 2,
        ROLL_DOWN = 3,
        ROLL_UP = 4,
        RASQUEDO_DOWN = 5,
        RASQUEDO_UP = 6,
        ARPEGGIO_DIRECTIONLESS = 7
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Beam' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    /**
        * A [[Beam]] - the bar grouping multiple consecutive [[Note]]s.
        */
    export class Beam {
            BeamNumber: number;
            BeamNumberOffsetToXML: number;
            AutoGenerated: boolean;
            constructor(beamNumber?: number, beamNumberOffsetToXML?: number);
            get Notes(): Note[];
            set Notes(value: Note[]);
            get ExtendedNoteList(): Note[];
            set ExtendedNoteList(value: Note[]);
            /**
                * Perform all the appropriate actions for adding a singleNote to the Beam.
                * @param note
                */
            addNoteToBeam(note: Note): void;
    }
    export enum BeamEnum {
            BeamNone = -1,
            BeamBegin = 0,
            BeamContinue = 1,
            BeamEnd = 2,
            BeamForward = 3,
            BeamBackward = 4
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/ChordSymbolContainer' {
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { AccidentalEnum } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class ChordSymbolContainer {
        constructor(rootPitch: Pitch, chordKind: ChordSymbolEnum, bassPitch: Pitch, chordDegrees: Degree[], rules: EngravingRules);
        get RootPitch(): Pitch;
        get ChordKind(): ChordSymbolEnum;
        get BassPitch(): Pitch;
        get ChordDegrees(): Degree[];
        static calculateChordText(chordSymbol: ChordSymbolContainer, transposeHalftones: number, keyInstruction: KeyInstruction): string;
    }
    export class Degree {
        constructor(value: number, alteration: AccidentalEnum, text: ChordDegreeText);
        value: number;
        alteration: AccidentalEnum;
        text: ChordDegreeText;
    }
    export interface DegreesInfo {
        adds?: string[];
        alts?: string[];
        subs?: string[];
    }
    export class CustomChord {
        alternateName: string;
        chordKind: ChordSymbolEnum;
        degrees: DegreesInfo;
        constructor(alternateName: string, chordKind: ChordSymbolEnum, degrees: DegreesInfo);
        static createCustomChord(altName: string, chordKind: ChordSymbolEnum, degrees: DegreesInfo): CustomChord;
        static renameCustomChord(altName: string, newAltName: string, customChords: CustomChord[]): void;
    }
    export enum ChordDegreeText {
        add = 0,
        alter = 1,
        subtract = 2
    }
    export enum ChordSymbolEnum {
        major = 0,
        minor = 1,
        augmented = 2,
        diminished = 3,
        dominant = 4,
        majorseventh = 5,
        minorseventh = 6,
        diminishedseventh = 7,
        augmentedseventh = 8,
        halfdiminished = 9,
        majorminor = 10,
        majorsixth = 11,
        minorsixth = 12,
        dominantninth = 13,
        majorninth = 14,
        minorninth = 15,
        dominant11th = 16,
        major11th = 17,
        minor11th = 18,
        dominant13th = 19,
        major13th = 20,
        minor13th = 21,
        suspendedsecond = 22,
        suspendedfourth = 23,
        Neapolitan = 24,
        Italian = 25,
        French = 26,
        German = 27,
        pedal = 28,
        power = 29,
        Tristan = 30,
        none = 31
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Glissando' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { ColDirEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    export class Glissando {
        constructor(note: Note);
        StartNote: Note;
        EndNote: Note;
        XMLNumber: number;
        Direction: ColDirEnum;
        get Notes(): Note[];
        get Duration(): Fraction;
        get Pitch(): Pitch;
        AddNote(note: Note): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/LinkedVoice' {
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    export class LinkedVoice extends Voice {
        constructor(parent: Instrument, voiceId: number, master: Voice);
        get Master(): Voice;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Notehead' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    /**
        * A note head with shape and fill information belonging to a [[Note]].
        */
    export class Notehead {
            /**
                * @param sourceNote
                * @param shapeTypeXml The shape type given from XML.
                *                     See https://usermanuals.musicxml.com/MusicXML/Content/ST-MusicXML-notehead-value.htm
                * @param filledXml The XML flag to fill the note shape. Can be undefined if not included in XML.
                *                  If undefined, the filled parameter will be calculated by note duration (d < half note => filled)
                */
            constructor(sourceNote: Note, shapeTypeXml: string, filledXml?: boolean);
            /** Sets the note head's shape from XML parameters.
                * @param shapeTypeXml The XML shape.
                * @param filledXmlAttribute the filled parameter as given in XML.
                *                           Can be undefined if not given in XML or if it should be calculated from note duration.
                *                           If undefined, this.sourceNote should not be undefined.
                */
            setShapeFromXml(shapeTypeXml: string, filledXmlAttribute?: boolean): void;
            get SourceNote(): Note;
            get Shape(): NoteHeadShape;
            get Filled(): boolean;
            /** Converts xml attribute to NoteHeadShape.
                * Necessary because "circle-x" is not a valid enum member name.
                */
            static ShapeTypeXmlToShape(shapeTypeXml: string): NoteHeadShape;
    }
    /** shape of a note head, needs to be supported by MusicXML and Vexflow. */
    export enum NoteHeadShape {
            CIRCLEX = 0,
            DIAMOND = 1,
            NORMAL = 2,
            RECTANGLE = 3,
            SLASH = 4,
            SQUARE = 5,
            TRIANGLE = 6,
            TRIANGLE_INVERTED = 7,
            X = 8
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/NoteType' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    export enum NoteType {
        UNDEFINED = 0,
        _1024th = 1,
        _512th = 2,
        _256th = 3,
        _128th = 4,
        _64th = 5,
        _32nd = 6,
        _16th = 7,
        EIGTH = 8,
        QUARTER = 9,
        HALF = 10,
        WHOLE = 11,
        BREVE = 12,
        LONG = 13,
        MAXIMA = 14
    }
    export class NoteTypeHandler {
        static NoteTypeXmlValues: string[];
        static NoteTypeToString(noteType: NoteType): string;
        static StringToNoteType(noteType: string): NoteType;
        /**
          *
          * @param type
          * @returns {Fraction} - a Note's Duration from a given type (type must be valid).
          */
        static getNoteDurationFromType(type: string): Fraction;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/OrnamentContainer' {
    import { AccidentalEnum } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    export class OrnamentContainer {
        constructor(ornament: OrnamentEnum);
        placement: PlacementEnum;
        get GetOrnament(): OrnamentEnum;
        get AccidentalAbove(): AccidentalEnum;
        set AccidentalAbove(value: AccidentalEnum);
        get AccidentalBelow(): AccidentalEnum;
        set AccidentalBelow(value: AccidentalEnum);
    }
    export enum OrnamentEnum {
        Trill = 0,
        Turn = 1,
        InvertedTurn = 2,
        DelayedTurn = 3,
        DelayedInvertedTurn = 4,
        Mordent = 5,
        InvertedMordent = 6
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { VerticalSourceStaffEntryContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/VerticalSourceStaffEntryContainer";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { AbstractNotationInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/AbstractNotationInstruction";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { StaffEntryLink } from "opensheetmusicdisplay/MusicalScore/VoiceData/StaffEntryLink";
    import { ChordSymbolContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/ChordSymbolContainer";
    /**
        * A [[SourceStaffEntry]] is a container spanning all the [[VoiceEntry]]s at one timestamp for one [[StaffLine]].
        */
    export class SourceStaffEntry {
            constructor(verticalContainerParent: VerticalSourceStaffEntryContainer, parentStaff: Staff);
            get ParentStaff(): Staff;
            get VerticalContainerParent(): VerticalSourceStaffEntryContainer;
            get Timestamp(): Fraction;
            get AbsoluteTimestamp(): Fraction;
            get VoiceEntries(): VoiceEntry[];
            set VoiceEntries(value: VoiceEntry[]);
            get Link(): StaffEntryLink;
            set Link(value: StaffEntryLink);
            get Instructions(): AbstractNotationInstruction[];
            set Instructions(value: AbstractNotationInstruction[]);
            get ChordContainers(): ChordSymbolContainer[];
            set ChordContainers(value: ChordSymbolContainer[]);
            removeAllInstructionsOfTypeClefInstruction(): number;
            /**
                * Similar to RemoveAllInstructionsOfType but faster,
                * because it stops searching when the first instruction of the given type is found.
                * @returns {boolean}
                */
            removeFirstInstructionOfTypeClefInstruction(): boolean;
            removeAllInstructionsOfTypeKeyInstruction(): number;
            /**
                * Similar to RemoveAllInstructionsOfType but faster,
                * because it stops searching when the first instruction of the given type is found.
                * @returns {boolean}
                */
            removeFirstInstructionOfTypeKeyInstruction(): boolean;
            removeAllInstructionsOfTypeRhythmInstruction(): number;
            removeFirstInstructionOfTypeRhythmInstruction(): boolean;
            /**
                * Calculate the [[SourceStaffEntry]]'s minimum NoteLength.
                * @returns {Fraction}
                */
            calculateMinNoteLength(): Fraction;
            calculateMaxNoteLength(untilEndOfTie?: boolean): Fraction;
            hasNotes(): boolean;
            hasTie(): boolean;
            findLinkedNotes(linkedNotes: Note[]): void;
            get hasOnlyRests(): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/StaffEntryLink' {
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    /**
      * Used for linked voices.
      */
    export class StaffEntryLink {
        constructor(voiceEntry: VoiceEntry);
        get GetVoiceEntry(): VoiceEntry;
        get LinkStaffEntries(): SourceStaffEntry[];
        set LinkStaffEntries(value: SourceStaffEntry[]);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Tie' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { TieTypes } from "opensheetmusicdisplay/Common/Enums";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    /**
        * A [[Tie]] connects two notes of the same pitch and name, indicating that they have to be played as a single note.
        */
    export class Tie {
            constructor(note: Note, type: TieTypes);
            TieNumber: number;
            TieDirection: PlacementEnum;
            /** Can contain tie directions at certain note indices.
                *  For example, if it contains {2: PlacementEnum.Below}, then
                *  the tie should go downwards from Tie.Notes[2] onwards,
                *  even if tie.TieDirection is PlacementEnum.Above (tie starts going up on Notes[0]).
                */
            NoteIndexToTieDirection: NoteIndexToPlacementEnum;
            getTieDirection(startNote?: Note): PlacementEnum;
            get Notes(): Note[];
            get Type(): TieTypes;
            get StartNote(): Note;
            get Duration(): Fraction;
            get Pitch(): Pitch;
            AddNote(note: Note): void;
    }
    export interface NoteIndexToPlacementEnum {
            [key: number]: PlacementEnum;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Tuplet' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    /**
        * Tuplets create irregular rhythms; e.g. triplets, quadruplets, quintuplets, etc.
        */
    export class Tuplet {
            constructor(tupletLabelNumber: number, bracket?: boolean);
            PlacementFromXml: boolean;
            tupletLabelNumberPlacement: PlacementEnum;
            RenderTupletNumber: boolean;
            /** Boolean if 'bracket="no"' or "yes" was explicitly requested in the XML, otherwise undefined. */
            BracketedXmlValue: boolean;
            /** Whether <tuplet show-number="none"> was given in the XML, indicating the tuplet number should not be rendered. */
            ShowNumberNoneGivenInXml: boolean;
            /** Determines whether the tuplet should be bracketed (arguments are EngravingRules). */
            shouldBeBracketed(useXmlValue: boolean, tupletsBracketed: boolean, tripletsBracketed: boolean, isTabMeasure?: boolean, tabTupletsBracketed?: boolean): boolean;
            get TupletLabelNumber(): number;
            set TupletLabelNumber(value: number);
            get Notes(): Note[][];
            set Notes(value: Note[][]);
            get Fractions(): Fraction[];
            set Fractions(value: Fraction[]);
            get Bracket(): boolean;
            set Bracket(value: boolean);
            /**
                * Returns the index of the given Note in the Tuplet List (notes[0], notes[1],...).
                * @param note
                * @returns {number}
                */
            getNoteIndex(note: Note): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/VerticalSourceStaffEntryContainer' {
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    /**
      * A [[VerticalSourceStaffEntryContainer]] contains the [[StaffEntry]]s at one timestamp through all the [[StaffLine]]s.
      */
    export class VerticalSourceStaffEntryContainer {
        constructor(parentMeasure: SourceMeasure, timestamp: Fraction, size: number);
        $get$(index: number): SourceStaffEntry;
        $set$(index: number, value: SourceStaffEntry): void;
        get Timestamp(): Fraction;
        set Timestamp(value: Fraction);
        get StaffEntries(): SourceStaffEntry[];
        set StaffEntries(value: SourceStaffEntry[]);
        get Comments(): Comment[];
        set Comments(value: Comment[]);
        get ParentMeasure(): SourceMeasure;
        set ParentMeasure(value: SourceMeasure);
        getAbsoluteTimestamp(): Fraction;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Instructions' {
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/AbstractNotationInstruction";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RhythmInstruction";
    export * from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/TechnicalInstruction";
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicSource/MappingSourceMusicPart' {
    import { SourceMusicPart } from "opensheetmusicdisplay/MusicalScore/MusicSource/SourceMusicPart";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { Repetition } from "opensheetmusicdisplay/MusicalScore/MusicSource/Repetition";
    import { PartListEntry } from "opensheetmusicdisplay/MusicalScore/MusicSource/PartListEntry";
    export class MappingSourceMusicPart {
        constructor(sourceMusicPart: SourceMusicPart, startTimestamp: Fraction, parentPartListEntry?: Repetition, repetitionRun?: number, isEnding?: boolean);
        get IsRepetition(): boolean;
        get IsEnding(): boolean;
        get IsLastRepetitionRun(): boolean;
        get RepetitionRun(): number;
        get ParentPartListEntry(): PartListEntry;
        get SourceMusicPart(): SourceMusicPart;
        get StartTimestamp(): Fraction;
        CompareTo(comp: MappingSourceMusicPart): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicSource/PartListEntry' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    export abstract class PartListEntry {
        constructor(musicSheet: MusicSheet);
        absoluteTimestamp: Fraction;
        startIndex: number;
        endIndex: number;
        protected enrolledTimestamps: Fraction[];
        protected visible: boolean;
        protected musicSheet: MusicSheet;
        get Visible(): boolean;
        set Visible(value: boolean);
        getFirstSourceMeasure(): SourceMeasure;
        getLastSourceMeasure(): SourceMeasure;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/MusicSource/SourceMusicPart' {
    import { PartListEntry } from "opensheetmusicdisplay/MusicalScore/MusicSource/PartListEntry";
    import { Repetition } from "opensheetmusicdisplay/MusicalScore/MusicSource/Repetition";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    export class SourceMusicPart extends PartListEntry {
        constructor(musicSheet: MusicSheet, startIndex?: number, endIndex?: number);
        protected parentRepetition: Repetition;
        get MeasuresCount(): number;
        get StartIndex(): number;
        get EndIndex(): number;
        get ParentRepetition(): Repetition;
        set ParentRepetition(value: Repetition);
        get AbsoluteTimestamp(): Fraction;
        setStartIndex(startIndex: number): void;
        setEndIndex(index: number): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/InstrumentReader' {
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { RhythmInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RhythmInstruction";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { RepetitionInstructionReader } from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/RepetitionInstructionReader";
    import { ReaderPluginManager } from "opensheetmusicdisplay/MusicalScore/ScoreIO/ReaderPluginManager";
    /**
        * An InstrumentReader is used during the reading phase to keep parsing new measures from the MusicXML file
        * with the readNextXmlMeasure method.
        */
    export class InstrumentReader {
            constructor(pluginManager: ReaderPluginManager, repetitionInstructionReader: RepetitionInstructionReader, xmlMeasureList: IXmlElement[], instrument: Instrument);
            pluginManager: ReaderPluginManager;
            get ActiveKey(): KeyInstruction;
            get MaxTieNoteFraction(): Fraction;
            get ActiveRhythm(): RhythmInstruction;
            set ActiveRhythm(value: RhythmInstruction);
            /**
                * Main CreateSheet: read the next XML Measure and save all data to the given [[SourceMeasure]].
                * @param currentMeasure
                * @param measureStartAbsoluteTimestamp - Using this instead of currentMeasure.AbsoluteTimestamp as it isn't set yet
                * @param octavePlusOne Software like Guitar Pro gives one octave too low, so we need to add one
                * @returns {boolean}
                */
            readNextXmlMeasure(currentMeasure: SourceMeasure, measureStartAbsoluteTimestamp: Fraction, octavePlusOne: boolean): boolean;
            /** Parse a color in XML format. Can be #ARGB or #RGB format, colors as byte hex values.
                *  @return color in Vexflow format #[A]RGB or undefined for invalid xmlColorString
                */
            parseXmlColor(xmlColorString: string): string;
            doCalculationsAfterDurationHasBeenSet(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSheetReader' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { IAfterSheetReadingModule } from "opensheetmusicdisplay/MusicalScore/Interfaces/IAfterSheetReadingModule";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { ReaderPluginManager } from "opensheetmusicdisplay/MusicalScore/ScoreIO/ReaderPluginManager";
    export class MusicSheetReader {
            constructor(afterSheetReadingModules?: IAfterSheetReadingModule[], rules?: EngravingRules);
            rules: EngravingRules;
            get PluginManager(): ReaderPluginManager;
            get CompleteNumberOfStaves(): number;
            /**
                * Read a music XML file and saves the values in the MusicSheet class.
                * @param root
                * @param path
                * @returns {MusicSheet}
                */
            createMusicSheet(root: IXmlElement, path: string): MusicSheet;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModuleFactory' {
    import { RepetitionInstructionReader } from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/RepetitionInstructionReader";
    import { RepetitionCalculator } from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/RepetitionCalculator";
    export class MusicSymbolModuleFactory {
        static createRepetitionInstructionReader(): RepetitionInstructionReader;
        static createRepetitionCalculator(): RepetitionCalculator;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/VoiceGenerator' {
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { StemDirectionType } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { Note, TremoloInfo } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { SlurReader } from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/SlurReader";
    import { NoteType } from "opensheetmusicdisplay/MusicalScore/VoiceData/NoteType";
    import { KeyInstruction, RhythmInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions";
    import { ReaderPluginManager } from "opensheetmusicdisplay/MusicalScore/ScoreIO/ReaderPluginManager";
    export class VoiceGenerator {
            constructor(pluginManager: ReaderPluginManager, staff: Staff, voiceId: number, slurReader: SlurReader, mainVoice?: Voice);
            pluginManager: ReaderPluginManager;
            get GetVoice(): Voice;
            get OctaveShift(): number;
            set OctaveShift(value: number);
            /**
                * Create new [[VoiceEntry]], add it to given [[SourceStaffEntry]] and if given so, to [[Voice]].
                * @param musicTimestamp
                * @param parentStaffEntry
                * @param addToVoice
                * @param isGrace States whether the new VoiceEntry (only) has grace notes
                */
            createVoiceEntry(musicTimestamp: Fraction, parentStaffEntry: SourceStaffEntry, activeKey: KeyInstruction, activeRhythm: RhythmInstruction, isGrace?: boolean, hasGraceSlash?: boolean, graceSlur?: boolean): void;
            finalizeReadingMeasure(): void;
            /**
                * Create [[Note]]s and handle Lyrics, Articulations, Beams, Ties, Slurs, Tuplets.
                * @param noteNode
                * @param noteDuration
                * @param divisions
                * @param restNote
                * @param parentStaffEntry
                * @param parentMeasure
                * @param measureStartAbsoluteTimestamp
                * @param maxTieNoteFraction
                * @param chord
                * @param octavePlusOne Software like Guitar Pro gives one octave too low, so we need to add one
                * @param printObject whether the note should be rendered (true) or invisible (false)
                * @returns {Note}
                */
            read(noteNode: IXmlElement, noteDuration: Fraction, typeDuration: Fraction, noteTypeXml: NoteType, normalNotes: number, restNote: boolean, parentStaffEntry: SourceStaffEntry, parentMeasure: SourceMeasure, measureStartAbsoluteTimestamp: Fraction, maxTieNoteFraction: Fraction, chord: boolean, octavePlusOne: boolean, printObject: boolean, isCueNote: boolean, isGraceNote: boolean, stemDirectionXml: StemDirectionType, tremoloInfo: TremoloInfo, stemColorXml: string, noteheadColorXml: string, dotsXml: number): Note;
            /**
                * Create a new [[StaffEntryLink]] and sets the currenstStaffEntry accordingly.
                * @param index
                * @param currentStaff
                * @param currentStaffEntry
                * @param currentMeasure
                * @returns {SourceStaffEntry}
                */
            checkForStaffEntryLink(index: number, currentStaff: Staff, currentStaffEntry: SourceStaffEntry, currentMeasure: SourceMeasure): SourceStaffEntry;
            checkForOpenBeam(): void;
            checkOpenTies(): void;
            hasVoiceEntry(): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules' {
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/ArticulationReader";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/ChordSymbolReader";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/DynamicsCalculator";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/ExpressionReader";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/LyricsReader";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/RepetitionCalculator";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/RepetitionInstructionReader";
    export * from "opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/SlurReader";
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/ReaderPluginManager' {
    import { IVoiceMeasureReadPlugin } from "opensheetmusicdisplay/MusicalScore/Interfaces/IVoiceMeasureReadPlugin";
    import { VoiceEntry, RhythmInstruction, KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData";
    export class ReaderPluginManager {
        addVoiceMeasureReadPlugin(plugin: IVoiceMeasureReadPlugin): void;
        processVoiceMeasureReadPlugins(measureVoiceEntries: VoiceEntry[], activeKey: KeyInstruction, currentRhythm: RhythmInstruction): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalExpression' {
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { AbstractExpression, PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    export abstract class AbstractGraphicalExpression extends GraphicalObject {
        protected label: GraphicalLabel;
        protected parentStaffLine: StaffLine;
        /** Internal cache of read expression */
        protected expression: AbstractExpression;
        /** EngravingRules for positioning */
        protected rules: EngravingRules;
        protected parentMeasure: SourceMeasure;
        constructor(parentStaffline: StaffLine, expression: AbstractExpression, measure: SourceMeasure);
        /** Graphical label of the expression if available */
        get Label(): GraphicalLabel;
        /** Staffline where the expression is attached to */
        get ParentStaffLine(): StaffLine;
        get SourceExpression(): AbstractExpression;
        get Placement(): PlacementEnum;
        abstract updateSkyBottomLine(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalInstruction' {
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    export abstract class AbstractGraphicalInstruction extends GraphicalObject {
        protected parent: GraphicalStaffEntry;
        constructor(parent: GraphicalStaffEntry);
        get Parent(): GraphicalStaffEntry;
        set Parent(value: GraphicalStaffEntry);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/AccidentalCalculator' {
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    /**
        * Compute the accidentals for notes according to the current key instruction
        */
    export class AccidentalCalculator {
            get ActiveKeyInstruction(): KeyInstruction;
            set ActiveKeyInstruction(value: KeyInstruction);
            /**
                * This method is called after each Measure
                * It clears the in-measure alterations dict for the next measure
                * and pre-loads with the alterations of the key signature
                */
            doCalculationsAtEndOfMeasure(): void;
            checkAccidental(graphicalNote: GraphicalNote, pitch: Pitch): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/AlignmentManager' {
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    export class AlignmentManager {
            constructor(staffline: StaffLine);
            alignDynamicExpressions(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/Clickable' {
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    export class Clickable extends GraphicalObject {
        dataObject: Object;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums' {
    import { Dictionary } from "typescript-collections";
    /**
        * The supported styles to draw a rectangle on the music sheet
        */
    export enum OutlineAndFillStyleEnum {
            BaseWritingColor = 0,
            FollowingCursor = 1,
            AlternativeFollowingCursor = 2,
            PlaybackCursor = 3,
            Highlighted = 4,
            ErrorUnderlay = 5,
            Selected = 6,
            SelectionSymbol = 7,
            DebugColor1 = 8,
            DebugColor2 = 9,
            DebugColor3 = 10,
            SplitScreenDivision = 11,
            GreyTransparentOverlay = 12,
            MarkedArea1 = 13,
            MarkedArea2 = 14,
            MarkedArea3 = 15,
            MarkedArea4 = 16,
            MarkedArea5 = 17,
            MarkedArea6 = 18,
            MarkedArea7 = 19,
            MarkedArea8 = 20,
            MarkedArea9 = 21,
            MarkedArea10 = 22,
            Comment1 = 23,
            Comment2 = 24,
            Comment3 = 25,
            Comment4 = 26,
            Comment5 = 27,
            Comment6 = 28,
            Comment7 = 29,
            Comment8 = 30,
            Comment9 = 31,
            Comment10 = 32
    }
    export const OUTLINE_AND_FILL_STYLE_DICT: Dictionary<OutlineAndFillStyleEnum, string>;
    export enum StyleSets {
            MarkedArea = 0,
            Comment = 1
    }
    /**
        * The layers which one can draw on (not supported)
        */
    export enum GraphicalLayers {
            Background = 0,
            Highlight = 1,
            MeasureError = 2,
            SelectionSymbol = 3,
            Cursor = 4,
            PSI_Debug = 5,
            Notes = 6,
            Comment = 7,
            Debug_above = 8
    }
    export enum NoteState {
            Normal = 0,
            Selected = 1,
            Follow_Confirmed = 2,
            QFeedback_NotFound = 3,
            QFeedback_OK = 4,
            QFeedback_Perfect = 5,
            Debug1 = 6,
            Debug2 = 7,
            Debug3 = 8
    }
    export enum AutoColorSet {
            C = "#d82c6b",
            D = "#F89D15",
            E = "#FFE21A",
            F = "#4dbd5c",
            G = "#009D96",
            A = "#43469d",
            B = "#76429c",
            Rest = "#000000"
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/DrawingMode' {
    export enum DrawingMode {
        All = 0,
        NoOverlays = 1,
        Leadsheet = 2
    }
    export enum MusicSymbolDrawingStyle {
        Normal = 0,
        Disabled = 1,
        Selected = 2,
        Clickable = 3,
        PlaybackSymbols = 4,
        FollowSymbols = 5,
        QFeedbackNotFound = 6,
        QFeedbackOk = 7,
        QFeedbackPerfect = 8,
        Debug1 = 9,
        Debug2 = 10,
        Debug3 = 11
    }
    export enum PhonicScoreModes {
        Following = 0,
        Midi = 1,
        Manual = 2
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalChordSymbolContainer' {
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { ChordSymbolContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/ChordSymbolContainer";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    export class GraphicalChordSymbolContainer extends GraphicalObject {
        constructor(chordSymbolContainer: ChordSymbolContainer, parent: BoundingBox, textHeight: number, keyInstruction: KeyInstruction, transposeHalftones: number, rules: EngravingRules);
        get GetChordSymbolContainer(): ChordSymbolContainer;
        get GraphicalLabel(): GraphicalLabel;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalContinuousDynamicExpression' {
    import { GraphicalLine } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { ContinuousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/ContinuousDynamicExpression";
    import { AbstractGraphicalExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalExpression";
    import { ISqueezable } from "opensheetmusicdisplay/MusicalScore/Graphical/ISqueezable";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    /**
        * This class prepares the graphical elements for a continuous expression. It calculates the wedges and
        * wrappings if they are split over system breaks.
        */
    export class GraphicalContinuousDynamicExpression extends AbstractGraphicalExpression implements ISqueezable {
            IsSoftAccent: boolean;
            /**
                * Create a new instance of the GraphicalContinuousDynamicExpression
                * @param continuousDynamic The continuous dynamic instruction read via ExpressionReader
                * @param staffLine The staffline where the expression is attached
                */
            constructor(continuousDynamic: ContinuousDynamicExpression, staffLine: StaffLine, measure: SourceMeasure);
            /** The graphical measure where the parent continuous dynamic expression starts */
            get StartMeasure(): GraphicalMeasure;
            set StartMeasure(value: GraphicalMeasure);
            /** The graphical measure where the parent continuous dynamic expression ends */
            get EndMeasure(): GraphicalMeasure;
            set EndMeasure(value: GraphicalMeasure);
            /** The staff lin where the graphical dynamic expressions ends */
            get EndStaffLine(): StaffLine;
            /**  Is true if this continuous expression is a wedge, that reaches over a system border and needs to be split into two. */
            get IsSplittedPart(): boolean;
            set IsSplittedPart(value: boolean);
            /**  Is true if the dynamic is not a symbol but a text instruction. E.g. "decrescendo" */
            get IsVerbal(): boolean;
            /** True if this expression should not be removed if re-rendered */
            get NotToBeRemoved(): boolean;
            set NotToBeRemoved(value: boolean);
            /** Holds the line objects that can be drawn via implementation */
            get Lines(): GraphicalLine[];
            get ContinuousDynamic(): ContinuousDynamicExpression;
            updateSkyBottomLine(): void;
            /**
                * Calculate crescendo lines for (full).
                * @param startX left most starting point
                * @param endX right mist ending point
                * @param y y placement
                * @param wedgeOpeningLength length of the opening
                * @param wedgeLineWidth line width of the wedge
                */
            createCrescendoLines(startX: number, endX: number, y: number, wedgeOpeningLength?: number, wedgeLineWidth?: number): void;
            /**
                * Calculate crescendo lines for system break (first part).
                * @param startX left most starting point
                * @param endX right mist ending point
                * @param y y placement
                * @param wedgeMeasureEndOpeningLength length of opening at measure end
                * @param wedgeOpeningLength length of the opening
                * @param wedgeLineWidth line width of the wedge
                */
            createFirstHalfCrescendoLines(startX: number, endX: number, y: number, wedgeMeasureEndOpeningLength?: number, wedgeLineWidth?: number): void;
            /**
                * Calculate crescendo lines for system break (second part).
                * @param startX left most starting point
                * @param endX right mist ending point
                * @param y y placement
                * @param wedgeMeasureBeginOpeningLength length of opening at measure start
                * @param wedgeOpeningLength length of the opening
                * @param wedgeLineWidth line width of the wedge
                */
            createSecondHalfCrescendoLines(startX: number, endX: number, y: number, wedgeMeasureBeginOpeningLength?: number, wedgeOpeningLength?: number, wedgeLineWidth?: number): void;
            /**
                * This method recalculates the Crescendo Lines (for all cases).
                * @param startX left most starting point
                * @param endX right most ending point
                * @param y y placement
                */
            recalculateCrescendoLines(startX: number, endX: number, y: number): void;
            /**
                * Calculate diminuendo lines for system break (full).
                * @param startX left most starting point
                * @param endX right mist ending point
                * @param y y placement
                * @param wedgeOpeningLength length of the opening
                * @param wedgeLineWidth line width of the wedge
                */
            createDiminuendoLines(startX: number, endX: number, y: number, wedgeOpeningLength?: number, wedgeLineWidth?: number): void;
            /**
                * Calculate diminuendo lines for system break (first part).
                * @param startX left most starting point
                * @param endX right mist ending point
                * @param y y placement
                * @param wedgeOpeningLength length of the opening
                * @param wedgeMeasureEndOpeningLength length of opening at measure end
                * @param wedgeLineWidth line width of the wedge
                */
            createFirstHalfDiminuendoLines(startX: number, endX: number, y: number, wedgeOpeningLength?: number, wedgeMeasureEndOpeningLength?: number, wedgeLineWidth?: number): void;
            /**
                * Calculate diminuendo lines for system break (second part).
                * @param startX left most starting point
                * @param endX right mist ending point
                * @param y y placement
                * @param wedgeMeasureBeginOpeningLength length of opening at measure start
                * @param wedgeLineWidth line width of the wedge
                */
            createSecondHalfDiminuendoLines(startX: number, endX: number, y: number, wedgeMeasureBeginOpeningLength?: number, wedgeLineWidth?: number): void;
            /**
                * This method recalculates the diminuendo lines (for all cases).
                * @param startX left most starting point
                * @param endX right most ending point
                * @param y y placement
                */
            recalculateDiminuendoLines(startX: number, endX: number, yPosition: number): void;
            /** Wrapper for createFirstHalfCrescendoLines and createFirstHalfDiminuendoLines.
                * Checks whether `this` is crescendo or diminuendo, helps avoid code duplication.
                */
            createFirstHalfLines(startX: number, endX: number, y: number, wedgeOpeningLength?: number, wedgeMeasureEndOpeningLength?: number, wedgeLineWidth?: number): void;
            /** Wrapper for createSecondHalfCrescendoLines and createSecondHalfDiminuendoLines, see createFirstHalfLines. */
            createSecondHalfLines(startX: number, endX: number, y: number, wedgeMeasureBeginOpeningLength?: number, wedgeOpeningLength?: number, wedgeLineWidth?: number): void;
            /** Wrapper for createCrescendoLines and createDiminuendoLines, see createFirstHalfLines. */
            createLines(startX: number, endX: number, y: number, wedgeOpeningLength?: number, wedgeLineWidth?: number): void;
            /**
                * Calculate the BoundingBox (as a box around the Wedge).
                */
            calcPsi(): void;
            /**
                * Clear Lines
                */
            cleanUp(): void;
            /**
                * Shift wedge in y position
                * @param shift Number to shift
                */
            shiftYPosition(shift: number): void;
            squeeze(value: number): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalCurve' {
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    export class GraphicalCurve {
        constructor();
        bezierStartPt: PointF2D;
        bezierStartControlPt: PointF2D;
        bezierEndControlPt: PointF2D;
        bezierEndPt: PointF2D;
        /**
          *
          * @param relativePosition
          */
        calculateCurvePointAtIndex(relativePosition: number): PointF2D;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalGlissando' {
    import { Glissando } from "opensheetmusicdisplay/MusicalScore/VoiceData/Glissando";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { GraphicalLine } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    export class GraphicalGlissando {
        Glissando: Glissando;
        Line: GraphicalLine;
        staffEntries: GraphicalStaffEntry[];
        StaffLine: StaffLine;
        Width: number;
        Color: string;
        constructor(glissando: Glissando);
        calculateLine(rules: EngravingRules): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalInstantaneousDynamicExpression' {
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { InstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousDynamicExpression";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { AbstractGraphicalExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalExpression";
    export class GraphicalInstantaneousDynamicExpression extends AbstractGraphicalExpression {
        protected mInstantaneousDynamicExpression: InstantaneousDynamicExpression;
        protected mMeasure: GraphicalMeasure;
        constructor(instantaneousDynamic: InstantaneousDynamicExpression, staffLine: StaffLine, measure: GraphicalMeasure);
        updateSkyBottomLine(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalInstantaneousTempoExpression' {
    import { AbstractTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractTempoExpression";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { AbstractGraphicalExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalExpression";
    export class GraphicalInstantaneousTempoExpression extends AbstractGraphicalExpression {
        constructor(tempoExpresssion: AbstractTempoExpression, label: GraphicalLabel);
        get GraphicalLabel(): GraphicalLabel;
        updateSkyBottomLine(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel' {
    import { TextAlignmentEnum } from "opensheetmusicdisplay/Common/Enums/TextAlignment";
    import { Label } from "opensheetmusicdisplay/MusicalScore/Label";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { Clickable } from "opensheetmusicdisplay/MusicalScore/Graphical/Clickable";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    /**
        * The graphical counterpart of a Label
        */
    export class GraphicalLabel extends Clickable {
            TextLines: {
                    text: string;
                    xOffset: number;
                    width: number;
            }[];
            /** A reference to the Node in the SVG, if SVGBackend, otherwise undefined.
                *  Allows manipulation without re-rendering, e.g. for dynamics, lyrics, etc.
                *  For the Canvas backend, this is unfortunately not possible.
                */
            SVGNode: Node;
            /** Read-only informational variable only set once by lyrics centering algorithm. */
            CenteringXShift: number;
            ColorXML: string;
            /**
                * Creates a new GraphicalLabel from a Label
                * @param label  label object containing text
                * @param textHeight Height of text
                * @param alignment Alignement like left, right, top, ...
                * @param parent Parent Bounding Box where the label is attached to
                */
            constructor(label: Label, textHeight: number, alignment: TextAlignmentEnum, rules: EngravingRules, parent?: BoundingBox);
            get Label(): Label;
            toString(): string;
            /**
                * Calculate GraphicalLabel's Borders according to its Alignment
                * Create also the text-lines and their offsets here
                */
            setLabelPositionAndShapeBorders(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine' {
    import { OutlineAndFillStyleEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    export class GraphicalLine {
        constructor(start: PointF2D, end: PointF2D, width?: number, styleEnum?: OutlineAndFillStyleEnum, colorHex?: string);
        styleId: number;
        colorHex: string;
        get Start(): PointF2D;
        set Start(value: PointF2D);
        get End(): PointF2D;
        set End(value: PointF2D);
        get Width(): number;
        set Width(value: number);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLyricEntry' {
    import { LyricsEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsEntry";
    import { GraphicalLyricWord } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLyricWord";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    /**
      * The graphical counterpart of a [[LyricsEntry]]
      */
    export class GraphicalLyricEntry {
        constructor(lyricsEntry: LyricsEntry, graphicalStaffEntry: GraphicalStaffEntry, lyricsHeight: number, staffHeight: number);
        hasDashFromLyricWord(): boolean;
        get LyricsEntry(): LyricsEntry;
        get ParentLyricWord(): GraphicalLyricWord;
        set ParentLyricWord(value: GraphicalLyricWord);
        get GraphicalLabel(): GraphicalLabel;
        set GraphicalLabel(value: GraphicalLabel);
        get StaffEntryParent(): GraphicalStaffEntry;
        set StaffEntryParent(value: GraphicalStaffEntry);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLyricWord' {
    import { LyricWord } from "opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsWord";
    import { GraphicalLyricEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLyricEntry";
    /**
      * The graphical counterpart of a [[LyricWord]]
      */
    export class GraphicalLyricWord {
        constructor(lyricWord: LyricWord);
        get GetLyricWord(): LyricWord;
        get GraphicalLyricsEntries(): GraphicalLyricEntry[];
        set GraphicalLyricsEntries(value: GraphicalLyricEntry[]);
        isFilled(): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMarkedArea' {
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { GraphicalRectangle } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalRectangle";
    export class GraphicalMarkedArea {
        constructor(systemRectangle: GraphicalRectangle, labelRectangle?: GraphicalRectangle, label?: GraphicalLabel, settingsLabel?: GraphicalLabel);
        systemRectangle: GraphicalRectangle;
        labelRectangle: GraphicalRectangle;
        label: GraphicalLabel;
        settings: GraphicalLabel;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure' {
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { RhythmInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RhythmInstruction";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { SystemLinesEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    /**
        * Represents a measure in the music sheet (one measure in one staff line)
        */
    export abstract class GraphicalMeasure extends GraphicalObject {
            protected firstInstructionStaffEntry: GraphicalStaffEntry;
            protected lastInstructionStaffEntry: GraphicalStaffEntry;
            constructor(staff?: Staff, parentSourceMeasure?: SourceMeasure, staffLine?: StaffLine);
            parentSourceMeasure: SourceMeasure;
            staffEntries: GraphicalStaffEntry[];
            /** The clef of the first note of the measure (the clef the measure starts with). */
            InitiallyActiveClef: ClefInstruction;
            /**
                * The x-width of possibly existing: repetition start line, clef, key, rhythm.
                */
            beginInstructionsWidth: number;
            /**
                * The minimum possible x-width of all staff entries without overlapping.
                */
            minimumStaffEntriesWidth: number;
            /**
                * Will be set by music system builder while building systems.
                */
            staffEntriesScaleFactor: number;
            /**
                * The x-width of possibly existing: repetition end line, clef.
                */
            endInstructionsWidth: number;
            hasError: boolean;
            /**
                * Whether or not this measure is nothing but rest(s).
                * Also see SourceMeasure.allRests, which is not the same, because a source measure can have multiple staffs/graphicalMeasures.
                */
            hasOnlyRests: boolean;
            /** Used to show key, rhythm changes at the end of the system, has MeasureNumber < 0, because never set. */
            IsExtraGraphicalMeasure: boolean;
            ExtraGraphicalMeasurePreviousMeasure: GraphicalMeasure;
            ShowTimeSignature: boolean;
            ShowKeySignature: boolean;
            isTabMeasure: boolean;
            get ParentStaff(): Staff;
            get ParentMusicSystem(): MusicSystem;
            set ParentMusicSystem(value: MusicSystem);
            get MeasureNumber(): number;
            get FirstInstructionStaffEntry(): GraphicalStaffEntry;
            set FirstInstructionStaffEntry(value: GraphicalStaffEntry);
            get LastInstructionStaffEntry(): GraphicalStaffEntry;
            set LastInstructionStaffEntry(value: GraphicalStaffEntry);
            get ParentStaffLine(): StaffLine;
            set ParentStaffLine(value: StaffLine);
            /**
                * Reset all the geometric values and parameters of this measure and put it in an initialized state.
                * This is needed to evaluate a measure a second time by system builder.
                */
            resetLayout(): void;
            /**
                * Return the x-width of a given measure line.
                * @param line
                */
            getLineWidth(line: SystemLinesEnum): number;
            /**
                * Add the given clef to the begin of the measure.
                * This has to update/increase BeginInstructionsWidth.
                * @param clef
                */
            addClefAtBegin(clef: ClefInstruction): void;
            /**
                * Add the given key to the begin of the measure.
                * This has to update/increase BeginInstructionsWidth.
                * @param currentKey - The new valid key.
                * @param previousKey - The old cancelled key. Needed to show which accidentals are not valid any more.
                * @param currentClef - The valid clef. Needed to put the accidentals on the right y-positions.
                */
            addKeyAtBegin(currentKey: KeyInstruction, previousKey: KeyInstruction, currentClef: ClefInstruction): void;
            /**
                * Add the given rhythm to the begin of the measure.
                * This has to update/increase BeginInstructionsWidth.
                * @param rhythm
                */
            addRhythmAtBegin(rhythm: RhythmInstruction): void;
            /**
                * Add the given clef to the end of the measure.
                * This has to update/increase EndInstructionsWidth.
                * @param clef
                */
            addClefAtEnd(clef: ClefInstruction, visible?: boolean): void;
            /**
                * Set the x-position relative to the staffline (y-Position is always 0 relative to the staffline).
                * @param xPos
                */
            setPositionInStaffline(xPos: number): void;
            /**
                * Set the overall x-width of the measure.
                * @param width
                */
            setWidth(width: number): void;
            /**
                * This method is called after the StaffEntriesScaleFactor has been set.
                * Here the final x-positions of the staff entries have to be set.
                * (multiply the minimal positions with the scaling factor, considering the BeginInstructionsWidth).
                */
            layoutSymbols(): void;
            findGraphicalStaffEntryFromTimestamp(relativeTimestamp: Fraction): GraphicalStaffEntry;
            /**
                * Iterate from start to end and find the [[GraphicalStaffEntry]] with the same absolute timestamp.
                * @param absoluteTimestamp
                * @returns {any}
                */
            findGraphicalStaffEntryFromVerticalContainerTimestamp(absoluteTimestamp: Fraction): GraphicalStaffEntry;
            /**
                * Check if the all the [[GraphicalMeasure]]'s [[StaffEntry]]s (their minimum Length) have the same duration with the [[SourceMeasure]].
                * @returns {boolean}
                */
            hasSameDurationWithSourceMeasureParent(): boolean;
            /**
                * Check a whole [[Measure]] for the presence of multiple Voices (used for Stem direction).
                * @returns {boolean}
                */
            hasMultipleVoices(): boolean;
            isVisible(): boolean;
            getGraphicalMeasureDurationFromStaffEntries(): Fraction;
            addGraphicalStaffEntry(graphicalStaffEntry: GraphicalStaffEntry): void;
            /**
                * Add a [[StaffEntry]] (along with its [[BoundingBox]]) to the current Measure.
                * @param staffEntry
                */
            addGraphicalStaffEntryAtTimestamp(staffEntry: GraphicalStaffEntry): void;
            isPianoRightHand(): boolean;
            isPianoLeftHand(): boolean;
            isUpperStaffOfInstrument(): boolean;
            isLowerStaffOfInstrument(): boolean;
            beginsWithLineRepetition(): boolean;
            /**
                * Check if this Measure is a Repetition Ending.
                * @returns {boolean}
                */
            endsWithLineRepetition(): boolean;
            /**
                * Check if a Repetition starts at the next Measure.
                * @returns {boolean}
                */
            beginsWithWordRepetition(): boolean;
            /**
                * Check if this Measure is a Repetition Ending.
                */
            endsWithWordRepetition(): boolean;
            getTransposedHalftones(): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject' {
    import { AClassHierarchyTrackable } from "opensheetmusicdisplay/Common/Interfaces/AClassHierarchyTrackable";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    export class GraphicalObject extends AClassHierarchyTrackable {
        protected boundingBox: BoundingBox;
        get PositionAndShape(): BoundingBox;
        set PositionAndShape(value: BoundingBox);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalOctaveShift' {
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { OctaveShift } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { MusicSymbol } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSymbol";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    /**
      * The graphical counterpart of an [[OctaveShift]]
      */
    export class GraphicalOctaveShift extends GraphicalObject {
        constructor(octaveShift: OctaveShift, parent: BoundingBox);
        getOctaveShift: OctaveShift;
        octaveSymbol: MusicSymbol;
        dashesStart: PointF2D;
        dashesEnd: PointF2D;
        endsOnDifferentStaffLine: boolean;
        /** Whether the octave shift should be drawn until the end of the measure, instead of the current note. */
        graphicalEndAtMeasureEnd: boolean;
        /** The measure in which this OctaveShift (which can be a part/bracket of a multi-line shift) ends graphically. */
        endMeasure: GraphicalMeasure;
        isFirstPart: boolean;
        isSecondPart: boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalRectangle' {
    import { OutlineAndFillStyleEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    export class GraphicalRectangle extends GraphicalObject {
        constructor(upperLeftPoint: PointF2D, lowerRightPoint: PointF2D, parent: BoundingBox, style: OutlineAndFillStyleEnum);
        style: OutlineAndFillStyleEnum;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalSlur' {
    import { GraphicalCurve } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalCurve";
    import { Slur } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Slur";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    export class GraphicalSlur extends GraphicalCurve {
            constructor(slur: Slur, rules: EngravingRules);
            slur: Slur;
            staffEntries: GraphicalStaffEntry[];
            placement: PlacementEnum;
            graceStart: boolean;
            graceEnd: boolean;
            SVGElement: Node;
            /**
                * Compares the timespan of two Graphical Slurs
                * @param x
                * @param y
                */
            static Compare(x: GraphicalSlur, y: GraphicalSlur): number;
            /**
                *
                * @param rules
                */
            calculateCurve(rules: EngravingRules): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry' {
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { VerticalGraphicalStaffEntryContainer } from "opensheetmusicdisplay/MusicalScore/Graphical/VerticalGraphicalStaffEntryContainer";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { Slur } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Slur";
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { GraphicalTie } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalTie";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { GraphicalChordSymbolContainer } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalChordSymbolContainer";
    import { GraphicalLyricEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLyricEntry";
    import { AbstractGraphicalInstruction } from "opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalInstruction";
    import { GraphicalStaffEntryLink } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntryLink";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { Tie } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tie";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    /**
        * The graphical counterpart of a [[SourceStaffEntry]].
        */
    export abstract class GraphicalStaffEntry extends GraphicalObject {
            constructor(parentMeasure: GraphicalMeasure, sourceStaffEntry?: SourceStaffEntry, staffEntryParent?: GraphicalStaffEntry);
            graphicalChordContainers: GraphicalChordSymbolContainer[];
            graphicalLink: GraphicalStaffEntryLink;
            relInMeasureTimestamp: Fraction;
            sourceStaffEntry: SourceStaffEntry;
            parentMeasure: GraphicalMeasure;
            graphicalVoiceEntries: GraphicalVoiceEntry[];
            staffEntryParent: GraphicalStaffEntry;
            parentVerticalContainer: VerticalGraphicalStaffEntryContainer;
            tabStaffEntry: GraphicalStaffEntry;
            MaxAccidentals: number;
            ties: Tie[];
            FingeringEntries: GraphicalLabel[];
            get GraphicalInstructions(): AbstractGraphicalInstruction[];
            get GraphicalTies(): GraphicalTie[];
            get LyricsEntries(): GraphicalLyricEntry[];
            set LyricsEntries(value: GraphicalLyricEntry[]);
            /**
                * Calculate the absolute Timestamp.
                * @returns {Fraction}
                */
            getAbsoluteTimestamp(): Fraction;
            /**
                * Search through all the GraphicalNotes to find the suitable one for a TieEndNote.
                * @param tieNote
                * @returns {any}
                */
            findTieGraphicalNoteFromNote(tieNote: Note): GraphicalNote;
            /**
                * Search through all [[GraphicalNote]]s to find the suitable one for an StartSlurNote (that 's also an EndTieNote).
                * @param tieNote
                * @param slur
                * @returns {any}
                */
            findEndTieGraphicalNoteFromNoteWithStartingSlur(tieNote: Note, slur: Slur): GraphicalNote;
            findGraphicalNoteFromGraceNote(graceNote: Note): GraphicalNote;
            findGraphicalNoteFromNote(note: Note): GraphicalNote;
            getGraphicalNoteDurationFromVoice(voice: Voice): Fraction;
            /**
                * Find the [[StaffEntry]]'s [[GraphicalNote]]s that correspond to the given [[VoiceEntry]]'s [[Note]]s.
                * @param voiceEntry
                * @returns {any}
                */
            findVoiceEntryGraphicalNotes(voiceEntry: VoiceEntry): GraphicalNote[];
            /**
                * Check if the given [[VoiceEntry]] is part of the [[StaffEntry]]'s Linked [[VoiceEntry]].
                * @param voiceEntry
                * @returns {boolean}
                */
            isVoiceEntryPartOfLinkedVoiceEntry(voiceEntry: VoiceEntry): boolean;
            /**
                * Return the [[StaffEntry]]'s Minimum NoteLength.
                * @returns {Fraction}
                */
            findStaffEntryMinNoteLength(): Fraction;
            findStaffEntryMaxNoteLength(): Fraction;
            /**
                * Find or creates the list of [[GraphicalNote]]s in case of a [[VoiceEntry]] (not from TiedNote).
                * @param voiceEntry
                * @returns {GraphicalNote[]}
                */
            findOrCreateGraphicalVoiceEntry(voiceEntry: VoiceEntry): GraphicalVoiceEntry;
            /**
                * Find or creates the list of [[GraphicalNote]]s in case of a TiedNote.
                * @param graphicalNote
                * @returns {GraphicalNote[]}
                */
            findOrCreateGraphicalVoiceEntryFromGraphicalNote(graphicalNote: GraphicalNote): GraphicalVoiceEntry;
            /**
                * Insert the [[GraphicalNote]] to the correct index of the [[GraphicalNote]]s list,
                * so that the order of the [[GraphicalNote]]'s in the list corresponds to the [[VoiceEntry]]'s [[Note]]s order.
                * (needed when adding Tie-EndNotes).
                * @param graphicalNotes
                * @param graphicalNote
                */
            addGraphicalNoteToListAtCorrectYPosition(gve: GraphicalVoiceEntry, graphicalNote: GraphicalNote): void;
            /**
                * Returns true if this staff entry has only rests
                */
            hasOnlyRests(): boolean;
            getSkylineMin(): number;
            /** Highest Y around the staff entry and notes in OSMD units (pixels / 10). Note that negative y is up. */
            getHighestYAtEntry(): number;
            /** Lowest Y around the staff entry and notes in OSMD units (pixels / 10). Note that positive y is down. */
            getLowestYAtEntry(): number;
            getBottomlineMax(): number;
            getAbsoluteStartAndEnd(): [number, number];
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntryLink' {
    import { StaffEntryLink } from "opensheetmusicdisplay/MusicalScore/VoiceData/StaffEntryLink";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    /**
        * The graphical counterpart of a [[StaffEntryLink]].
        * Used for linked voices.
        */
    export class GraphicalStaffEntryLink {
            constructor(staffEntryLink: StaffEntryLink);
            get GetStaffEntryLink(): StaffEntryLink;
            get GraphicalLinkedStaffEntries(): GraphicalStaffEntry[];
            set GraphicalLinkedStaffEntries(value: GraphicalStaffEntry[]);
            isFilled(): boolean;
            /**
                * Return all the [[GraphicalNote]]s that correspond to the [[LinkedVoiceEntry]] (the one saved in [[StaffEntryLink]]).
                * @param graphicalStaffEntry
                * @returns {any}
                */
            getLinkedStaffEntriesGraphicalNotes(graphicalStaffEntry: GraphicalStaffEntry): GraphicalNote[];
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalTie' {
    import { Tie } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tie";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import Vex from "vexflow";
    import VF = Vex.Flow;
    /**
      * The graphical counterpart of a [[Tie]].
      */
    export class GraphicalTie {
        vfTie: VF.StaveTie;
        constructor(tie: Tie, start?: GraphicalNote, end?: GraphicalNote);
        get SVGElement(): HTMLElement;
        get GetTie(): Tie;
        get StartNote(): GraphicalNote;
        get Tie(): Tie;
        set StartNote(value: GraphicalNote);
        get EndNote(): GraphicalNote;
        set EndNote(value: GraphicalNote);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry' {
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { OctaveEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    /**
        * The graphical counterpart of a [[VoiceEntry]].
        */
    export class GraphicalVoiceEntry extends GraphicalObject {
            constructor(parentVoiceEntry: VoiceEntry, parentStaffEntry: GraphicalStaffEntry, rules?: EngravingRules);
            parentVoiceEntry: VoiceEntry;
            parentStaffEntry: GraphicalStaffEntry;
            notes: GraphicalNote[];
            /** Contains octave shifts affecting this voice entry, caused by octave brackets. */
            octaveShiftValue: OctaveEnum;
            protected rules: EngravingRules;
            GraceSlash: boolean;
            /** Sort this entry's notes by pitch.
                * Notes need to be sorted for Vexflow StaveNote creation.
                * Note that Vexflow needs the reverse order, see VexFlowConverter.StaveNote().
                */
            sort(): GraphicalNote[];
            /** Sort notes for vexflow (bottom to top), which needs them in the reverse order OSMD likes to have them.
                *  Note that sort() and reverse() replace the array in place,
                *  so to avoid changing the array one could copy it first, see sortedNotesCopyForVexflow() (commented),
                *  though copying the array is also unnecessary (time+memory) for now.
                */
            sortForVexflow(): GraphicalNote[];
            /** (Re-)color notes and stems
                */
            color(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/ISqueezable' {
    export interface ISqueezable {
        /**
          * Squeezes the wedge by the given amount.
          * @param value Squeeze amount. Positive values squeeze from the left, negative from the right
          */
        squeeze(value: number): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/MusicSheetCalculator' {
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { GraphicalMusicSheet } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { Tie } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tie";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { LyricWord } from "opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsWord";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { Beam } from "opensheetmusicdisplay/MusicalScore/VoiceData/Beam";
    import { OctaveEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { OrnamentContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/OrnamentContainer";
    import { Articulation } from "opensheetmusicdisplay/MusicalScore/VoiceData/Articulation";
    import { Tuplet } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tuplet";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { GraphicalTie } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalTie";
    import { RepetitionInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction";
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    import { StaffEntryLink } from "opensheetmusicdisplay/MusicalScore/VoiceData/StaffEntryLink";
    import { MultiTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiTempoExpression";
    import { Repetition } from "opensheetmusicdisplay/MusicalScore/MusicSource/Repetition";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { TextAlignmentEnum } from "opensheetmusicdisplay/Common/Enums/TextAlignment";
    import { TechnicalInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/TechnicalInstruction";
    import { IGraphicalSymbolFactory } from "opensheetmusicdisplay/MusicalScore/Interfaces/IGraphicalSymbolFactory";
    import { ITextMeasurer } from "opensheetmusicdisplay/MusicalScore/Interfaces/ITextMeasurer";
    import { ITransposeCalculator } from "opensheetmusicdisplay/MusicalScore/Interfaces/ITransposeCalculator";
    import { AccidentalCalculator } from "opensheetmusicdisplay/MusicalScore/Graphical/AccidentalCalculator";
    import { GraphicalLyricWord } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLyricWord";
    import { SkyBottomLineCalculator } from "opensheetmusicdisplay/MusicalScore/Graphical/SkyBottomLineCalculator";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { InstantaneousTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousTempoExpression";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { GraphicalInstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalInstantaneousDynamicExpression";
    import { GraphicalContinuousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalContinuousDynamicExpression";
    import { IStafflineNoteCalculator } from "opensheetmusicdisplay/MusicalScore/Interfaces/IStafflineNoteCalculator";
    /**
        * Class used to do all the calculations in a MusicSheet, which in the end populates a GraphicalMusicSheet.
        */
    export abstract class MusicSheetCalculator {
            static symbolFactory: IGraphicalSymbolFactory;
            static transposeCalculator: ITransposeCalculator;
            static stafflineNoteCalculator: IStafflineNoteCalculator;
            protected static textMeasurer: ITextMeasurer;
            protected staffEntriesWithGraphicalTies: GraphicalStaffEntry[];
            protected staffEntriesWithOrnaments: GraphicalStaffEntry[];
            protected staffEntriesWithChordSymbols: GraphicalStaffEntry[];
            protected staffLinesWithLyricWords: StaffLine[];
            protected graphicalLyricWords: GraphicalLyricWord[];
            protected graphicalMusicSheet: GraphicalMusicSheet;
            protected rules: EngravingRules;
            protected musicSystems: MusicSystem[];
            static get TextMeasurer(): ITextMeasurer;
            static set TextMeasurer(value: ITextMeasurer);
            protected get leadSheet(): boolean;
            protected static setMeasuresMinStaffEntriesWidth(measures: GraphicalMeasure[], minimumStaffEntriesWidth: number): void;
            initialize(graphicalMusicSheet: GraphicalMusicSheet): void;
            /**
                * Build the 2D [[GraphicalMeasure]] list needed for the [[MusicSheetCalculator]].
                * Internally it creates [[GraphicalMeasure]]s, [[GraphicalStaffEntry]]'s and [[GraphicalNote]]s.
                */
            prepareGraphicalMusicSheet(): void;
            /**
                * The main method for the Calculator.
                */
            calculate(): void;
            calculateXLayout(graphicalMusicSheet: GraphicalMusicSheet, maxInstrNameLabelLength: number): void;
            calculateMeasureWidthFromStaffEntries(measuresVertical: GraphicalMeasure[], oldMinimumStaffEntriesWidth: number): number;
            protected formatMeasures(): void;
            /**
                * Calculates the x layout of the staff entries within the staff measures belonging to one source measure.
                * All staff entries are x-aligned throughout all the measures.
                * @param measures - The minimum required x width of the source measure
                */
            protected calculateMeasureXLayout(measures: GraphicalMeasure[]): number;
            /**
                * Called for every source measure when generating the list of staff measures for it.
                */
            protected initGraphicalMeasuresCreation(): void;
            protected handleBeam(graphicalNote: GraphicalNote, beam: Beam, openBeams: Beam[]): void;
            /**
                * Check if the tied graphical note belongs to any beams or tuplets and react accordingly.
                * @param tiedGraphicalNote
                * @param beams
                * @param activeClef
                * @param octaveShiftValue
                * @param graphicalStaffEntry
                * @param duration
                * @param openTie
                * @param isLastTieNote
                */
            protected handleTiedGraphicalNote(tiedGraphicalNote: GraphicalNote, beams: Beam[], activeClef: ClefInstruction, octaveShiftValue: OctaveEnum, graphicalStaffEntry: GraphicalStaffEntry, duration: Fraction, openTie: Tie, isLastTieNote: boolean): void;
            protected handleVoiceEntryLyrics(voiceEntry: VoiceEntry, graphicalStaffEntry: GraphicalStaffEntry, openLyricWords: LyricWord[]): void;
            protected handleVoiceEntryOrnaments(ornamentContainer: OrnamentContainer, voiceEntry: VoiceEntry, graphicalStaffEntry: GraphicalStaffEntry): void;
            protected handleVoiceEntryArticulations(articulations: Articulation[], voiceEntry: VoiceEntry, staffEntry: GraphicalStaffEntry): void;
            /**
                * Adds a technical instruction at the given staff entry.
                * @param technicalInstructions
                * @param voiceEntry
                * @param staffEntry
                */
            protected handleVoiceEntryTechnicalInstructions(technicalInstructions: TechnicalInstruction[], voiceEntry: VoiceEntry, staffEntry: GraphicalStaffEntry): void;
            protected handleTuplet(graphicalNote: GraphicalNote, tuplet: Tuplet, openTuplets: Tuplet[]): void;
            protected layoutVoiceEntry(voiceEntry: VoiceEntry, graphicalNotes: GraphicalNote[], graphicalStaffEntry: GraphicalStaffEntry, hasPitchedNote: boolean): void;
            protected layoutStaffEntry(graphicalStaffEntry: GraphicalStaffEntry): void;
            protected createGraphicalTie(tie: Tie, startGse: GraphicalStaffEntry, endGse: GraphicalStaffEntry, startNote: GraphicalNote, endNote: GraphicalNote): GraphicalTie;
            protected updateStaffLineBorders(staffLine: StaffLine): void;
            /**
                * Iterate through all Measures and calculates the MeasureNumberLabels.
                * @param musicSystem
                */
            protected calculateMeasureNumberPlacement(musicSystem: MusicSystem): void;
            /**
                * Calculate the shape (Bézier curve) for this tie.
                * @param tie
                * @param tieIsAtSystemBreak
                */
            protected layoutGraphicalTie(tie: GraphicalTie, tieIsAtSystemBreak: boolean, isTab: boolean): void;
            /**
                * Calculate the Lyrics YPositions for a single [[StaffLine]].
                * @param staffLine
                * @param lyricVersesNumber
                */
            protected calculateSingleStaffLineLyricsPosition(staffLine: StaffLine, lyricVersesNumber: string[]): GraphicalStaffEntry[];
            /**
                * calculates the dashes of lyric words and the extending underscore lines of syllables sung on more than one note.
                * @param lyricsStaffEntries
                */
            protected calculateLyricsExtendsAndDashes(lyricsStaffEntries: GraphicalStaffEntry[]): void;
            /**
                * Calculate a single OctaveShift for a [[MultiExpression]].
                * @param sourceMeasure
                * @param multiExpression
                * @param measureIndex
                * @param staffIndex
                */
            protected calculateSingleOctaveShift(sourceMeasure: SourceMeasure, multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            /**
                * Calculate a single Pedal for a [[MultiExpression]].
                * @param sourceMeasure
                * @param multiExpression
                * @param measureIndex
                * @param staffIndex
                */
            protected abstract calculateSinglePedal(sourceMeasure: SourceMeasure, multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            /**
                * Calculate a single Wavy Line for a [[MultiExpression]].
                * @param sourceMeasure
                * @param multiExpression
                * @param measureIndex
                * @param staffIndex
                */
            protected abstract calculateSingleWavyLine(sourceMeasure: SourceMeasure, multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            /**
                * Calculate all the textual [[RepetitionInstruction]]s (e.g. dal segno) for a single [[SourceMeasure]].
                * @param repetitionInstruction
                * @param measureIndex
                */
            protected calculateWordRepetitionInstruction(repetitionInstruction: RepetitionInstruction, measureIndex: number): void;
            /**
                * Calculate all the Mood and Unknown Expressions for a single [[MultiExpression]].
                * @param multiExpression
                * @param measureIndex
                * @param staffIndex
                */
            protected calculateMoodAndUnknownExpression(multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            /**
                * Delete all Objects that must be recalculated.
                * If graphicalMusicSheet.reCalculate has been called, then this method will be called to reset or remove all flexible
                * graphical music symbols (e.g. Ornaments, Lyrics, Slurs) graphicalMusicSheet will have MusicPages, they will have MusicSystems etc...
                */
            protected clearRecreatedObjects(): void;
            /**
                * This method handles a [[StaffEntryLink]].
                * @param graphicalStaffEntry
                * @param staffEntryLinks
                */
            protected handleStaffEntryLink(graphicalStaffEntry: GraphicalStaffEntry, staffEntryLinks: StaffEntryLink[]): void;
            /**
                * Store the newly computed [[Measure]]s in newly created [[MusicSystem]]s.
                */
            protected calculateMusicSystems(): void;
            protected calculateMarkedAreas(): void;
            protected calculateChordSymbols(): void;
            protected calculateAlignedChordSymbolsOffset(staffEntries: GraphicalStaffEntry[], sbc: SkyBottomLineCalculator): number;
            /**
                * Do layout on staff measures which only consist of a full rest.
                * @param rest
                * @param gse
                * @param measure
                */
            protected layoutMeasureWithWholeRest(rest: GraphicalNote, gse: GraphicalStaffEntry, measure: GraphicalMeasure): void;
            protected layoutBeams(staffEntry: GraphicalStaffEntry): void;
            protected layoutArticulationMarks(articulations: Articulation[], voiceEntry: VoiceEntry, graphicalStaffEntry: GraphicalStaffEntry): void;
            protected layoutOrnament(ornaments: OrnamentContainer, voiceEntry: VoiceEntry, graphicalStaffEntry: GraphicalStaffEntry): void;
            protected calculateRestNotePlacementWithinGraphicalBeam(graphicalStaffEntry: GraphicalStaffEntry, restNote: GraphicalNote, previousNote: GraphicalNote, nextStaffEntry: GraphicalStaffEntry, nextNote: GraphicalNote): void;
            protected calculateTupletNumbers(): void;
            protected calculateSlurs(): void;
            protected calculateGlissandi(): void;
            protected calculateDynamicExpressionsForMultiExpression(multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            /**
                * This method calculates the RelativePosition of a single verbal GraphicalContinuousDynamic.
                * @param graphicalContinuousDynamic Graphical continous dynamic to be calculated
                * @param startPosInStaffline Starting point in staff line
                */
            protected calculateGraphicalVerbalContinuousDynamic(graphicalContinuousDynamic: GraphicalContinuousDynamicExpression, startPosInStaffline: PointF2D): void;
            /**
                * This method calculates the RelativePosition of a single GraphicalContinuousDynamic.
                * @param graphicalContinuousDynamic Graphical continous dynamic to be calculated
                * @param startPosInStaffline Starting point in staff line
                */
            calculateGraphicalContinuousDynamic(graphicalContinuousDynamic: GraphicalContinuousDynamicExpression, startPosInStaffline: PointF2D): void;
            /**
                * This method calculates the RelativePosition of a single GraphicalInstantaneousDynamicExpression.
                * @param graphicalInstantaneousDynamic Dynamic expression to be calculated
                * @param startPosInStaffline Starting point in staff line
                */
            protected calculateGraphicalInstantaneousDynamicExpression(graphicalInstantaneousDynamic: GraphicalInstantaneousDynamicExpression, startPosInStaffline: PointF2D, timestamp: Fraction): void;
            protected calcGraphicalRepetitionEndingsRecursively(repetition: Repetition): void;
            /**
                * Calculate a single GraphicalRepetition.
                * @param start
                * @param end
                * @param numberText
                * @param offset
                * @param leftOpen
                * @param rightOpen
                */
            protected layoutSingleRepetitionEnding(start: GraphicalMeasure, end: GraphicalMeasure, numberText: string, offset: number, leftOpen: boolean, rightOpen: boolean): void;
            protected calculateLabel(staffLine: StaffLine, relative: PointF2D, combinedString: string, style: FontStyles, placement: PlacementEnum, fontHeight: number, textAlignment?: TextAlignmentEnum, yPadding?: number): GraphicalLabel;
            protected calculateTempoExpressionsForMultiTempoExpression(sourceMeasure: SourceMeasure, multiTempoExpression: MultiTempoExpression, measureIndex: number): void;
            protected createMetronomeMark(metronomeExpression: InstantaneousTempoExpression): void;
            protected graphicalMeasureCreatedCalculations(measure: GraphicalMeasure): void;
            protected clearSystemsAndMeasures(): void;
            protected handleVoiceEntry(voiceEntry: VoiceEntry, graphicalStaffEntry: GraphicalStaffEntry, accidentalCalculator: AccidentalCalculator, openLyricWords: LyricWord[], activeClef: ClefInstruction, openTuplets: Tuplet[], openBeams: Beam[], octaveShiftValue: OctaveEnum, staffIndex: number, linkedNotes?: Note[], sourceStaffEntry?: SourceStaffEntry): OctaveEnum;
            protected resetYPositionForLeadSheet(psi: BoundingBox): void;
            protected layoutVoiceEntries(graphicalStaffEntry: GraphicalStaffEntry, staffIndex: number): void;
            protected maxInstrNameLabelLength(): number;
            protected calculateSheetLabelBoundingBoxes(): void;
            protected checkMeasuresForWholeRestNotes(): void;
            protected optimizeRestNotePlacement(graphicalStaffEntry: GraphicalStaffEntry, measure: GraphicalMeasure): void;
            protected getRelativePositionInStaffLineFromTimestamp(timestamp: Fraction, verticalIndex: number, staffLine: StaffLine, multiStaffInstrument: boolean, firstVisibleMeasureRelativeX?: number, useLeftStaffEntryBorder?: boolean): PointF2D;
            protected getRelativeXPositionFromTimestamp(timestamp: Fraction): number;
            protected calculatePageLabels(page: GraphicalMusicPage): void;
            protected createGraphicalTies(): void;
            protected calculateSkyBottomLines(): void;
            /**
                * Re-adjust the x positioning of expressions.
                */
            protected calculateExpressionAlignements(): void;
            calculateFingerings(): void;
            protected dynamicExpressionMap: Map<number, BoundingBox>;
            protected calculateRehearsalMark(measure: SourceMeasure): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/MusicSheetDrawer' {
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { ITextMeasurer } from "opensheetmusicdisplay/MusicalScore/Interfaces/ITextMeasurer";
    import { GraphicalMusicSheet } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { GraphicalLayers } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums";
    import { DrawingParameters } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingParameters";
    import { GraphicalLine } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine";
    import { RectangleF2D } from "opensheetmusicdisplay/Common/DataObjects/RectangleF2D";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { GraphicalRectangle } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalRectangle";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { SelectionStartSymbol } from "opensheetmusicdisplay/MusicalScore/Graphical/SelectionStartSymbol";
    import { SelectionEndSymbol } from "opensheetmusicdisplay/MusicalScore/Graphical/SelectionEndSymbol";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { SystemLine } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLine";
    import { MusicSymbol } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSymbol";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { MusicSymbolDrawingStyle, PhonicScoreModes } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingMode";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { GraphicalInstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalInstantaneousDynamicExpression";
    import { GraphicalContinuousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalContinuousDynamicExpression";
    export class LabelRenderSpecs {
            BitmapWidth: number;
            BitmapHeight: number;
            FontHeightInPixel: number;
            ScreenPosition: PointF2D;
    }
    /**
        * Draw a [[GraphicalMusicSheet]] (through the .drawSheet method)
        *
        * The drawing is implemented with a top-down approach, starting from a music sheet, going through pages, systems, staffs...
        * ... and ending in notes, beams, accidentals and other symbols.
        * It's worth to say, that this class just draws the symbols and graphical elements, using the positions that have been computed before.
        * But in any case, some of these previous positioning algorithms need the sizes of the concrete symbols (NoteHeads, sharps, flats, keys...).
        * Therefore, there are some static functions on the 'Bounding Boxes' section used to compute these symbol boxes at the
        * beginning for the later use in positioning algorithms.
        *
        * This class also includes the resizing and positioning of the symbols due to user interaction like zooming or panning.
        */
    export abstract class MusicSheetDrawer {
            drawingParameters: DrawingParameters;
            splitScreenLineColor: number;
            midiPlaybackAvailable: boolean;
            drawableBoundingBoxElement: string;
            skyLineVisible: boolean;
            bottomLineVisible: boolean;
            protected rules: EngravingRules;
            protected graphicalMusicSheet: GraphicalMusicSheet;
            protected textMeasurer: ITextMeasurer;
            constructor(textMeasurer: ITextMeasurer, drawingParameters: DrawingParameters);
            set Mode(value: PhonicScoreModes);
            drawSheet(graphicalMusicSheet: GraphicalMusicSheet): void;
            drawLineAsHorizontalRectangle(line: GraphicalLine, layer: number): void;
            drawLineAsVerticalRectangle(line: GraphicalLine, layer: number): void;
            drawLineAsHorizontalRectangleWithOffset(line: GraphicalLine, offset: PointF2D, layer: number): void;
            drawLineAsVerticalRectangleWithOffset(line: GraphicalLine, offset: PointF2D, layer: number): void;
            drawRectangle(rect: GraphicalRectangle, layer: number): void;
            abstract calculatePixelDistance(unitDistance: number): number;
            drawLabel(graphicalLabel: GraphicalLabel, layer: number): Node;
            protected calculateLabel(graphicalLabel: GraphicalLabel): LabelRenderSpecs;
            protected abstract applyScreenTransformation(point: PointF2D): PointF2D;
            protected applyScreenTransformations(points: PointF2D[]): PointF2D[];
            protected abstract applyScreenTransformationForRect(rectangle: RectangleF2D): RectangleF2D;
            protected drawSplitScreenLine(): void;
            protected renderRectangle(rectangle: RectangleF2D, layer: number, styleId: number, colorHex?: string, alpha?: number): Node;
            protected drawScrollIndicator(): void;
            protected drawSelectionStartSymbol(symbol: SelectionStartSymbol): void;
            protected drawSelectionEndSymbol(symbol: SelectionEndSymbol): void;
            protected renderLabel(graphicalLabel: GraphicalLabel, layer: GraphicalLayers, specs: LabelRenderSpecs): Node;
            protected renderSystemToScreen(system: MusicSystem, systemBoundingBoxInPixels: RectangleF2D, absBoundingRectWithMargin: RectangleF2D): void;
            protected abstract drawMeasure(measure: GraphicalMeasure): void;
            protected drawSkyLine(staffLine: StaffLine): void;
            protected drawBottomLine(staffLine: StaffLine): void;
            protected drawInstrumentBrace(brace: GraphicalObject, system: MusicSystem): void;
            protected drawGroupBracket(bracket: GraphicalObject, system: MusicSystem): void;
            protected isVisible(psi: BoundingBox): boolean;
            protected drawMusicSystem(system: MusicSystem): void;
            protected getSytemBoundingBoxInPixels(absBoundingRectWithMargin: RectangleF2D): RectangleF2D;
            protected getSystemAbsBoundingRect(system: MusicSystem): RectangleF2D;
            protected drawMusicSystemComponents(musicSystem: MusicSystem, systemBoundingBoxInPixels: RectangleF2D, absBoundingRectWithMargin: RectangleF2D): void;
            protected activateSystemRendering(systemId: number, absBoundingRect: RectangleF2D, systemBoundingBoxInPixels: RectangleF2D, createNewImage: boolean): boolean;
            protected drawSystemLineObject(systemLine: SystemLine): void;
            protected drawStaffLine(staffLine: StaffLine): void;
            protected drawLyricLines(lyricLines: GraphicalLine[], staffLine: StaffLine): void;
            protected drawExpressions(staffline: StaffLine): void;
            protected drawGraphicalLine(graphicalLine: GraphicalLine, lineWidth: number, colorOrStyle?: string): Node;
            protected drawLine(start: PointF2D, stop: PointF2D, color: string, lineWidth: number): Node;
            /**
                * Draw all dashes to the canvas
                * @param lyricsDashes Array of lyric dashes to be drawn
                * @param layer Number of the layer that the lyrics should be drawn in
                */
            protected drawDashes(lyricsDashes: GraphicalLabel[]): void;
            protected drawOctaveShifts(staffLine: StaffLine): void;
            protected abstract drawPedals(staffLine: StaffLine): void;
            protected abstract drawWavyLines(staffLine: StaffLine): void;
            protected drawStaffLines(staffLine: StaffLine): void;
            /**
                * Draws an instantaneous dynamic expression (p, pp, f, ff, ...) to the canvas
                * @param instantaneousDynamic GraphicalInstantaneousDynamicExpression to be drawn
                */
            protected abstract drawInstantaneousDynamic(instantaneousDynamic: GraphicalInstantaneousDynamicExpression): void;
            /**
                * Draws a continuous dynamic expression (wedges) to the canvas
                * @param expression GraphicalContinuousDynamicExpression to be drawn
                */
            protected abstract drawContinuousDynamic(expression: GraphicalContinuousDynamicExpression): void;
            protected drawSymbol(symbol: MusicSymbol, symbolStyle: MusicSymbolDrawingStyle, position: PointF2D, scalingFactor?: number, layer?: number): void;
            protected get leadSheet(): boolean;
            protected set leadSheet(value: boolean);
            protected drawPage(page: GraphicalMusicPage): void;
            drawBoundingBox(bbox: BoundingBox, color?: string, drawCross?: boolean, labelText?: string, layer?: number): Node;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/MusicSymbol' {
    export enum MusicSymbol {
        Unused_first_Symbol = 0,
        BLACK_HEAD = 1,
        UPWARDS_TAIL = 2,
        DOWNWARDS_TAIL = 3,
        UPWARDS_DOUBLE_TAIL = 4,
        DOWNWARDS_DOUBLE_TAIL = 5,
        UPWARDS_TRIPLE_TAIL = 6,
        DOWNWARDS_TRIPLE_TAIL = 7,
        UPWARDS_QUAD_TAIL = 8,
        DOWNWARDS_QUAD_TAIL = 9,
        ROUND_HEAD = 10,
        WHITE_HEAD = 11,
        G_CLEF = 12,
        F_CLEF = 13,
        C_CLEF = 14,
        BREVE = 15,
        BREVE_REST = 16,
        COMMON_TIME = 17,
        CUT_TIME = 18,
        WHOLE_REST = 19,
        HALF_REST = 20,
        QUARTER_REST = 21,
        EIGHTH_REST = 22,
        SIXTEENTH_REST = 23,
        THIRTYSECOND_REST = 24,
        SIXTYFOURTH_REST = 25,
        FLAT = 26,
        SHARP = 27,
        NATURAL = 28,
        DOUBLE_FLAT = 29,
        DOUBLE_SHARP = 30,
        ZERO = 31,
        ONE = 32,
        TWO = 33,
        THREE = 34,
        FOUR = 35,
        FIVE = 36,
        SIX = 37,
        SEVEN = 38,
        EIGHT = 39,
        NINE = 40,
        DOT = 41,
        FERMATA = 42,
        INVERTED_FERMATA = 43,
        SPICCATO = 44,
        TENUTO = 45,
        MARCATO = 46,
        MARCATISSIMO = 47,
        INVERTED_MARCATISSIMO = 48,
        P = 49,
        F = 50,
        S = 51,
        Z = 52,
        M = 53,
        R = 54,
        SEGNO = 55,
        CODA = 56,
        DRUM_CLEF = 57,
        G_CLEF_SUB8 = 58,
        G_CLEF_SUPER8 = 59,
        G_CLEF_SUB15 = 60,
        G_CLEF_SUPER15 = 61,
        F_CLEF_SUB8 = 62,
        F_CLEF_SUPER8 = 63,
        F_CLEF_SUB15 = 64,
        F_CLEF_SUPER15 = 65,
        DOWN_BOW = 66,
        MORDENT = 67,
        INVERTED_MORDENT = 68,
        TURN = 69,
        INVERTED_TURN = 70,
        LEFTHAND_PIZZICATO = 71,
        RELEASE_PED = 72,
        ENGAGE_PED = 73,
        VA8 = 74,
        VB8 = 75,
        TRILL = 76,
        MA15 = 77,
        MB15 = 78,
        HIGH = 79,
        PLAY = 80,
        MIC = 81,
        SNAP_PIZZICATO = 82,
        NATURAL_HARMONIC = 83,
        EditPen = 84,
        PEDAL_BRACKET = 85,
        PEDAL_MIXED = 86,
        PEDAL_SYMBOL = 87
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/MusicSystemBuilder' {
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { GraphicalMusicPage } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicPage";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { RhythmInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RhythmInstruction";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { SystemLinesEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    import { GraphicalMusicSheet } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMusicSheet";
    export class MusicSystemBuilder {
            protected measureList: GraphicalMeasure[][];
            protected graphicalMusicSheet: GraphicalMusicSheet;
            protected currentSystemParams: SystemBuildParameters;
            protected numberOfVisibleStaffLines: number;
            protected rules: EngravingRules;
            protected measureListIndex: number;
            protected musicSystems: MusicSystem[];
            /**
                * Does the mapping from the currently visible staves to the global staff-list of the music sheet.
                */
            protected visibleStaffIndices: number[];
            protected activeRhythm: RhythmInstruction[];
            protected activeKeys: KeyInstruction[];
            protected activeClefs: ClefInstruction[];
            protected globalSystemIndex: number;
            protected leadSheet: boolean;
            initialize(graphicalMusicSheet: GraphicalMusicSheet, measureList: GraphicalMeasure[][], numberOfStaffLines: number): void;
            buildMusicSystems(): MusicSystem[];
            /**
                * calculates the y positions of the staff lines within a system and
                * furthermore the y positions of the systems themselves.
                */
            calculateSystemYLayout(): void;
            /**
                * Set the Width of the staff-Measures of one source measure.
                * @param graphicalMeasures
                * @param width
                * @param beginInstrWidth
                * @param endInstrWidth
                */
            protected setMeasureWidth(graphicalMeasures: GraphicalMeasure[], width: number, beginInstrWidth: number, endInstrWidth: number): void;
            /**
                * When the actual source measure doesn't fit any more, this method finalizes the current system and
                * opens up a new empty system, where the actual measure will be added in the next iteration.
                * @param measures
                * @param isPartEndingSystem
                */
            protected finalizeCurrentAndCreateNewSystem(measures: GraphicalMeasure[], systemEndsPart?: boolean, checkExtraInstructionMeasure?: boolean, startNewPage?: boolean): void;
            protected finalizeCurrentSystem(measures: GraphicalMeasure[], systemEndsPart?: boolean, checkExtraInstructionMeasure?: boolean, startNewPage?: boolean): void;
            /**
                * If a line repetition is ending and a new line repetition is starting at the end of the system,
                * the double repetition line has to be split into two: one at the currently ending system and
                * one at the next system.
                * (this should be refactored at some point to not use a combined end/start line but always separated lines)
                */
            protected adaptRepetitionLineWithIfNeeded(): void;
            protected addMeasureToSystem(graphicalMeasures: GraphicalMeasure[], measureStartLine: SystemLinesEnum, measureEndLine: SystemLinesEnum, totalMeasureWidth: number, currentMeasureBeginInstructionsWidth: number, currentVarWidth: number, currentMeasureEndInstructionsWidth: number): void;
            /**
                * Initialize a new [[MusicSystem]].
                * @returns {MusicSystem}
                */
            protected initMusicSystem(): MusicSystem;
            /**
                * Get the width the system should have for a given page width.
                * @returns {number}
                */
            protected getFullPageSystemWidth(): number;
            protected layoutSystemStaves(musicSystem: MusicSystem): void;
            /**
                * Calculate the [[StaffLine]](s) needed for a [[MusicSystem]].
                * @param musicSystem
                * @param relativeYPosition
                * @param staff
                */
            protected addStaffLineToMusicSystem(musicSystem: MusicSystem, relativeYPosition: number, staff: Staff): void;
            /**
                * Initialize the active Instructions from the first [[SourceMeasure]] of first [[SourceMusicPart]].
                * @param measureList
                */
            protected initializeActiveInstructions(measureList: GraphicalMeasure[]): void;
            protected transposeKeyInstruction(keyInstruction: KeyInstruction, graphicalMeasure: GraphicalMeasure): KeyInstruction;
            /**
                * Calculate the width needed for Instructions (Key, Clef, Rhythm, Repetition) for the measure.
                * @param measures
                * @param isSystemFirstMeasure
                * @param isFirstSourceMeasure
                * @returns {number}
                */
            protected addBeginInstructions(measures: GraphicalMeasure[], isSystemFirstMeasure: boolean, isFirstSourceMeasure: boolean): number;
            /**
                * Calculates the width needed for Instructions (Clef, Repetition) for the measure.
                * @param measures
                * @returns {number}
                */
            protected addEndInstructions(measures: GraphicalMeasure[]): number;
            protected AddInstructionsAtMeasureBegin(firstEntry: SourceStaffEntry, measure: GraphicalMeasure, visibleStaffIdx: number, isFirstSourceMeasure: boolean, isSystemStartMeasure: boolean): number;
            protected addInstructionsAtMeasureEnd(lastEntry: SourceStaffEntry, measure: GraphicalMeasure, measures: GraphicalMeasure[]): number;
            /**
                * Track down and update the active ClefInstruction in Measure's StaffEntries.
                * This has to be done after the measure is added to a system
                * (otherwise already the check if the measure fits to the system would update the active clefs..)
                * @param measure
                * @param graphicalMeasures
                */
            protected updateActiveClefs(measure: SourceMeasure, graphicalMeasures: GraphicalMeasure[]): void;
            /**
                * Check if an extra Instruction [[Measure]] is needed.
                * @param measures
                */
            protected checkAndCreateExtraInstructionMeasure(measures: GraphicalMeasure[]): void;
            protected addExtraInstructionMeasure(visStaffIdx: number, keyInstruction: KeyInstruction, rhythmInstruction: RhythmInstruction): number;
            /**
                * Add all current vertical Measures to currentSystem.
                * @param graphicalMeasures
                */
            protected addStaveMeasuresToSystem(graphicalMeasures: GraphicalMeasure[]): void;
            /**
                * Return the width of the corresponding [[SystemLine]] and set the corresponding [[SystemLineEnum]].
                * @returns {SystemLinesEnum}
                */
            protected getMeasureStartLine(): SystemLinesEnum;
            protected getMeasureEndLine(): SystemLinesEnum;
            /**
                * Return the width of the corresponding [[SystemLine]] and sets the corresponding [[SystemLineEnum]].
                * @param measure
                * @param systemLineEnum
                * @param isSystemStartMeasure
                * @returns {number}
                */
            protected getLineWidth(measure: GraphicalMeasure, systemLineEnum: SystemLinesEnum, isSystemStartMeasure: boolean): number;
            protected previousMeasureEndsLineRepetition(): boolean;
            /**
                * Check if at this [[Measure]] starts a [[Repetition]].
                * @returns {boolean}
                */
            protected thisMeasureBeginsLineRepetition(): boolean;
            /**
                * Check if a [[Repetition]] starts at the next [[Measure]].
                * @returns {boolean}
                */
            protected nextMeasureBeginsLineRepetition(): boolean;
            /**
                * Check if this [[Measure]] is a [[Repetition]] ending.
                * @returns {boolean}
                */
            protected thisMeasureEndsLineRepetition(): boolean;
            /**
                * Check if a [[Repetition]] starts at the next [[Measure]].
                * @returns {boolean}
                */
            protected nextMeasureBeginsWordRepetition(): boolean;
            /**
                * Check if this [[Measure]] is a [[Repetition]] ending.
                * @returns {boolean}
                */
            protected thisMeasureEndsWordRepetition(): boolean;
            /**
                * Check if the next [[Measure]] has a [[KeyInstruction]] change.
                * @returns {boolean}
                */
            protected nextMeasureHasKeyInstructionChange(): boolean;
            protected getNextMeasureKeyInstruction(): KeyInstruction;
            /**
                * Calculate the X ScalingFactor in order to strech the whole System.
                * @param systemFixWidth
                * @param systemVarWidth
                * @returns {number}
                */
            protected calculateXScalingFactor(systemFixWidth: number, systemVarWidth: number): number;
            /**
                * Stretch the whole System so that no white space is left at the end.
                * @param systemEndsPart
                */
            protected stretchMusicSystem(systemEndsPart: boolean): void;
            /**
                * If the last [[MusicSystem]] doesn't need stretching, then this method decreases the System's Width,
                * the [[StaffLine]]'s Width and the 5 [[StaffLine]]s length.
                */
            protected decreaseMusicSystemBorders(): void;
            /**
                * This method updates the System's StaffLine's RelativePosition (starting from the given index).
                * @param musicSystem
                * @param index
                * @param value
                */
            protected updateStaffLinesRelativePosition(musicSystem: MusicSystem, index: number, value: number): void;
            /**
                * Create a new [[GraphicalMusicPage]]
                * (for now only one long page is used per music sheet, as we scroll down and have no page flips)
                * @returns {GraphicalMusicPage}
                */
            protected createMusicPage(): GraphicalMusicPage;
            protected addSystemToPage(page: GraphicalMusicPage, system: MusicSystem): void;
            /**
                * This method checks the distances between any two consecutive StaffLines of a System and if needed, shifts the lower one down.
                * @param musicSystem
                */
            protected optimizeDistanceBetweenStaffLines(musicSystem: MusicSystem): void;
            /** Calculates the relative Positions of all MusicSystems.
                *
                */
            protected calculateMusicSystemsRelativePositions(): void;
    }
    export class SystemBuildParameters {
            currentSystem: MusicSystem;
            systemMeasures: MeasureBuildParameters[];
            systemMeasureIndex: number;
            currentWidth: number;
            currentSystemFixWidth: number;
            currentSystemVarWidth: number;
            maxLabelLength: number;
            IsSystemStartMeasure(): boolean;
    }
    export class MeasureBuildParameters {
            beginLine: SystemLinesEnum;
            endLine: SystemLinesEnum;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/OctaveShiftParams' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { OctaveShift } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    export class OctaveShiftParams {
        constructor(openOctaveShift: OctaveShift, absoluteStartTimestamp: Fraction, absoluteEndTimestamp: Fraction);
        getOpenOctaveShift: OctaveShift;
        getAbsoluteStartTimestamp: Fraction;
        getAbsoluteEndTimestamp: Fraction;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/SelectionEndSymbol' {
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { GraphicalLine } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine";
    export class SelectionEndSymbol extends GraphicalObject {
        constructor(system: MusicSystem, xPosition: number);
        verticalLine: GraphicalLine;
        arrows: PointF2D[][];
        arrowlines: PointF2D[][];
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/SelectionStartSymbol' {
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { GraphicalLine } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    export class SelectionStartSymbol extends GraphicalObject {
        constructor(system: MusicSystem, xPosition: number);
        verticalLine: GraphicalLine;
        arrows: PointF2D[][];
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/SkyBottomLineCalculator' {
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { SkyBottomLineCalculationResult } from "opensheetmusicdisplay/MusicalScore/Graphical/SkyBottomLineCalculationResult";
    /**
        * This class calculates and holds the skyline and bottom line information.
        * It also has functions to update areas of the two lines if new elements are
        * added to the staffline (e.g. measure number, annotations, ...)
        */
    export class SkyBottomLineCalculator {
            /** Parent Staffline where the skyline and bottom line is attached */
            protected mStaffLineParent: StaffLine;
            /** Internal array for the skyline */
            protected mSkyLine: number[];
            /** Internal array for the bottomline */
            protected mBottomLine: number[];
            /** Engraving rules for formatting */
            protected mRules: EngravingRules;
            /**
                * Create a new object of the calculator
                * @param staffLineParent staffline where the calculator should be attached
                */
            constructor(staffLineParent: StaffLine);
            /**
                * This method updates the skylines and bottomlines for mStaffLineParent.
                * @param calculationResults the skylines and bottomlines of mStaffLineParent's measures calculated by SkyBottomLineBatchCalculator
                */
            updateLines(calculationResults: SkyBottomLineCalculationResult[]): void;
            /**
                * This method calculates the Sky- and BottomLines for a StaffLine.
                */
            calculateLines(): void;
            updateSkyLineWithLine(start: PointF2D, end: PointF2D, value: number): void;
            /**
                * This method updates the SkyLine for a given Wedge.
                * @param start Start point of the wedge (the point where both lines meet)
                * @param end End point of the wedge (the end of the most extreme line: upper line for skyline, lower line for bottomline)
                */
            updateSkyLineWithWedge(start: PointF2D, end: PointF2D): void;
            /**
                * This method updates the BottomLine for a given Wedge.
                * @param start Start point of the wedge
                * @param end End point of the wedge
                */
            updateBottomLineWithWedge(start: PointF2D, end: PointF2D): void;
            /**
                * This method updates the SkyLine for a given range with a given value
                * //param  to update the SkyLine for
                * @param startIndex Start index of the range
                * @param endIndex End index of the range
                * @param value ??
                */
            updateSkyLineInRange(startIndex: number, endIndex: number, value: number): void;
            /**
                * This method updates the BottomLine for a given range with a given value
                * @param startIndex Start index of the range
                * @param endIndex End index of the range (excluding)
                * @param value ??
                */
            updateBottomLineInRange(startIndex: number, endIndex: number, value: number): void;
            /**
                * Resets a SkyLine in a range to its original value
                * @param startIndex Start index of the range
                * @param endIndex End index of the range (excluding)
                */
            resetSkyLineInRange(startIndex: number, endIndex: number): void;
            /**
                * Resets a bottom line in a range to its original value
                * @param startIndex Start index of the range
                * @param endIndex End index of the range
                */
            resetBottomLineInRange(startIndex: number, endIndex: number): void;
            /**
                * Update the whole skyline with a certain value
                * @param value value to be set
                */
            setSkyLineWithValue(value: number): void;
            /**
                * Update the whole bottomline with a certain value
                * @param value value to be set
                */
            setBottomLineWithValue(value: number): void;
            getLeftIndexForPointX(x: number, length: number): number;
            getRightIndexForPointX(x: number, length: number): number;
            /**
                * This method updates the StaffLine Borders with the Sky- and BottomLines Min- and MaxValues.
                */
            updateStaffLineBorders(): void;
            /**
                * This method finds the minimum value of the SkyLine.
                */
            getSkyLineMin(): number;
            getSkyLineMinAtPoint(point: number): number;
            /**
                * This method finds the SkyLine's minimum value within a given range.
                * @param startIndex Starting index
                * @param endIndex End index (including)
                */
            getSkyLineMinInRange(startIndex: number, endIndex: number): number;
            /**
                * This method finds the maximum value of the BottomLine.
                */
            getBottomLineMax(): number;
            getBottomLineMaxAtPoint(point: number): number;
            /**
                * This method finds the BottomLine's maximum value within a given range.
                * @param startIndex Start index of the range
                * @param endIndex End index of the range (excluding)
                */
            getBottomLineMaxInRange(startIndex: number, endIndex: number): number;
            /**
                * This method returns the maximum value of the bottom line around a specific
                * bounding box. Will return undefined if the bounding box is not valid or inside staffline
                * @param boundingBox Bounding box where the maximum should be retrieved from
                * @returns Maximum value inside bounding box boundaries or undefined if not possible
                */
            getBottomLineMaxInBoundingBox(boundingBox: BoundingBox): number;
            /**
                * Updates sky- and bottom line with a boundingBox and its children
                * @param boundingBox Bounding box to be added
                */
            updateWithBoundingBoxRecursively(boundingBox: BoundingBox): void;
            /** Sampling units that are used to quantize the sky and bottom line  */
            get SamplingUnit(): number;
            /** Parent staffline where the skybottomline calculator is attached to */
            get StaffLineParent(): StaffLine;
            /** Get the plain skyline array */
            get SkyLine(): number[];
            /** Get the plain bottomline array */
            get BottomLine(): number[];
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/StaffLine' {
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { GraphicalLine } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLine";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { GraphicalLabel } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalLabel";
    import { SkyBottomLineCalculator } from "opensheetmusicdisplay/MusicalScore/Graphical/SkyBottomLineCalculator";
    import { GraphicalOctaveShift } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalOctaveShift";
    import { GraphicalSlur } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalSlur";
    import { AbstractGraphicalExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/AbstractGraphicalExpression";
    import { GraphicalPedal } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalPedal";
    import { GraphicalGlissando } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalGlissando";
    import { GraphicalWavyLine } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalWavyLine";
    /**
        * A StaffLine contains the [[Measure]]s in one line of the music sheet
        * (one instrument, one line, until a line break)
        */
    export abstract class StaffLine extends GraphicalObject {
            protected measures: GraphicalMeasure[];
            protected staffLines: GraphicalLine[];
            protected parentMusicSystem: MusicSystem;
            protected parentStaff: Staff;
            protected octaveShifts: GraphicalOctaveShift[];
            protected skyBottomLine: SkyBottomLineCalculator;
            protected lyricLines: GraphicalLine[];
            protected lyricsDashes: GraphicalLabel[];
            protected abstractExpressions: AbstractGraphicalExpression[];
            protected graphicalSlurs: GraphicalSlur[];
            protected graphicalGlissandi: GraphicalGlissando[];
            constructor(parentSystem: MusicSystem, parentStaff: Staff);
            get Measures(): GraphicalMeasure[];
            set Measures(value: GraphicalMeasure[]);
            get StaffLines(): GraphicalLine[];
            set StaffLines(value: GraphicalLine[]);
            get Index(): number;
            get NextStaffLine(): StaffLine;
            get LyricLines(): GraphicalLine[];
            get AbstractExpressions(): AbstractGraphicalExpression[];
            set AbstractExpressions(value: AbstractGraphicalExpression[]);
            set LyricLines(value: GraphicalLine[]);
            get LyricsDashes(): GraphicalLabel[];
            set LyricsDashes(value: GraphicalLabel[]);
            get ParentMusicSystem(): MusicSystem;
            set ParentMusicSystem(value: MusicSystem);
            get ParentStaff(): Staff;
            set ParentStaff(value: Staff);
            get SkyBottomLineCalculator(): SkyBottomLineCalculator;
            get SkyLine(): number[];
            get BottomLine(): number[];
            get OctaveShifts(): GraphicalOctaveShift[];
            set OctaveShifts(value: GraphicalOctaveShift[]);
            Pedals: GraphicalPedal[];
            WavyLines: GraphicalWavyLine[];
            get StaffHeight(): number;
            get TopLineOffset(): number;
            get BottomLineOffset(): number;
            get GraphicalSlurs(): GraphicalSlur[];
            get GraphicalGlissandi(): GraphicalGlissando[];
            /**
                * Add a given Graphical Slur to the staffline
                * @param gSlur
                */
            addSlurToStaffline(gSlur: GraphicalSlur): void;
            addGlissandoToStaffline(gGlissando: GraphicalGlissando): void;
            addActivitySymbolClickArea(): void;
            /**
                * True iff [[StaffLine]] belongs to an [[Instrument]] with more than one [[Staff]].
                * @returns {boolean}
                */
            isPartOfMultiStaffInstrument(): boolean;
            /**
                * Find the [[GraphicalStaffEntry]] closest to the given xPosition.
                * @param xPosition
                * @returns {GraphicalStaffEntry}
                */
            findClosestStaffEntry(xPosition: number): GraphicalStaffEntry;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/StaffLineActivitySymbol' {
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    export class StaffLineActivitySymbol extends GraphicalObject {
        constructor(staffLine: StaffLine);
        parentStaffLine: StaffLine;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/SystemLine' {
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { SystemLinePosition } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinePosition";
    import { SystemLinesEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class SystemLine extends GraphicalObject {
        constructor(lineType: SystemLinesEnum, linePosition: SystemLinePosition, musicSystem: MusicSystem, topMeasure: GraphicalMeasure, bottomMeasure?: GraphicalMeasure);
        lineType: SystemLinesEnum;
        linePosition: SystemLinePosition;
        parentMusicSystem: MusicSystem;
        parentTopStaffLine: StaffLine;
        topMeasure: GraphicalMeasure;
        bottomMeasure: GraphicalMeasure;
        /**
          * Return the width of the SystemLinesContainer for the given SystemLineType.
          * @param rules
          * @param systemLineType
          * @returns {number}
          */
        static getObjectWidthForLineType(rules: EngravingRules, systemLineType: SystemLinesEnum): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/SystemLinePosition' {
    export enum SystemLinePosition {
        MeasureBegin = 0,
        MeasureEnd = 1
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum' {
    export enum SystemLinesEnum {
        SingleThin = 0,
        DoubleThin = 1,
        ThinBold = 2,
        BoldThinDots = 3,
        DotsThinBold = 4,
        DotsBoldBoldDots = 5,
        None = 6,
        Dotted = 7,
        Dashed = 8,
        Bold = 9,
        BoldThin = 10,
        DoubleBold = 11,
        Tick = 12,
        Short = 13
    }
    export class SystemLinesEnumHelper {
        static xmlBarlineStyleToSystemLinesEnum(xmlValue: string): SystemLinesEnum;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VerticalGraphicalStaffEntryContainer' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    export class VerticalGraphicalStaffEntryContainer {
        constructor(numberOfEntries: number, absoluteTimestamp: Fraction);
        get Index(): number;
        set Index(value: number);
        get AbsoluteTimestamp(): Fraction;
        get StaffEntries(): GraphicalStaffEntry[];
        set StaffEntries(value: GraphicalStaffEntry[]);
        static compareByTimestamp(x: VerticalGraphicalStaffEntryContainer, y: VerticalGraphicalStaffEntryContainer): number;
        /**
          * Return the first non-null [[GraphicalStaffEntry]].
          * @returns {any}
          */
        getFirstNonNullStaffEntry(): GraphicalStaffEntry;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow' {
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/AlignmentManager";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/CanvasVexFlowBackend";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/SvgVexFlowBackend";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowBackend";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowContinuousDynamicExpression";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowConverter";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowGlissando";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowGraphicalNote";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowGraphicalSymbolFactory";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowInstantaneousDynamicExpression";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowInstrumentBrace";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowInstrumentBracket";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMeasure";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMultiRestMeasure";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMusicSheetCalculator";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMusicSheetDrawer";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMusicSystem";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowOctaveShift";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowSlur";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowStaffEntry";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowStaffLine";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexflowStafflineNoteCalculator";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowTabMeasure";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowTextMeasurer";
    export * from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowVoiceEntry";
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/IAfterSheetReadingModule' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    /**
      * Created by Matthias on 22.02.2017.
      */
    export interface IAfterSheetReadingModule {
        calculate(musicSheet: MusicSheet): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/IGraphicalSymbolFactory' {
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { OctaveEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { TechnicalInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/TechnicalInstruction";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { SkyBottomLineCalculator } from "opensheetmusicdisplay/MusicalScore/Graphical/SkyBottomLineCalculator";
    export interface IGraphicalSymbolFactory {
        createMusicSystem(systemIndex: number, rules: EngravingRules): MusicSystem;
        createStaffLine(parentSystem: MusicSystem, parentStaff: Staff): StaffLine;
        createSkyBottomLineCalculator(parentStaffline: StaffLine): SkyBottomLineCalculator;
        createGraphicalMeasure(sourceMeasure: SourceMeasure, staff: Staff): GraphicalMeasure;
        createMultiRestMeasure(sourceMeasure: SourceMeasure, staff: Staff): GraphicalMeasure;
        createTabStaffMeasure(sourceMeasure: SourceMeasure, staff: Staff): GraphicalMeasure;
        createExtraGraphicalMeasure(staffLine: StaffLine): GraphicalMeasure;
        createStaffEntry(sourceStaffEntry: SourceStaffEntry, measure: GraphicalMeasure): GraphicalStaffEntry;
        createVoiceEntry(parentVoiceEntry: VoiceEntry, parentStaffEntry: GraphicalStaffEntry): GraphicalVoiceEntry;
        createNote(note: Note, graphicalVoiceEntry: GraphicalVoiceEntry, activeClef: ClefInstruction, octaveShift: OctaveEnum, rules: EngravingRules, graphicalNoteLength?: Fraction): GraphicalNote;
        createGraceNote(note: Note, graphicalVoiceEntry: GraphicalVoiceEntry, activeClef: ClefInstruction, rules: EngravingRules, octaveShift?: OctaveEnum): GraphicalNote;
        addGraphicalAccidental(graphicalNote: GraphicalNote, pitch: Pitch): void;
        addFermataAtTiedEndNote(tiedNote: Note, graphicalStaffEntry: GraphicalStaffEntry): void;
        createGraphicalTechnicalInstruction(technicalInstruction: TechnicalInstruction, graphicalStaffEntry: GraphicalStaffEntry): void;
        createInStaffClef(graphicalStaffEntry: GraphicalStaffEntry, clefInstruction: ClefInstruction): void;
        createChordSymbols(sourceStaffEntry: SourceStaffEntry, graphicalStaffEntry: GraphicalStaffEntry, keyInstruction: KeyInstruction, transposeHalftones: number): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/IQualityFeedbackTone' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    export interface IQualityFeedbackTone {
        ParentNote: Note;
        TimingScore: number;
        PitchScore: number;
        getOverallQualityFeedbackScore(): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/ITextMeasurer' {
    import { Fonts } from "opensheetmusicdisplay/Common/Enums/Fonts";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    export interface ITextMeasurer {
        fontSize: number;
        fontSizeStandard: number;
        computeTextWidthToHeightRatio(text: string, font: Fonts, style: FontStyles, fontFamily?: string, fontSize?: number): number;
        setFontSize(fontSize: number): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/ITextTranslation' {
    export class ITextTranslation {
        static defaultTextTranslation: ITextTranslation;
        static translateText(tag: string, text: string): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/AUIController' {
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects";
    export abstract class AUIController<T> {
        protected parentElement: HTMLElement;
        protected insertLocation: InsertPosition;
        protected isTouchDevice: boolean;
        protected eventListeners: T[];
        protected abstract initialize(): void;
        abstract show(location?: PointF2D): void;
        abstract hideAndClear(): void;
        constructor(parentElement?: HTMLElement, isTouchDevice?: boolean, where?: InsertPosition);
        addListener(listener: T): void;
        protected generateHtmlTemplate(rawHtml: string, data?: Object): string;
        protected generateAndInsertHtmlTemplate(rawHtml: string, data?: Object, where?: InsertPosition, parent?: HTMLElement): void;
        protected get downEventName(): string;
        protected get upEventName(): string;
        protected get moveEventName(): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/IVoiceMeasureReadPlugin' {
    import { VoiceEntry, RhythmInstruction, KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData";
    export interface IVoiceMeasureReadPlugin {
        measureReadCalculations(measureVoiceEntries: VoiceEntry[], activeKey: KeyInstruction, activeRhythm: RhythmInstruction): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Interfaces/IStafflineNoteCalculator' {
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    export interface IStafflineNoteCalculator {
        trackNote(graphicalNote: GraphicalNote): void;
        positionNote(graphicalNote: GraphicalNote): GraphicalNote;
        getStafflineUniquePositionCount(staffIndex: number): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Playback/PlaybackNoteGenerator' {
    import { IAfterSheetReadingModule } from "opensheetmusicdisplay/MusicalScore/Interfaces";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    export class PlaybackNoteGenerator implements IAfterSheetReadingModule {
        calculate(musicSheet: MusicSheet): void;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/Matrix2D' {
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    export class Matrix2D {
        constructor();
        static getRotationMatrix(angle: number): Matrix2D;
        scalarMultiplication(scalar: number): void;
        getTransposeMatrix(): Matrix2D;
        vectorMultiplication(point: PointF2D): PointF2D;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/Pitch' {
    export enum NoteEnum {
            C = 0,
            D = 2,
            E = 4,
            F = 5,
            G = 7,
            A = 9,
            B = 11
    }
    /** Describes Accidental types.
        * Do not use the number values of these enum members directly for calculation anymore.
        * To use these for pitch calculation, use pitch.AccidentalHalfTones()
        * or Pitch.HalfTonesFromAccidental(accidentalEnum).
        */
    export enum AccidentalEnum {
            SHARP = 0,
            FLAT = 1,
            NONE = 2,
            NATURAL = 3,
            DOUBLESHARP = 4,
            DOUBLEFLAT = 5,
            TRIPLESHARP = 6,
            TRIPLEFLAT = 7,
            QUARTERTONESHARP = 8,
            QUARTERTONEFLAT = 9,
            SLASHFLAT = 10,
            THREEQUARTERSSHARP = 11,
            THREEQUARTERSFLAT = 12,
            SLASHQUARTERSHARP = 13,
            SLASHSHARP = 14,
            DOUBLESLASHFLAT = 15,
            SORI = 16,
            KORON = 17
    }
    export class Pitch {
            static pitchEnumValues: NoteEnum[];
            static getNoteEnumString(note: NoteEnum): string;
            /** Changes a note x lines/steps up (+) or down (-) from a NoteEnum on a staffline/keyboard (white keys).
                * E.g. Two lines down (-2) from a D is a B.
                * Two lines up from an A is a C.
                *   (e.g. in the treble/violin clef, going one line up: E -> F (semitone), F -> G (2 semitones)).
                * Returns new NoteEnum and the octave shift (e.g. -1 = new octave is one octave down). */
            static lineShiftFromNoteEnum(noteEnum: NoteEnum, lines: number): [NoteEnum, number];
            /**
                * @param the input pitch
                * @param the number of halftones to transpose with
                * @returns ret[0] = the transposed fundamental.
                * ret[1] = the octave shift (not the new octave!)
                * @constructor
                */
            static CalculateTransposedHalfTone(pitch: Pitch, transpose: number): {
                    halftone: number;
                    overflow: number;
            };
            /** Returns the fundamental note x (0 <= x <= 11, e.g. 0 = C) with octave change/overflow.
                * The halftone will be one of the values in the enum NoteEnum, converted to number here as we need numbers for calculation.
                */
            static WrapAroundCheck(value: number, limit: number): {
                    halftone: number;
                    overflow: number;
            };
            static calcFrequency(obj: Pitch | number): number;
            static calcFractionalKey(frequency: number): number;
            static fromFrequency(frequency: number): Pitch;
            static fromHalftone(halftone: number): Pitch;
            static ceiling(halftone: number): NoteEnum;
            static floor(halftone: number): NoteEnum;
            constructor(fundamentalNote: NoteEnum, octave: number, accidental: AccidentalEnum, accidentalXml?: string, isRest?: boolean);
            /** Turns an AccidentalEnum into half tone steps for pitch calculation.
                *
                */
            static HalfTonesFromAccidental(accidental: AccidentalEnum): number;
            static AccidentalFromHalfTones(halfTones: number): AccidentalEnum;
            /**
                * Converts AccidentalEnum to a string which represents an accidental in VexFlow
                * Can also be useful in other cases, but has to match Vexflow accidental codes.
                * @param accidental
                * @returns {string} Vexflow Accidental code
                */
            static accidentalVexflow(accidental: AccidentalEnum): string;
            get AccidentalHalfTones(): number;
            get Octave(): number;
            get FundamentalNote(): NoteEnum;
            get Accidental(): AccidentalEnum;
            get AccidentalXml(): string;
            get Frequency(): number;
            static get OctaveXmlDifference(): number;
            getHalfTone(): number;
            getTransposedPitch(factor: number): Pitch;
            DoEnharmonicChange(): void;
            ToString(): string;
            /** A short representation of the note like A4 (A, octave 4), Ab5 or C#4. */
            ToStringShort(octaveOffset?: number): string;
            /** A shortcut getter for ToStringShort that can be useful for debugging. */
            get ToStringShortGet(): string;
            OperatorEquals(p2: Pitch): boolean;
            OperatorNotEqual(p2: Pitch): boolean;
            OperatorFundamentalGreaterThan(p2: Pitch): boolean;
            OperatorFundamentalLessThan(p2: Pitch): boolean;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/PointF2D' {
    export class PointF2D {
        x: number;
        y: number;
        constructor(x?: number, y?: number);
        static get Empty(): PointF2D;
        static pointsAreEqual(p1: PointF2D, p2: PointF2D): boolean;
        ToString(): string;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/RectangleF2D' {
    import { SizeF2D } from "opensheetmusicdisplay/Common/DataObjects/SizeF2D";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    /**
        * Represent a rectangle on a plane
        */
    export class RectangleF2D {
            x: number;
            y: number;
            width: number;
            height: number;
            /**
                *
                * @param x
                * @param y
                * @param width
                * @param height
                */
            constructor(x: number, y: number, width: number, height: number);
            static createFromLocationAndSize(location: PointF2D, size: SizeF2D): RectangleF2D;
            get Location(): PointF2D;
            get Size(): SizeF2D;
    }
}

declare module 'opensheetmusicdisplay/Common/DataObjects/SizeF2D' {
    /**
      * Represent the size of a 2D object, with (width, height)
      */
    export class SizeF2D {
        width: number;
        height: number;
        constructor(width?: number, height?: number);
    }
}

declare module 'opensheetmusicdisplay/Common/Enums/TieTypes' {
    /**
      * The types of ties available
      */
    export enum TieTypes {
        "SIMPLE" = "",
        "HAMMERON" = "H",
        "PULLOFF" = "P",
        "SLIDE" = "S",
        "TAPPING" = "T"
    }
}

declare module 'opensheetmusicdisplay/Common/Enums/PsEnums' {
    export enum PlaybackState {
        Stopped = 0,
        Running = 1
    }
    export enum MessageBoxType {
        Info = 0,
        Warning = 1,
        Error = 2
    }
}

declare module 'opensheetmusicdisplay/Common/FileIO/Mxl' {
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    /**
        * Some helper methods to handle MXL files.
        */
    export class MXLHelper {
            /**
                *
                * @param data
                * @returns {Promise<IXmlElement>}
                * @constructor
                */
            static MXLtoIXmlElement(data: string): Promise<IXmlElement>;
            static MXLtoXMLstring(data: string): Promise<string>;
    }
}

declare module 'opensheetmusicdisplay/Common/FileIO/Xml' {
    /**
        * IXmlAttribute is just the standard Attr
        */
    export type IXmlAttribute = Attr;
    /**
        * Just a wrapper for an XML Element object.
        * It facilitates handling of XML elements by OSMD
        */
    export class IXmlElement {
            name: string;
            value: string;
            hasAttributes: boolean;
            firstAttribute: IXmlAttribute;
            hasElements: boolean;
            /**
                * Wraps 'elem' Element in a IXmlElement
                * @param elem
                */
            constructor(elem: Element);
            /**
                * Get the attribute with the given name
                * @param attributeName
                * @returns {Attr}
                */
            attribute(attributeName: string): IXmlAttribute;
            /**
                * Get all attributes
                * @returns {IXmlAttribute[]}
                */
            attributes(): IXmlAttribute[];
            /**
                * Get the first child element with the given node name
                * @param elementName
                * @returns {IXmlElement}
                */
            element(elementName: string): IXmlElement;
            /**
                * Get the children with the given node name (if given, otherwise all child elements)
                * @param nodeName
                * @returns {IXmlElement[]}
                */
            elements(nodeName?: string): IXmlElement[];
            /**
                * Get the first child element with the given node name
                * with all the children of consequent child elements with the same node name.
                * for example two <notations> tags will be combined for better processing
                * @param elementName
                * @returns {IXmlElement}
                */
            combinedElement(elementName: string): IXmlElement;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/AClassHierarchyTrackable' {
    export abstract class AClassHierarchyTrackable {
        isInstanceOfClass(className: string): boolean;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IAudioMetronomePlayer' {
    export interface IAudioMetronomePlayer {
            /**
                * Play the sound for the first beat within the measure
                * @param volume relative volume ranging from 0.0 - 1.0
                */
            playFirstBeatSample(volume: number): void;
            /**
                * Play the sound for all but the first beat within the measure
                * @param volume relative volume ranging from 0.0 - 1.0
                */
            playBeatSample(volume: number): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IAudioPlayer' {
    import { MidiInstrument } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    export interface IAudioPlayer<TSoundFont> {
        ac: AudioContext;
        open(uniqueInstruments: number[], numberOfinstruments: number): void;
        close(): void;
        tuningChanged(tuningInHz: number): void;
        playSound(instrumentChannel: number, key: number, volume: number, lengthInMs: number): void;
        stopSound(instrumentChannel: number, volume: number): void;
        setSound(instrumentChannel: number, soundId: MidiInstrument): Promise<void>;
        setVolume(instrumentChannel: number, volume: number): void;
        /**
          * Sets the file path from where the sound font can be loaded
          * @param soundId Sound identifier
          * @param path File path for loading samples into memory
          */
        setSoundFontFilePath(soundId: MidiInstrument, path: string): void;
        playbackHasStopped(): void;
        loadSoundFont(soundId: MidiInstrument): Promise<TSoundFont>;
        getMemoryLoadedSoundFonts(): TSoundFont[];
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IControllerOutputListener' {
    export interface IControllerOutputListener {
        outputChanged(directlySet: boolean, currentValue: number, expectedValue: number): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IDisplayInteractionListener' {
    export interface IDisplayInteractionListener {
        displaySizeChanged(width: number, height: number): void;
        positionTouched(relativePositionX: number, relativePositionY: number): void;
        positionDoubleTouched(relativePositionX: number, relativePositionY: number): void;
        mouseDown(relativePositionX: number, relativePositionY: number, activateZoomOnRightMouseButton: boolean): void;
        mouseUp(relativePositionX: number, relativePositionY: number): void;
        mouseMove(relativePositionX: number, relativePositionY: number, deltaX: number, deltaY: number): void;
        zoom(scale: number): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IInstrument' {
    import { MidiInstrument } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    export interface IInstrument {
        Id: number;
        Audible: boolean;
        Solo: boolean;
        Mute: boolean;
        Visible: boolean;
        Highlight: boolean;
        Following: boolean;
        PitchMonitor: boolean;
        Name: string;
        Volume: number;
        MidiInstrumentId: MidiInstrument;
        InstrumentParameterChanged: any;
        setInstrumentParameter(parameter: any, value: Object): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IMessageViewer' {
    export interface IMessageViewer {
        MessageOccurred: any;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IPlaybackParametersListener' {
    export interface IPlaybackParametersListener {
        bpmChanged(newBpm: number, sheetOverride: boolean): void;
        volumeChanged(instrumentId: number, newVolume: number): void;
        volumeMute(instrumentId: number): void;
        volumeUnmute(instrumentId: number): void;
        play(): Promise<void>;
        pause(): Promise<void>;
        reset(): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IRepetition' {
    export interface IRepetition {
        DefaultNumberOfRepetitions: number;
        FirstSourceMeasureNumber: number;
        LastSourceMeasureNumber: number;
        NumberOfEndings: number;
        UserNumberOfRepetitions: number;
        StartIndex: number;
        EndIndex: number;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/ISettableInstrument' {
    import { MidiInstrument } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { IInstrument } from "opensheetmusicdisplay/Common/Interfaces/IInstrument";
    export interface ISettableInstrument extends IInstrument {
        Audible: boolean;
        Solo: boolean;
        Mute: boolean;
        Visible: boolean;
        Following: boolean;
        PitchMonitor: boolean;
        Highlight: boolean;
        Volume: number;
        MidiInstrumentId: MidiInstrument;
        setVoiceAudible(voiceId: number, audible: boolean): void;
        setStaffAudible(staffId: number, audible: boolean): void;
        setVoiceFollowing(voiceId: number, follow: boolean): void;
        setStaffFollow(staffId: number, follow: boolean): void;
        setVoicePitchMonitor(voiceId: number, pitchMonitor: boolean): void;
        setStaffPitchMonitor(staffId: number, pitchMonitor: boolean): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/ITimingSource' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects";
    import { PlaybackSettings } from "opensheetmusicdisplay/Common/DataObjects/PlaybackSettings";
    export interface ITimingSource {
        Settings: PlaybackSettings;
        setBpm(bpm: number): void;
        setTimeAndBpm(timestamp: Fraction, bpm: number): void;
        /** @returns the time in milliseconds when the given timestamp will be reached. */
        getWaitingTimeForTimestampInMs(timestamp: Fraction): number;
        getDurationInMs(duration: Fraction): number;
        getCurrentTimeInMs(): number;
        getCurrentTimestamp(): Fraction;
        /** @returns Returns the current audio timestamp as fraction, but revised by the audio delay of the system (e.g. a constant value is subtracted). */
        getCurrentAudioDelayRevisedTimestamp(): Fraction;
        getTimestampForTimeInMs(timesInMs: number): Fraction;
        getDuration(milliseconds: number): Fraction;
        start(): void;
        pause(): void;
        reset(): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IUserDisplayInteractionListener' {
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects";
    import { InteractionType } from "opensheetmusicdisplay/Common/Enums/InteractionType";
    export interface IUserDisplayInteractionListener {
        userDisplayInteraction(relativePosition: PointF2D, positionInSheetUnits: PointF2D, type: InteractionType): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Interfaces/IZoomView' {
    export interface IZoomView {
            /**
                * @param offsetX x offset in unit coord space
                * @param rangeX x range in unit coord space
                */
            viewportXChanged(offsetX: number, rangeX: number): void;
            /**
                * @param offsetY y offset in unit coord space
                * @param rangeY y range in unit coord space
                */
            viewportYChanged(offsetY: number, rangeY: number): void;
    }
}

declare module 'opensheetmusicdisplay/Common/Enums/InteractionType' {
    export enum InteractionType {
        SingleTouch = 0,
        DoubleTouch = 1,
        TouchUp = 2,
        TouchDown = 3,
        Move = 4
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Playback/PlaybackNote' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData";
    import { PlaybackEntry } from "opensheetmusicdisplay/MusicalScore/Playback/PlaybackEntry";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects";
    export class PlaybackNote {
        constructor(playbackEntry: PlaybackEntry, parentNote: Note);
        /** needs to be done later, when also ties are known */
        setLength(): void;
        get ParentEntry(): PlaybackEntry;
        get ParentNote(): Note;
        MidiKey: number;
        Length: Fraction;
    }
}

declare module 'opensheetmusicdisplay/Playback/TimingSources/AbstractTimingSource' {
    import { ITimingSource } from "opensheetmusicdisplay/Common/Interfaces/ITimingSource";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects";
    import { PlaybackSettings } from "opensheetmusicdisplay/Common/DataObjects/PlaybackSettings";
    export class AbstractTimingSource implements ITimingSource {
        Settings: PlaybackSettings;
        protected anchorTimestamp: Fraction;
        setBpm(bpm: number): void;
        setTimeAndBpm(timestamp: Fraction, bpm?: number): void;
        getCurrentTimestamp(): Fraction;
        getWaitingTimeForTimestampInMs(timestamp: Fraction): number;
        getDurationInMs(duration: Fraction): number;
        getDuration(milliseconds: number): Fraction;
        getCurrentTimeInMs(): number;
        getTimestampForTimeInMs(timesInMs: number): Fraction;
        start(): void;
        pause(): void;
        reset(): void;
        getCurrentAudioDelayRevisedTimestamp(): Fraction;
    }
}

declare module 'opensheetmusicdisplay/Plugins/Transpose/TransposeCalculator' {
    import { ITransposeCalculator } from "opensheetmusicdisplay/MusicalScore/Interfaces";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions";
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression' {
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    export class AbstractExpression {
        protected placement: PlacementEnum;
        parentMeasure: SourceMeasure;
        ColorXML: string;
        constructor(placement: PlacementEnum);
        protected static isStringInStringList(stringList: Array<string>, inputString: string): boolean;
        /** Placement of the expression */
        get Placement(): PlacementEnum;
        static PlacementEnumFromString(placementString: string): PlacementEnum;
    }
    export enum PlacementEnum {
        Above = 0,
        Below = 1,
        Left = 2,
        Right = 3,
        NotYetDefined = 4,
        AboveOrBelow = 5
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsEntry' {
    import { LyricWord } from "opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsWord";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    export class LyricsEntry {
        constructor(text: string, verseNumber: string, word: LyricWord, parent: VoiceEntry, syllableNumber?: number);
        extend: boolean;
        get Text(): string;
        set Text(value: string);
        get Word(): LyricWord;
        get Parent(): VoiceEntry;
        set Parent(value: VoiceEntry);
        get VerseNumber(): string;
        get SyllableIndex(): number;
        get IsTranslation(): boolean;
        get IsChorus(): boolean;
        get FontStyle(): FontStyles;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/TechnicalInstruction' {
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    export enum TechnicalInstructionType {
        Fingering = 0,
        String = 1
    }
    export class TechnicalInstruction {
        type: TechnicalInstructionType;
        value: string;
        placement: PlacementEnum;
        sourceNote: Note;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Articulation' {
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { ArticulationEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    export class Articulation {
        placement: PlacementEnum;
        articulationEnum: ArticulationEnum;
        constructor(articulationEnum: ArticulationEnum, placement: PlacementEnum);
        Equals(otherArticulation: Articulation): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction' {
    import { AbstractNotationInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/AbstractNotationInstruction";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { NoteEnum } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { AccidentalEnum } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    /**
      * A [[KeyInstruction]] is a key signature denoting which notes are to be sharpened or flattened.
      */
    export class KeyInstruction extends AbstractNotationInstruction {
        constructor(sourceStaffEntry?: SourceStaffEntry, key?: number, mode?: KeyEnum);
        keyTypeOriginal: number;
        /** The halftones this instruction was transposed by, compared to the original. */
        isTransposedBy: number;
        static copy(keyInstruction: KeyInstruction): KeyInstruction;
        static getAllPossibleMajorKeyInstructions(): KeyInstruction[];
        get Key(): number;
        set Key(value: number);
        get Mode(): KeyEnum;
        set Mode(value: KeyEnum);
        get AlteratedNotes(): NoteEnum[];
        willAlterateNote(note: NoteEnum): boolean;
        getAlterationForPitch(pitch: Pitch): AccidentalEnum;
        ToString(): string;
        OperatorEquals(key2: KeyInstruction): boolean;
        OperatorNotEqual(key2: KeyInstruction): boolean;
    }
    export class NoteEnumToHalfToneLink {
        constructor(note: NoteEnum, halftone: number);
        note: NoteEnum;
        halfTone: number;
    }
    export enum KeyEnum {
        major = 0,
        minor = 1,
        none = 2,
        dorian = 3,
        phrygian = 4,
        lydian = 5,
        mixolydian = 6,
        aeolian = 7,
        ionian = 8,
        locrian = 9
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Slur' {
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    export class Slur {
        constructor();
        PlacementXml: PlacementEnum;
        get StartNote(): Note;
        set StartNote(value: Note);
        get EndNote(): Note;
        set EndNote(value: Note);
        startNoteHasMoreStartingSlurs(): boolean;
        endNoteHasMoreEndingSlurs(): boolean;
        isCrossed(): boolean;
        isSlurLonger(): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift' {
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    export class OctaveShift {
        constructor(type: string, octave: number);
        numberXml: number;
        get Type(): OctaveEnum;
        set Type(value: OctaveEnum);
        get StaffNumber(): number;
        set StaffNumber(value: number);
        get ParentStartMultiExpression(): MultiExpression;
        set ParentStartMultiExpression(value: MultiExpression);
        get ParentEndMultiExpression(): MultiExpression;
        set ParentEndMultiExpression(value: MultiExpression);
        /**
          * Convert a source (XML) pitch of a note to the pitch needed to draw. E.g. 8va would draw +1 octave so we reduce by 1
          * @param pitch Original pitch
          * @param octaveShiftValue octave shift
          * @returns New pitch with corrected octave shift
          */
        static getPitchFromOctaveShift(pitch: Pitch, octaveShiftValue: OctaveEnum): Pitch;
    }
    export enum OctaveEnum {
        VA8 = 0,
        VB8 = 1,
        MA15 = 2,
        MB15 = 3,
        NONE = 4
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMeasure' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { SystemLinesEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { RhythmInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RhythmInstruction";
    import { Beam } from "opensheetmusicdisplay/MusicalScore/VoiceData/Beam";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { Tuplet } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tuplet";
    import { RepetitionInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction";
    import { SystemLinePosition } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinePosition";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { VexFlowVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowVoiceEntry";
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { GraphicalTie } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalTie";
    export class VexFlowMeasure extends GraphicalMeasure {
            constructor(staff: Staff, sourceMeasure?: SourceMeasure, staffLine?: StaffLine);
            /** octaveOffset according to active clef */
            octaveOffset: number;
            /** The VexFlow Voices in the measure */
            vfVoices: {
                    [voiceID: number]: VF.Voice;
            };
            /** Call this function (if present) to x-format all the voices in the measure */
            formatVoices?: (width: number, parent: VexFlowMeasure) => void;
            /** The VexFlow Ties in the measure */
            vfTies: VF.StaveTie[];
            /** The repetition instructions given as words or symbols (coda, dal segno..) */
            vfRepetitionWords: VF.Repetition[];
            hasMetronomeMark: boolean;
            /** The VexFlow Stave (= one measure in a staffline) */
            protected stave: VF.Stave;
            /** VexFlow StaveConnectors (vertical lines) */
            protected connectors: VF.StaveConnector[];
            /** Intermediate object to construct tuplets */
            protected tuplets: {
                    [voiceID: number]: [Tuplet, VexFlowVoiceEntry[]][];
            };
            rules: EngravingRules;
            setAbsoluteCoordinates(x: number, y: number): void;
            /**
                * Reset all the geometric values and parameters of this measure and put it in an initialized state.
                * This is needed to evaluate a measure a second time by system builder.
                */
            resetLayout(): void;
            clean(): void;
            /**
                * returns the x-width (in units) of a given measure line {SystemLinesEnum}.
                * @param line
                * @returns the x-width in osmd units
                */
            getLineWidth(line: SystemLinesEnum): number;
            /**
                * adds the given clef to the begin of the measure.
                * This has to update/increase BeginInstructionsWidth.
                * @param clef
                */
            addClefAtBegin(clef: ClefInstruction): void;
            /**
                * Sets the number of stafflines that are rendered, so that they are centered properly
                * @param lineNumber
                */
            setLineNumber(lineNumber: number): void;
            /**
                * adds the given key to the begin of the measure.
                * This has to update/increase BeginInstructionsWidth.
                * @param currentKey the new valid key.
                * @param previousKey the old cancelled key. Needed to show which accidentals are not valid any more.
                * @param currentClef the valid clef. Needed to put the accidentals on the right y-positions.
                */
            addKeyAtBegin(currentKey: KeyInstruction, previousKey: KeyInstruction, currentClef: ClefInstruction): void;
            /**
                * adds the given rhythm to the begin of the measure.
                * This has to update/increase BeginInstructionsWidth.
                * @param rhythm
                */
            addRhythmAtBegin(rhythm: RhythmInstruction): void;
            /**
                * adds the given clef to the end of the measure.
                * This has to update/increase EndInstructionsWidth.
                * @param clef
                */
            addClefAtEnd(clef: ClefInstruction, visible?: boolean): void;
            addMeasureLine(lineType: SystemLinesEnum, linePosition: SystemLinePosition, renderInitialLine?: boolean): void;
            /**
                * Adds a measure number to the top left corner of the measure
                * This method is not used currently in favor of the calculateMeasureNumberPlacement
                * method in the MusicSheetCalculator.ts
                */
            addMeasureNumber(): void;
            addWordRepetition(repetitionInstruction: RepetitionInstruction): void;
            protected addVolta(repetitionInstruction: RepetitionInstruction): void;
            /**
                * Sets the overall x-width of the measure.
                * @param width
                */
            setWidth(width: number): void;
            /**
                * This method is called after the StaffEntriesScaleFactor has been set.
                * Here the final x-positions of the staff entries have to be set.
                * (multiply the minimal positions with the scaling factor, considering the BeginInstructionsWidth)
                */
            layoutSymbols(): void;
            /**
                * Draw this measure on a VexFlow CanvasContext
                * @param ctx
                */
            draw(ctx: Vex.IRenderContext): Node;
            format(): void;
            correctNotePositions(): void;
            /**
                * Returns all the voices that are present in this measure
                */
            getVoicesWithinMeasure(): Voice[];
            /**
                * Returns all the graphicalVoiceEntries of a given Voice.
                * @param voice the voice for which the graphicalVoiceEntries shall be returned.
                */
            getGraphicalVoiceEntriesPerVoice(voice: Voice): GraphicalVoiceEntry[];
            /**
                * Finds the gaps between the existing notes within a measure.
                * Problem here is, that the graphicalVoiceEntry does not exist yet and
                * that Tied notes are not present in the normal voiceEntries.
                * To handle this, calculation with absolute timestamps is needed.
                * And the graphical notes have to be analysed directly (and not the voiceEntries, as it actually should be -> needs refactoring)
                * @param voice the voice for which the ghost notes shall be searched.
                */
            protected getRestFilledVexFlowStaveNotesPerVoice(voice: Voice): GraphicalVoiceEntry[];
            /**
                * Add a note to a beam
                * @param graphicalNote
                * @param beam
                */
            handleBeam(graphicalNote: GraphicalNote, beam: Beam): void;
            handleTuplet(graphicalNote: GraphicalNote, tuplet: Tuplet): void;
            /**
                * Complete the creation of VexFlow Beams in this measure
                */
            finalizeBeams(): void;
            /**
                * Complete the creation of VexFlow Tuplets in this measure
                */
            finalizeTuplets(): void;
            layoutStaffEntry(graphicalStaffEntry: GraphicalStaffEntry): void;
            graphicalMeasureCreatedCalculations(): void;
            /**
                * Create the articulations for all notes of the current staff entry
                */
            protected createArticulations(): void;
            /**
                * Create the ornaments for all notes of the current staff entry
                */
            protected createOrnaments(): void;
            /** Creates vexflow fingering elements.
                * Note that this is currently only used for Left and Right fingering positions, not Above and Below,
                * in which case they are instead added via MusicSheetCalculator.calculateFingerings() as Labels with bounding boxes.
                */
            protected createFingerings(voiceEntry: GraphicalVoiceEntry): void;
            protected createStringNumber(voiceEntry: GraphicalVoiceEntry): void;
            /**
                * Creates a line from 'top' to this measure, of type 'lineType'
                * @param top
                * @param lineType
                */
            lineTo(top: VexFlowMeasure, lineType: any): void;
            /**
                * Return the VexFlow Stave corresponding to this graphicalMeasure
                * @returns {VF.Stave}
                */
            getVFStave(): VF.Stave;
            /**
                * After re-running the formatting on the VexFlow Stave, update the
                * space needed by Instructions (in VexFlow: StaveModifiers)
                */
            protected updateInstructionWidth(): void;
            addStaveTie(stavetie: VF.StaveTie, graphicalTie: GraphicalTie): void;
    }
    export enum StavePositionEnum {
            LEFT = 1,
            RIGHT = 2,
            ABOVE = 3,
            BELOW = 4,
            BEGIN = 5,
            END = 6
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowContinuousDynamicExpression' {
    import { GraphicalContinuousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalContinuousDynamicExpression";
    import { ContinuousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/ContinuousDynamicExpression";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    /**
      * This class extends the GraphicalContinuousDynamicExpression and creates all necessary methods for drawing
      */
    export class VexFlowContinuousDynamicExpression extends GraphicalContinuousDynamicExpression {
        constructor(continuousDynamic: ContinuousDynamicExpression, staffLine: StaffLine, measure: SourceMeasure, textHeight?: number);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/AbstractNotationInstruction' {
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    export abstract class AbstractNotationInstruction {
        constructor(parent: SourceStaffEntry);
        protected parent: SourceStaffEntry;
        get Parent(): SourceStaffEntry;
        set Parent(value: SourceStaffEntry);
        get PrintObject(): boolean;
        set PrintObject(value: boolean);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction' {
    import { Repetition } from "opensheetmusicdisplay/MusicalScore/MusicSource/Repetition";
    export class RepetitionInstructionComparer {
        static Compare(x: RepetitionInstruction, y: RepetitionInstruction): number;
    }
    export class RepetitionInstruction {
        constructor(measureIndex: number, type: RepetitionInstructionEnum, alignment?: AlignmentType, parentRepetition?: Repetition, endingIndices?: number[]);
        measureIndex: number;
        endingIndices: number[];
        type: RepetitionInstructionEnum;
        alignment: AlignmentType;
        parentRepetition: Repetition;
        CompareTo(obj: Object): number;
        equals(other: RepetitionInstruction): boolean;
    }
    export enum RepetitionInstructionEnum {
        StartLine = 0,
        ForwardJump = 1,
        BackJumpLine = 2,
        Ending = 3,
        DaCapo = 4,
        DalSegno = 5,
        Fine = 6,
        ToCoda = 7,
        DalSegnoAlFine = 8,
        DaCapoAlFine = 9,
        DalSegnoAlCoda = 10,
        DaCapoAlCoda = 11,
        Coda = 12,
        Segno = 13,
        None = 14
    }
    export enum AlignmentType {
        Begin = 0,
        End = 1
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression' {
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { InstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousDynamicExpression";
    import { ContinuousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/ContinuousDynamicExpression";
    import { OctaveShift } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { MoodExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MoodExpression";
    import { UnknownExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/UnknownExpression";
    import { AbstractExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { Pedal } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Pedal";
    import { WavyLine } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/WavyLine";
    export class MultiExpression {
        constructor(sourceMeasure: SourceMeasure, timestamp: Fraction);
        /** The 'number="x"' given in XML, e.g. of a wedge, used to identify similar expressions. */
        numberXml: number;
        PedalStart: Pedal;
        PedalEnd: Pedal;
        WavyLineStart: WavyLine;
        WavyLineEnd: WavyLine;
        get SourceMeasureParent(): SourceMeasure;
        set SourceMeasureParent(value: SourceMeasure);
        get StaffNumber(): number;
        set StaffNumber(value: number);
        get Timestamp(): Fraction;
        set Timestamp(value: Fraction);
        get AbsoluteTimestamp(): Fraction;
        get InstantaneousDynamic(): InstantaneousDynamicExpression;
        set InstantaneousDynamic(value: InstantaneousDynamicExpression);
        get EndingContinuousDynamic(): ContinuousDynamicExpression;
        set EndingContinuousDynamic(value: ContinuousDynamicExpression);
        get StartingContinuousDynamic(): ContinuousDynamicExpression;
        set StartingContinuousDynamic(value: ContinuousDynamicExpression);
        get MoodList(): MoodExpression[];
        get UnknownList(): UnknownExpression[];
        get EntriesList(): MultiExpressionEntry[];
        get OctaveShiftStart(): OctaveShift;
        set OctaveShiftStart(value: OctaveShift);
        get OctaveShiftEnd(): OctaveShift;
        set OctaveShiftEnd(value: OctaveShift);
        get CombinedExpressionsText(): string;
        set CombinedExpressionsText(value: string);
        getPlacementOfFirstEntry(): PlacementEnum;
        getFontstyleOfFirstEntry(): FontStyles;
        addExpression(abstractExpression: AbstractExpression, prefix: string): void;
        CompareTo(other: MultiExpression): number;
    }
    export class MultiExpressionEntry {
        prefix: string;
        expression: AbstractExpression;
        label: string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/RehearsalExpression' {
    import { AbstractExpression, PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    export class RehearsalExpression extends AbstractExpression {
        constructor(label: string, placement: PlacementEnum);
        label: string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/ContinuousDynamicExpression' {
    import { PlacementEnum, AbstractExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { InstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousDynamicExpression";
    export class ContinuousDynamicExpression extends AbstractExpression {
        constructor(dynamicType: ContDynamicEnum, placement: PlacementEnum, staffNumber: number, measure: SourceMeasure, activeInstantaneousDynamic: InstantaneousDynamicExpression, numberXml: number, label?: string);
        NumberXml: number;
        IsStartOfSoftAccent: boolean;
        YPosXml: number;
        setStartAndEndVolume(): void;
        get DynamicType(): ContDynamicEnum;
        set DynamicType(value: ContDynamicEnum);
        get StartMultiExpression(): MultiExpression;
        set StartMultiExpression(value: MultiExpression);
        get EndMultiExpression(): MultiExpression;
        set EndMultiExpression(value: MultiExpression);
        get Placement(): PlacementEnum;
        set Placement(value: PlacementEnum);
        get StartVolume(): number;
        set StartVolume(value: number);
        get EndVolume(): number;
        set EndVolume(value: number);
        get StaffNumber(): number;
        set StaffNumber(value: number);
        get Label(): string;
        set Label(value: string);
        static isInputStringContinuousDynamic(inputString: string): boolean;
        getInterpolatedDynamic(currentAbsoluteTimestamp: Fraction): number;
        isWedge(): boolean;
    }
    export enum ContDynamicEnum {
        crescendo = 0,
        /** Diminuendo/Decrescendo. These terms are apparently sometimes synonyms, and a falling wedge is given in MusicXML as type="diminuendo". */
        diminuendo = 1
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousDynamicExpression' {
    import { PlacementEnum, AbstractExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    import { DynamicExpressionSymbolEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/DynamicExpressionSymbolEnum";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { Dictionary } from "typescript-collections";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    export class InstantaneousDynamicExpression extends AbstractExpression {
        static staticConstructor(): void;
        constructor(dynamicExpression: string, soundDynamics: number, placement: PlacementEnum, staffNumber: number, measure: SourceMeasure);
        static dynamicToRelativeVolumeDict: Dictionary<DynamicEnum, number>;
        InMeasureTimestamp: Fraction;
        get ParentMultiExpression(): MultiExpression;
        set ParentMultiExpression(value: MultiExpression);
        get DynEnum(): DynamicEnum;
        set DynEnum(value: DynamicEnum);
        get SoundDynamic(): number;
        set SoundDynamic(value: number);
        get Placement(): PlacementEnum;
        set Placement(value: PlacementEnum);
        get StaffNumber(): number;
        set StaffNumber(value: number);
        get Length(): number;
        get MidiVolume(): number;
        get Volume(): number;
        static isInputStringInstantaneousDynamic(inputString: string): boolean;
        getDynamicExpressionSymbol(c: string): DynamicExpressionSymbolEnum;
    }
    export enum DynamicEnum {
        pppppp = 0,
        ppppp = 1,
        pppp = 2,
        ppp = 3,
        pp = 4,
        p = 5,
        mp = 6,
        mf = 7,
        f = 8,
        ff = 9,
        fff = 10,
        ffff = 11,
        fffff = 12,
        ffffff = 13,
        sf = 14,
        sff = 15,
        sfp = 16,
        sfpp = 17,
        fp = 18,
        rf = 19,
        rfz = 20,
        sfz = 21,
        sffz = 22,
        fz = 23,
        other = 24
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousTempoExpression' {
    import { AbstractTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractTempoExpression";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { MultiTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiTempoExpression";
    /** Tempo expressions that usually have an instantaneous and non-gradual effect on playback speed (e.g. Allegro),
      * or at least cover large sections, compared to the usually gradual effects or shorter sections of ContinuousExpressions.
      */
    export class InstantaneousTempoExpression extends AbstractTempoExpression {
        constructor(label: string, placement: PlacementEnum, staffNumber: number, soundTempo: number, parentMultiTempoExpression: MultiTempoExpression, isMetronomeMark?: boolean);
        dotted: boolean;
        beatUnit: string;
        isMetronomeMark: boolean;
        static getDefaultValueForTempoType(tempoEnum: TempoEnum): number;
        static isInputStringInstantaneousTempo(inputString: string): boolean;
        get Label(): string;
        set Label(value: string);
        get Placement(): PlacementEnum;
        set Placement(value: PlacementEnum);
        get StaffNumber(): number;
        set StaffNumber(value: number);
        get Enum(): TempoEnum;
        get TempoInBpm(): number;
        set TempoInBpm(value: number);
        get ParentMultiTempoExpression(): MultiTempoExpression;
        getAbsoluteTimestamp(): Fraction;
        getAbsoluteFloatTimestamp(): number;
    }
    export enum TempoEnum {
        none = 0,
        larghissimo = 1,
        grave = 2,
        lento = 3,
        largo = 4,
        larghetto = 5,
        adagio = 6,
        adagietto = 7,
        andanteModerato = 8,
        andante = 9,
        andantino = 10,
        moderato = 11,
        allegretto = 12,
        allegroModerato = 13,
        allegro = 14,
        vivace = 15,
        vivacissimo = 16,
        allegrissimo = 17,
        presto = 18,
        prestissimo = 19,
        lastRealTempo = 20,
        addon = 21,
        changes = 22,
        metronomeMark = 23
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractTempoExpression' {
    import { PlacementEnum, AbstractExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { MultiTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiTempoExpression";
    export abstract class AbstractTempoExpression extends AbstractExpression {
        constructor(label: string, placement: PlacementEnum, staffNumber: number, parentMultiTempoExpression: MultiTempoExpression);
        protected label: string;
        protected staffNumber: number;
        protected parentMultiTempoExpression: MultiTempoExpression;
        get Label(): string;
        set Label(value: string);
        get Placement(): PlacementEnum;
        set Placement(value: PlacementEnum);
        get StaffNumber(): number;
        set StaffNumber(value: number);
        get ParentMultiTempoExpression(): MultiTempoExpression;
        protected static isStringInStringList(wordsToFind: string[], inputString: string): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/ContinuousTempoExpression' {
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { MultiTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiTempoExpression";
    import { AbstractTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractTempoExpression";
    /** Tempo expressions that usually have a continuous or gradual effect playback-wise (e.g. accelerando),
      * or describe shorter sections (e.g. meno mosso).
      */
    export class ContinuousTempoExpression extends AbstractTempoExpression {
        constructor(label: string, placement: PlacementEnum, staffNumber: number, parentMultiTempoExpression: MultiTempoExpression);
        static isInputStringContinuousTempo(inputString: string): boolean;
        static isIncreasingTempo(tempoType: ContinuousTempoType): boolean;
        static isDecreasingTempo(tempoType: ContinuousTempoType): boolean;
        get TempoType(): ContinuousTempoType;
        set TempoType(value: ContinuousTempoType);
        get StartTempo(): number;
        set StartTempo(value: number);
        get EndTempo(): number;
        set EndTempo(value: number);
        get AbsoluteEndTimestamp(): Fraction;
        set AbsoluteEndTimestamp(value: Fraction);
        get AbsoluteTimestamp(): Fraction;
        getAbsoluteFloatTimestamp(): number;
        getInterpolatedTempo(currentAbsoluteTimestamp: Fraction): number;
    }
    export enum ContinuousTempoType {
        accelerando = 0,
        stretto = 1,
        stringendo = 2,
        mosso = 3,
        piuMosso = 4,
        allargando = 5,
        calando = 6,
        menoMosso = 7,
        rallentando = 8,
        ritardando = 9,
        ritard = 10,
        rit = 11,
        ritenuto = 12,
        rubato = 13,
        precipitando = 14
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RhythmInstruction' {
    import { AbstractNotationInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/AbstractNotationInstruction";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    /**
      * A [[RhythmInstruction]] is the time signature which specifies the number of beats in each bar, and the value of one beat.
      */
    export class RhythmInstruction extends AbstractNotationInstruction {
        constructor(rhythm: Fraction, rhythmSymbolEnum: RhythmSymbolEnum);
        get Rhythm(): Fraction;
        set Rhythm(value: Fraction);
        get SymbolEnum(): RhythmSymbolEnum;
        set SymbolEnum(value: RhythmSymbolEnum);
        clone(): RhythmInstruction;
        OperatorEquals(rhythm2: RhythmInstruction): boolean;
        OperatorNotEqual(rhythm2: RhythmInstruction): boolean;
        ToString(): string;
    }
    export enum RhythmSymbolEnum {
        NONE = 0,
        COMMON = 1,
        CUT = 2
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/RepetitionInstructionReader' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { RepetitionInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction";
    export class RepetitionInstructionReader {
            /**
                * A global list of all repetition instructions in the musicsheet.
                */
            repetitionInstructions: RepetitionInstruction[];
            xmlMeasureList: IXmlElement[][];
            set MusicSheet(value: MusicSheet);
            /**
                * is called when starting reading an xml measure
                * @param measure
                * @param currentMeasureIndex
                */
            prepareReadingMeasure(measure: SourceMeasure, currentMeasureIndex: number): void;
            handleLineRepetitionInstructions(barlineNode: IXmlElement): boolean;
            handleRepetitionInstructionsFromWordsOrSymbols(directionTypeNode: IXmlElement, relativeMeasurePosition: number): boolean;
            removeRedundantInstructions(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/RepetitionCalculator' {
    import { RepetitionInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { Repetition } from "opensheetmusicdisplay/MusicalScore/MusicSource";
    export class RepetitionCalculator {
        /**
          * Is called when all repetition symbols have been read from xml.
          * Creates the repetition instructions and adds them to the corresponding measure.
          * Creates the logical repetition objects for iteration and playback.
          * @param musicSheet
          * @param repetitionInstructions
          */
        calculateRepetitions(musicSheet: MusicSheet, repetitionInstructions: RepetitionInstruction[]): void;
    }
    export class RepetitionBuildingContainer {
        RepetitonUnderConstruction: Repetition;
        WaitingForCoda: boolean;
        SegnoFound: boolean;
        FineFound: boolean;
        ToCodaFound: boolean;
        CodaFound: boolean;
        constructor(musicSheet: MusicSheet);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/SlurReader' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    export class SlurReader {
        constructor(musicSheet: MusicSheet);
        addSlur(slurNodes: IXmlElement[], currentNote: Note): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/ArticulationReader' {
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class ArticulationReader {
            constructor(rules: EngravingRules);
            /**
                * This method adds an Articulation Expression to the currentVoiceEntry.
                * @param node
                * @param currentVoiceEntry
                */
            addArticulationExpression(node: IXmlElement, currentVoiceEntry: VoiceEntry): void;
            /**
                * This method add a Fermata to the currentVoiceEntry.
                * @param xmlNode
                * @param currentVoiceEntry
                */
            addFermata(xmlNode: IXmlElement, currentVoiceEntry: VoiceEntry): void;
            /**
                * This method add a technical Articulation to the currentVoiceEntry.
                * @param technicalNode
                * @param currentVoiceEntry
                */
            addTechnicalArticulations(technicalNode: IXmlElement, currentVoiceEntry: VoiceEntry, currentNote: Note): void;
            /**
                * This method adds an Ornament to the currentVoiceEntry.
                * @param ornamentsNode
                * @param currentVoiceEntry
                */
            addOrnament(ornamentsNode: IXmlElement, currentVoiceEntry: VoiceEntry): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/ChordSymbolReader' {
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { ChordSymbolContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/ChordSymbolContainer";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    export class ChordSymbolReader {
        static readChordSymbol(xmlNode: IXmlElement, musicSheet: MusicSheet, activeKey: KeyInstruction): ChordSymbolContainer;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/DynamicsCalculator' {
    import { IAfterSheetReadingModule } from "opensheetmusicdisplay/MusicalScore/Interfaces";
    import { MusicSheet } from "opensheetmusicdisplay/";
    export class DynamicsCalculator implements IAfterSheetReadingModule {
            /**
                * The interface main function: called when the musicsheet has been read.
                * @param musicSheet
                */
            calculate(musicSheet: MusicSheet): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/ExpressionReader' {
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { Instrument } from "opensheetmusicdisplay/MusicalScore/Instrument";
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    export class ExpressionReader {
        constructor(musicSheet: MusicSheet, instrument: Instrument, staffNumber: number);
        getMultiExpression: MultiExpression;
        readExpressionParameters(xmlNode: IXmlElement, currentInstrument: Instrument, divisions: number, inSourceMeasureCurrentFraction: Fraction, inSourceMeasureFormerFraction: Fraction, currentMeasureIndex: number, ignoreDivisionsOffset: boolean): void;
        read(directionNode: IXmlElement, currentMeasure: SourceMeasure, inSourceMeasureCurrentFraction: Fraction, inSourceMeasurePreviousFraction?: Fraction): void;
        /** Usually called at end of last measure. */
        closeOpenExpressions(sourceMeasure: SourceMeasure, timestamp: Fraction): void;
        addOctaveShift(directionNode: IXmlElement, currentMeasure: SourceMeasure, endTimestamp: Fraction): void;
        addPedalMarking(directionNode: IXmlElement, currentMeasure: SourceMeasure, endTimestamp: Fraction): void;
        addWavyLine(wavyLineNode: IXmlElement, currentMeasure: SourceMeasure, currentTimestamp: Fraction, previousTimestamp: Fraction): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/ScoreIO/MusicSymbolModules/LyricsReader' {
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { IXmlElement } from "opensheetmusicdisplay/Common/FileIO/Xml";
    import { MusicSheet } from "opensheetmusicdisplay/MusicalScore/MusicSheet";
    export class LyricsReader {
        constructor(musicSheet: MusicSheet);
        /**
          * This method adds a single LyricEntry to a VoiceEntry
          * @param {IXmlElement[]} lyricNodeList
          * @param {VoiceEntry} currentVoiceEntry
          */
        addLyricEntry(lyricNodeList: IXmlElement[], currentVoiceEntry: VoiceEntry): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsWord' {
    import { LyricsEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsEntry";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    export class LyricWord {
        get Syllables(): LyricsEntry[];
        containsVoiceEntry(voiceEntry: VoiceEntry): boolean;
        findLyricEntryInVoiceEntry(voiceEntry: VoiceEntry): LyricsEntry;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/SkyBottomLineCalculationResult' {
    /**
      * Contains a skyline and a bottomline for a measure.
      */
    export class SkyBottomLineCalculationResult {
        skyLine: number[];
        bottomLine: number[];
        constructor(skyLine: number[], bottomLine: number[]);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalPedal' {
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { MusicSymbol } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSymbol";
    import { Pedal } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Pedal";
    /**
      * The graphical counterpart of an [[Pedal]]
      */
    export class GraphicalPedal extends GraphicalObject {
        constructor(pedal: Pedal, parent: BoundingBox);
        getPedal: Pedal;
        pedalSymbol: MusicSymbol;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/GraphicalWavyLine' {
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { WavyLine } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/WavyLine";
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    export class GraphicalWavyLine extends GraphicalObject {
        constructor(wavyLine: WavyLine, parent: BoundingBox);
        getWavyLine: WavyLine;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/CanvasVexFlowBackend' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { VexFlowBackend } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowBackend";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { Fonts } from "opensheetmusicdisplay/Common/Enums/Fonts";
    import { RectangleF2D } from "opensheetmusicdisplay/Common/DataObjects/RectangleF2D";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { BackendType } from "opensheetmusicdisplay/OpenSheetMusicDisplay/OSMDOptions";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class CanvasVexFlowBackend extends VexFlowBackend {
        constructor(rules: EngravingRules);
        getVexflowBackendType(): VF.Renderer.Backends;
        getOSMDBackendType(): BackendType;
        getCanvasSize(): number;
        initialize(container: HTMLElement, zoom: number): void;
        /**
          * Initialize a canvas without attaching it to a DOM node. Can be used to draw in background
          * @param width Width of the canvas
          * @param height Height of the canvas
          */
        initializeHeadless(width?: number, height?: number): void;
        getContext(): VF.CanvasContext;
        free(): void;
        clear(): void;
        scale(k: number): void;
        translate(x: number, y: number): void;
        renderText(fontHeight: number, fontStyle: FontStyles, font: Fonts, text: string, heightInPixel: number, screenPosition: PointF2D, color?: string, fontFamily?: string): Node;
        renderRectangle(rectangle: RectangleF2D, styleId: number, colorHex: string, alpha?: number): Node;
        renderLine(start: PointF2D, stop: PointF2D, color?: string, lineWidth?: number, id?: string): Node;
        renderCurve(points: PointF2D[]): Node;
        renderPath(points: PointF2D[], fill?: boolean, id?: string): Node;
        get CanvasRenderingCtx(): CanvasRenderingContext2D;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/SvgVexFlowBackend' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { VexFlowBackend } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowBackend";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { Fonts } from "opensheetmusicdisplay/Common/Enums/Fonts";
    import { RectangleF2D } from "opensheetmusicdisplay/Common/DataObjects/RectangleF2D";
    import { PointF2D } from "opensheetmusicdisplay/Common/DataObjects/PointF2D";
    import { BackendType } from "opensheetmusicdisplay/OpenSheetMusicDisplay/OSMDOptions";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class SvgVexFlowBackend extends VexFlowBackend {
        zoom: number;
        constructor(rules: EngravingRules);
        getVexflowBackendType(): VF.Renderer.Backends;
        getOSMDBackendType(): BackendType;
        getCanvasSize(): number;
        initialize(container: HTMLElement, zoom: number, id?: string): void;
        getContext(): VF.SVGContext;
        getSvgElement(): SVGElement;
        removeNode(node: Node): boolean;
        free(): void;
        clear(): void;
        scale(k: number): void;
        translate(x: number, y: number): void;
        renderText(fontHeight: number, fontStyle: FontStyles, font: Fonts, text: string, heightInPixel: number, screenPosition: PointF2D, color?: string, fontFamily?: string): Node;
        renderRectangle(rectangle: RectangleF2D, styleId: number, colorHex: string, alpha?: number): Node;
        renderLine(start: PointF2D, stop: PointF2D, color?: string, lineWidth?: number, id?: string): Node;
        renderCurve(points: PointF2D[]): Node;
        renderPath(points: PointF2D[], fill?: boolean, id?: string): Node;
        export(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowConverter' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { ClefEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { RhythmInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RhythmInstruction";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { SystemLinesEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { Fonts } from "opensheetmusicdisplay/Common/Enums/Fonts";
    import { OutlineAndFillStyleEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/DrawingEnums";
    import { SystemLinePosition } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinePosition";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { OrnamentContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/OrnamentContainer";
    import { Notehead } from "opensheetmusicdisplay/MusicalScore/VoiceData/Notehead";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { ArpeggioType } from "opensheetmusicdisplay/MusicalScore/VoiceData/Arpeggio";
    /**
        * Helper class, which contains static methods which actually convert
        * from OSMD objects to VexFlow objects.
        */
    export class VexFlowConverter {
            /**
                * Convert a fraction to Vexflow string durations.
                * A duration like 5/16 (5 16th notes) can't be represented by a single (dotted) note,
                *   so we need to return multiple durations (e.g. for 5/16th ghost notes).
                * Currently, for a dotted quarter ghost note, we return a quarter and an eighth ghost note.
                *   We could return a dotted quarter instead, but then the code would need to distinguish between
                *   notes that can be represented as dotted notes and notes that can't, which would complicate things.
                *   We could e.g. add a parameter "allowSingleDottedNote" which makes it possible to return single dotted notes instead.
                * But currently, this is only really used for Ghost notes, so it doesn't make a difference visually.
                *   (for other uses like StaveNotes, we calculate the dots separately)
                * @param fraction a fraction representing the duration of a note
                * @returns {string[]} Vexflow note type strings (e.g. "h" = half note)
                */
            static durations(fraction: Fraction, isTuplet: boolean): string[];
            /**
                * Takes a Pitch and returns a string representing a VexFlow pitch,
                * which has the form "b/4", plus its alteration (accidental)
                * @param pitch
                * @returns {string[]}
                */
            static pitch(pitch: Pitch, isRest: boolean, clef: ClefInstruction, notehead?: Notehead, octaveOffsetGiven?: number): [string, string, ClefInstruction];
            static restToNotePitch(pitch: Pitch, clefType: ClefEnum): Pitch;
            /** returns the Vexflow code for a note head. Some are still unsupported, see Vexflow/tables.js */
            static NoteHeadCode(notehead: Notehead): string;
            static GhostNotes(frac: Fraction): VF.GhostNote[];
            /**
                * Convert a GraphicalVoiceEntry to a VexFlow StaveNote
                * @param gve the GraphicalVoiceEntry which can hold a note or a chord on the staff belonging to one voice
                * @returns {VF.StaveNote}
                */
            static StaveNote(gve: GraphicalVoiceEntry): VF.StaveNote;
            static generateArticulations(vfnote: VF.StemmableNote, gNote: GraphicalNote, rules: EngravingRules): void;
            static generateOrnaments(vfnote: VF.StemmableNote, oContainer: OrnamentContainer): void;
            static StrokeTypeFromArpeggioType(arpeggioType: ArpeggioType): VF.Stroke.Type;
            /**
                * Convert a set of GraphicalNotes to a VexFlow StaveNote
                * @param notes form a chord on the staff
                * @returns {VF.StaveNote}
                */
            static CreateTabNote(gve: GraphicalVoiceEntry): VF.TabNote;
            /**
                * Convert a ClefInstruction to a string represention of a clef type in VexFlow.
                *
                * @param clef The OSMD object to be converted representing the clef
                * @param size The VexFlow size to be used. Can be `default` or `small`.
                * As soon as #118 is done, this parameter will be dispensable.
                * @returns    A string representation of a VexFlow clef
                * @see        https://github.com/0xfe/vexflow/blob/master/src/clef.js
                * @see        https://github.com/0xfe/vexflow/blob/master/tests/clef_tests.js
                */
            static Clef(clef: ClefInstruction, size?: string): {
                    type: string;
                    size: string;
                    annotation: string;
            };
            /**
                * Convert a RhythmInstruction to a VexFlow TimeSignature object
                * @param rhythm
                * @returns {VF.TimeSignature}
                * @constructor
                */
            static TimeSignature(rhythm: RhythmInstruction): VF.TimeSignature;
            /**
                * Convert a KeyInstruction to a string representing in VexFlow a key
                * @param key
                * @returns {string}
                */
            static keySignature(key: KeyInstruction): string;
            /**
                * Converts a lineType to a VexFlow StaveConnector type
                * @param lineType
                * @returns {any}
                */
            static line(lineType: SystemLinesEnum, linePosition: SystemLinePosition): any;
            /**
                * Construct a string which can be used in a CSS font property
                * @param fontSize
                * @param fontStyle
                * @param font
                * @returns {string}
                */
            static font(fontSize: number, fontStyle: FontStyles, font: Fonts, rules: EngravingRules, fontFamily?: string): string;
            /**
                * Converts the style into a string that VexFlow RenderContext can understand
                * as the weight of the font
                */
            static fontStyle(style: FontStyles): string;
            /**
                * Convert OutlineAndFillStyle to CSS properties
                * @param styleId
                * @returns {string}
                */
            static style(styleId: OutlineAndFillStyleEnum): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowGlissando' {
    import { GraphicalGlissando } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalGlissando";
    import Vex from "vexflow";
    import VF = Vex.Flow;
    export class VexFlowGlissando extends GraphicalGlissando {
        vfTie: VF.StaveTie;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowGraphicalNote' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { OctaveEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    /**
        * The VexFlow version of a [[GraphicalNote]].
        */
    export class VexFlowGraphicalNote extends GraphicalNote {
            constructor(note: Note, parent: GraphicalVoiceEntry, activeClef: ClefInstruction, octaveShift: OctaveEnum, rules: EngravingRules, graphicalNoteLength?: Fraction);
            octaveShift: OctaveEnum;
            vfpitch: [string, string, ClefInstruction];
            vfnote: [VF.StemmableNote, number];
            vfnoteIndex: number;
            /**
                * Update the pitch of this note. Necessary in order to display accidentals correctly.
                * This is called by VexFlowGraphicalSymbolFactory.addGraphicalAccidental.
                * @param pitch
                */
            setAccidental(pitch: Pitch): void;
            drawPitch(pitch: Pitch): Pitch;
            Transpose(keyInstruction: KeyInstruction, activeClef: ClefInstruction, halfTones: number, octaveEnum: OctaveEnum): Pitch;
            /**
                * Set the VexFlow StaveNote corresponding to this GraphicalNote, together with its index in the chord.
                * @param note
                * @param index
                */
            setIndex(note: VF.StemmableNote, index: number): void;
            notehead(vfNote?: VF.StemmableNote): {
                    line: number;
            };
            /**
                * Gets the clef for this note
                */
            Clef(): ClefInstruction;
            /**
                * Gets the id of the SVGGElement containing this note, given the SVGRenderer is used.
                * This is for low-level rendering hacks and should be used with caution.
                */
            getSVGId(): string;
            /**
                * Gets the SVGGElement containing this note, given the SVGRenderer is used.
                * This is for low-level rendering hacks and should be used with caution.
                */
            getSVGGElement(): SVGGElement;
            /** Gets the SVG path element of the note's stem. */
            getStemSVG(): HTMLElement;
            /** Gets the SVG path elements of the beams starting on this note. */
            getBeamSVGs(): HTMLElement[];
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowGraphicalSymbolFactory' {
    import { IGraphicalSymbolFactory } from "opensheetmusicdisplay/MusicalScore/Interfaces/IGraphicalSymbolFactory";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { Note } from "opensheetmusicdisplay/MusicalScore/VoiceData/Note";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { OctaveEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { Pitch } from "opensheetmusicdisplay/Common/DataObjects/Pitch";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { TechnicalInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/TechnicalInstruction";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { KeyInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/KeyInstruction";
    import { SkyBottomLineCalculator } from "opensheetmusicdisplay/MusicalScore/Graphical/SkyBottomLineCalculator";
    export class VexFlowGraphicalSymbolFactory implements IGraphicalSymbolFactory {
            constructor();
            /**
                * Create a new music system for the given page.
                * Currently only one vertically endless page exists where all systems are put to.
                * @param page
                * @param systemIndex
                * @returns {VexFlowMusicSystem}
                */
            createMusicSystem(systemIndex: number, rules: EngravingRules): MusicSystem;
            /**
                * Create a staffline object containing all staff measures belonging to a given system and staff.
                * @param parentSystem
                * @param parentStaff
                * @returns {VexFlowStaffLine}
                */
            createStaffLine(parentSystem: MusicSystem, parentStaff: Staff): StaffLine;
            /**
                * Create a SkyBottomLine calculator for a given staffline
                * @param parentSystem
                * @param parentStaff
                * @returns {VexFlowStaffLine}
                */
            createSkyBottomLineCalculator(parentStaffline: StaffLine): SkyBottomLineCalculator;
            /**
                * Construct an empty graphicalMeasure from the given source measure and staff.
                * @param sourceMeasure
                * @param staff
                * @returns {VexFlowMeasure}
                */
            createGraphicalMeasure(sourceMeasure: SourceMeasure, staff: Staff, isTabMeasure?: boolean): GraphicalMeasure;
            /**
                * Construct a MultiRestMeasure from the given source measure and staff.
                * @param sourceMeasure
                * @param staff
                * @returns {VexFlowMultiRestMeasure}
                */
            createMultiRestMeasure(sourceMeasure: SourceMeasure, staff: Staff, staffLine?: StaffLine): GraphicalMeasure;
            /**
                * Construct an empty Tab staffMeasure from the given source measure and staff.
                * @param sourceMeasure
                * @param staff
                * @returns {VexFlowTabMeasure}
                */
            createTabStaffMeasure(sourceMeasure: SourceMeasure, staff: Staff): GraphicalMeasure;
            /**
                * Create empty measure, which will be used to show key, rhythm changes at the end of the system.
                * @param staffLine
                * @returns {VexFlowMeasure}
                */
            createExtraGraphicalMeasure(staffLine: StaffLine): GraphicalMeasure;
            /**
                * Create a staffEntry in the given measure for a given sourceStaffEntry.
                * @param sourceStaffEntry
                * @param measure
                * @returns {VexFlowStaffEntry}
                */
            createStaffEntry(sourceStaffEntry: SourceStaffEntry, measure: GraphicalMeasure): GraphicalStaffEntry;
            createVoiceEntry(parentVoiceEntry: VoiceEntry, parentStaffEntry: GraphicalStaffEntry): GraphicalVoiceEntry;
            /**
                * Create a Graphical Note for given note and clef and as part of graphicalStaffEntry.
                * @param note
                * @param numberOfDots  The number of dots the note has to increase its musical duration.
                * @param graphicalStaffEntry
                * @param activeClef    The currently active clef, needed for positioning the note vertically
                * @param octaveShift   The currently active octave transposition enum, needed for positioning the note vertically
                * @returns {GraphicalNote}
                */
            createNote(note: Note, graphicalVoiceEntry: GraphicalVoiceEntry, activeClef: ClefInstruction, octaveShift: OctaveEnum, rules: EngravingRules, graphicalNoteLength?: Fraction): GraphicalNote;
            /**
                * Create a Graphical Grace Note (smaller head, stem...) for given note and clef and as part of graphicalStaffEntry.
                * @param note
                * @param numberOfDots
                * @param graphicalVoiceEntry
                * @param activeClef
                * @param octaveShift
                * @returns {GraphicalNote}
                */
            createGraceNote(note: Note, graphicalVoiceEntry: GraphicalVoiceEntry, activeClef: ClefInstruction, rules: EngravingRules, octaveShift?: OctaveEnum): GraphicalNote;
            /**
                * Sets a pitch which will be used for rendering the given graphical note (not changing the original pitch of the note!!!).
                * Will be only called if the displayed accidental is different from the original (e.g. a C# with C# as key instruction)
                * @param graphicalNote
                * @param pitch The pitch which will be rendered.
                */
            addGraphicalAccidental(graphicalNote: GraphicalNote, pitch: Pitch): void;
            /**
                * Adds a Fermata symbol at the last note of the given tied Note.
                * The last graphical note of this tied note is located at the given graphicalStaffEntry.
                * A Fermata has to be located at the last tied note.
                * @param tiedNote
                * @param graphicalStaffEntry
                */
            addFermataAtTiedEndNote(tiedNote: Note, graphicalStaffEntry: GraphicalStaffEntry): void;
            /**
                * Adds a clef change within a measure before the given staff entry.
                * @param graphicalStaffEntry
                * @param clefInstruction
                */
            createInStaffClef(graphicalStaffEntry: GraphicalStaffEntry, clefInstruction: ClefInstruction): void;
            /**
                * Adds a chord symbol at the given staff entry
                * @param sourceStaffEntry
                * @param graphicalStaffEntry
                * @param transposeHalftones
                */
            createChordSymbols(sourceStaffEntry: SourceStaffEntry, graphicalStaffEntry: GraphicalStaffEntry, keyInstruction: KeyInstruction, transposeHalftones: number): void;
            /**
                * Adds a technical instruction at the given staff entry.
                * @param technicalInstruction
                * @param graphicalStaffEntry
                */
            createGraphicalTechnicalInstruction(technicalInstruction: TechnicalInstruction, graphicalStaffEntry: GraphicalStaffEntry): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowInstantaneousDynamicExpression' {
    import { GraphicalInstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalInstantaneousDynamicExpression";
    import { InstantaneousDynamicExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousDynamicExpression";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    export class VexFlowInstantaneousDynamicExpression extends GraphicalInstantaneousDynamicExpression {
        constructor(instantaneousDynamicExpression: InstantaneousDynamicExpression, staffLine: StaffLine, measure: GraphicalMeasure);
        get InstantaneousDynamic(): InstantaneousDynamicExpression;
        get Expression(): string;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowInstrumentBrace' {
    import { VexFlowInstrumentBracket } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowInstrumentBracket";
    import { VexFlowStaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowStaffLine";
    /**
      * Class that defines a instrument bracket at the beginning of a line.
      */
    export class VexFlowInstrumentBrace extends VexFlowInstrumentBracket {
        constructor(firstVexFlowStaffLine: VexFlowStaffLine, lastVexFlowStaffLine: VexFlowStaffLine, depth?: number);
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowInstrumentBracket' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { GraphicalObject } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalObject";
    import { VexFlowStaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowStaffLine";
    /**
        * Class that defines a instrument bracket at the beginning of a line.
        */
    export class VexFlowInstrumentBracket extends GraphicalObject {
            vexflowConnector: VF.StaveConnector;
            Visible: boolean;
            constructor(firstVexFlowStaffLine: VexFlowStaffLine, lastVexFlowStaffLine: VexFlowStaffLine, depth?: number);
            /**
                * Render the bracket using the given backend
                * @param ctx Render Vexflow context
                */
            draw(ctx: Vex.IRenderContext): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMultiRestMeasure' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { Beam } from "opensheetmusicdisplay/MusicalScore/VoiceData/Beam";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { Tuplet } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tuplet";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { Voice } from "opensheetmusicdisplay/MusicalScore/VoiceData/Voice";
    import { VexFlowMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMeasure";
    /** A GraphicalMeasure drawing a multiple-rest measure in Vexflow.
        *  Mostly copied from VexFlowMeasure.
        *  Even though most of those functions aren't needed, apparently you can't remove the layoutStaffEntry function.
        */
    export class VexFlowMultiRestMeasure extends VexFlowMeasure {
            constructor(staff: Staff, sourceMeasure?: SourceMeasure, staffLine?: StaffLine);
            /**
                * Draw this measure on a VexFlow CanvasContext
                * @param ctx
                */
            draw(ctx: Vex.IRenderContext): Node;
            format(): void;
            /**
                * Returns all the voices that are present in this measure
                */
            getVoicesWithinMeasure(): Voice[];
            /**
                * Returns all the graphicalVoiceEntries of a given Voice.
                * @param voice the voice for which the graphicalVoiceEntries shall be returned.
                */
            getGraphicalVoiceEntriesPerVoice(voice: Voice): GraphicalVoiceEntry[];
            /**
                * Finds the gaps between the existing notes within a measure.
                * Problem here is, that the graphicalVoiceEntry does not exist yet and
                * that Tied notes are not present in the normal voiceEntries.
                * To handle this, calculation with absolute timestamps is needed.
                * And the graphical notes have to be analysed directly (and not the voiceEntries, as it actually should be -> needs refactoring)
                * @param voice the voice for which the ghost notes shall be searched.
                */
            protected getRestFilledVexFlowStaveNotesPerVoice(voice: Voice): GraphicalVoiceEntry[];
            /**
                * Add a note to a beam
                * @param graphicalNote
                * @param beam
                */
            handleBeam(graphicalNote: GraphicalNote, beam: Beam): void;
            handleTuplet(graphicalNote: GraphicalNote, tuplet: Tuplet): void;
            /**
                * Complete the creation of VexFlow Beams in this measure
                */
            finalizeBeams(): void;
            /**
                * Complete the creation of VexFlow Tuplets in this measure
                */
            finalizeTuplets(): void;
            layoutStaffEntry(graphicalStaffEntry: GraphicalStaffEntry): void;
            graphicalMeasureCreatedCalculations(): void;
            /**
                * Create the articulations for all notes of the current staff entry
                */
            protected createArticulations(): void;
            /**
                * Create the ornaments for all notes of the current staff entry
                */
            protected createOrnaments(): void;
            protected createFingerings(voiceEntry: GraphicalVoiceEntry): void;
            /**
                * Return the VexFlow Stave corresponding to this graphicalMeasure
                * @returns {VF.Stave}
                */
            getVFStave(): VF.Stave;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMusicSheetCalculator' {
    import { MusicSheetCalculator } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSheetCalculator";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { GraphicalTie } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalTie";
    import { Tie } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tie";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    import { RepetitionInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/RepetitionInstruction";
    import { Beam } from "opensheetmusicdisplay/MusicalScore/VoiceData/Beam";
    import { ClefInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/ClefInstruction";
    import { OctaveEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { Fraction } from "opensheetmusicdisplay/Common/DataObjects/Fraction";
    import { LyricWord } from "opensheetmusicdisplay/MusicalScore/VoiceData/Lyrics/LyricsWord";
    import { OrnamentContainer } from "opensheetmusicdisplay/MusicalScore/VoiceData/OrnamentContainer";
    import { Articulation } from "opensheetmusicdisplay/MusicalScore/VoiceData/Articulation";
    import { Tuplet } from "opensheetmusicdisplay/MusicalScore/VoiceData/Tuplet";
    import { TechnicalInstruction } from "opensheetmusicdisplay/MusicalScore/VoiceData/Instructions/TechnicalInstruction";
    import { Slur } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Slur";
    import { GraphicalSlur } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalSlur";
    import { InstantaneousTempoExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/InstantaneousTempoExpression";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    import { GraphicalGlissando } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalGlissando";
    import { Glissando } from "opensheetmusicdisplay/MusicalScore/VoiceData/Glissando";
    export class VexFlowMusicSheetCalculator extends MusicSheetCalculator {
            beamsNeedUpdate: boolean;
            constructor(rules: EngravingRules);
            protected clearRecreatedObjects(): void;
            protected formatMeasures(): void;
            /**
                * Calculates the x layout of the staff entries within the staff measures belonging to one source measure.
                * All staff entries are x-aligned throughout all vertically aligned staff measures.
                * This method is called within calculateXLayout.
                * The staff entries are aligned with minimum needed x distances.
                * The MinimumStaffEntriesWidth of every measure will be set - needed for system building.
                * Prepares the VexFlow formatter for later formatting
                * Does not calculate measure width from lyrics (which is called from MusicSheetCalculator)
                * @param measures
                * @returns the minimum required x width of the source measure (=list of staff measures)
                */
            protected calculateMeasureXLayout(measures: GraphicalMeasure[]): number;
            calculateElongationFactorFromStaffEntries(staffEntries: GraphicalStaffEntry[], oldMinimumStaffEntriesWidth: number, elongationFactorForMeasureWidth: number, measureNumber: number): number;
            calculateMeasureWidthFromStaffEntries(measuresVertical: GraphicalMeasure[], oldMinimumStaffEntriesWidth: number): number;
            protected createGraphicalTie(tie: Tie, startGse: GraphicalStaffEntry, endGse: GraphicalStaffEntry, startNote: GraphicalNote, endNote: GraphicalNote): GraphicalTie;
            protected updateStaffLineBorders(staffLine: StaffLine): void;
            protected graphicalMeasureCreatedCalculations(measure: GraphicalMeasure): void;
            /**
                * Can be used to calculate articulations, stem directions, helper(ledger) lines, and overlapping note x-displacement.
                * Is Excecuted per voice entry of a staff entry.
                * After that layoutStaffEntry is called.
                * @param voiceEntry
                * @param graphicalNotes
                * @param graphicalStaffEntry
                * @param hasPitchedNote
                */
            protected layoutVoiceEntry(voiceEntry: VoiceEntry, graphicalNotes: GraphicalNote[], graphicalStaffEntry: GraphicalStaffEntry, hasPitchedNote: boolean): void;
            /**
                * Do all layout calculations that have to be done per staff entry, like dots, ornaments, arpeggios....
                * This method is called after the voice entries are handled by layoutVoiceEntry().
                * @param graphicalStaffEntry
                */
            protected layoutStaffEntry(graphicalStaffEntry: GraphicalStaffEntry): void;
            /**
                * Is called at the begin of the method for creating the vertically aligned staff measures belonging to one source measure.
                */
            protected initGraphicalMeasuresCreation(): void;
            /**
                * add here all given articulations to the VexFlowGraphicalStaffEntry and prepare them for rendering.
                * @param articulations
                * @param voiceEntry
                * @param graphicalStaffEntry
                */
            protected layoutArticulationMarks(articulations: Articulation[], voiceEntry: VoiceEntry, graphicalStaffEntry: GraphicalStaffEntry): void;
            /**
                * Calculate the shape (Bezier curve) for this tie.
                * @param tie
                * @param tieIsAtSystemBreak
                * @param isTab Whether this tie is for a tab note (guitar tabulature)
                */
            protected layoutGraphicalTie(tie: GraphicalTie, tieIsAtSystemBreak: boolean, isTab: boolean): void;
            protected calculateDynamicExpressionsForMultiExpression(multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            protected createMetronomeMark(metronomeExpression: InstantaneousTempoExpression): void;
            protected calculateRehearsalMark(measure: SourceMeasure): void;
            /**
                * Calculate a single OctaveShift for a [[MultiExpression]].
                * @param sourceMeasure
                * @param multiExpression
                * @param measureIndex
                * @param staffIndex
                */
            protected calculateSingleOctaveShift(sourceMeasure: SourceMeasure, multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            /** Finds the last staffline measure that has staffentries. (staffentries necessary for octaveshift and pedal) */
            protected findLastStafflineMeasure(staffline: StaffLine): GraphicalMeasure;
            protected calculateSinglePedal(sourceMeasure: SourceMeasure, multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            protected calculateSingleWavyLine(sourceMeasure: SourceMeasure, multiExpression: MultiExpression, measureIndex: number, staffIndex: number): void;
            /**
                * Calculate all the textual and symbolic [[RepetitionInstruction]]s (e.g. dal segno) for a single [[SourceMeasure]].
                * @param repetitionInstruction
                * @param measureIndex
                */
            protected calculateWordRepetitionInstruction(repetitionInstruction: RepetitionInstruction, measureIndex: number): void;
            protected calculateSkyBottomLines(): void;
            /**
                * Re-adjust the x positioning of expressions. Update the skyline afterwards
                */
            protected calculateExpressionAlignements(): void;
            /**
                * Check if the tied graphical note belongs to any beams or tuplets and react accordingly.
                * @param tiedGraphicalNote
                * @param beams
                * @param activeClef
                * @param octaveShiftValue
                * @param graphicalStaffEntry
                * @param duration
                * @param openTie
                * @param isLastTieNote
                */
            protected handleTiedGraphicalNote(tiedGraphicalNote: GraphicalNote, beams: Beam[], activeClef: ClefInstruction, octaveShiftValue: OctaveEnum, graphicalStaffEntry: GraphicalStaffEntry, duration: Fraction, openTie: Tie, isLastTieNote: boolean): void;
            /**
                * Is called if a note is part of a beam.
                * @param graphicalNote
                * @param beam
                * @param openBeams a list of all currently open beams
                */
            protected handleBeam(graphicalNote: GraphicalNote, beam: Beam, openBeams: Beam[]): void;
            protected handleVoiceEntryLyrics(voiceEntry: VoiceEntry, graphicalStaffEntry: GraphicalStaffEntry, lyricWords: LyricWord[]): void;
            protected handleVoiceEntryOrnaments(ornamentContainer: OrnamentContainer, voiceEntry: VoiceEntry, graphicalStaffEntry: GraphicalStaffEntry): void;
            /**
                * Add articulations to the given vexflow staff entry.
                * @param articulations
                * @param voiceEntry
                * @param graphicalStaffEntry
                */
            protected handleVoiceEntryArticulations(articulations: Articulation[], voiceEntry: VoiceEntry, staffEntry: GraphicalStaffEntry): void;
            /**
                * Add technical instructions to the given vexflow staff entry.
                * @param technicalInstructions
                * @param voiceEntry
                * @param staffEntry
                */
            protected handleVoiceEntryTechnicalInstructions(technicalInstructions: TechnicalInstruction[], voiceEntry: VoiceEntry, staffEntry: GraphicalStaffEntry): void;
            /**
                * Is called if a note is part of a tuplet.
                * @param graphicalNote
                * @param tuplet
                * @param openTuplets a list of all currently open tuplets
                */
            protected handleTuplet(graphicalNote: GraphicalNote, tuplet: Tuplet, openTuplets: Tuplet[]): void;
            /**
                * Find the Index of the item of the array of all VexFlow Slurs that holds a specified slur
                * @param gSlurs
                * @param slur
                */
            findIndexGraphicalSlurFromSlur(gSlurs: GraphicalSlur[], slur: Slur): number;
            indexOfGraphicalGlissFromGliss(gGlissandi: GraphicalGlissando[], glissando: Glissando): number;
            protected calculateSlurs(): void;
            calculateGlissandi(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMusicSystem' {
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { SystemLinesEnum } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinesEnum";
    import { SystemLinePosition } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLinePosition";
    import { GraphicalMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalMeasure";
    import { SystemLine } from "opensheetmusicdisplay/MusicalScore/Graphical/SystemLine";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class VexFlowMusicSystem extends MusicSystem {
            constructor(id: number, rules: EngravingRules);
            calculateBorders(rules: EngravingRules): void;
            /**
                * This method creates all the graphical lines and dots needed to render a system line (e.g. bold-thin-dots..).
                * @param xPosition
                * @param lineWidth
                * @param lineType
                * @param linePosition indicates if the line belongs to start or end of measure
                * @param musicSystem
                * @param topMeasure
                * @param bottomMeasure
                */
            protected createSystemLine(xPosition: number, lineWidth: number, lineType: SystemLinesEnum, linePosition: SystemLinePosition, musicSystem: MusicSystem, topMeasure: GraphicalMeasure, bottomMeasure?: GraphicalMeasure): SystemLine;
            /**
                * creates an instrument brace for the given dimension.
                * The height and positioning can be inferred from the given staff lines.
                * @param firstStaffLine the upper StaffLine (use a cast to get the VexFlowStaffLine) of the brace to create
                * @param lastStaffLine the lower StaffLine (use a cast to get the VexFlowStaffLine) of the brace to create
                */
            protected createInstrumentBracket(firstStaffLine: StaffLine, lastStaffLine: StaffLine): void;
            /**
                * creates an instrument group bracket for the given dimension.
                * There can be cascaded bracket (e.g. a group of 2 in a group of 4) -
                * The recursion depth informs about the current depth level (needed for positioning)
                * @param firstStaffLine the upper staff line of the bracket to create
                * @param lastStaffLine the lower staff line of the bracket to create
                * @param recursionDepth
                */
            protected createGroupBracket(firstStaffLine: StaffLine, lastStaffLine: StaffLine, recursionDepth: number): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowOctaveShift' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { GraphicalOctaveShift } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalOctaveShift";
    import { OctaveShift } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/OctaveShift";
    import { BoundingBox } from "opensheetmusicdisplay/MusicalScore/Graphical/BoundingBox";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    /**
        * The vexflow adaptation of a graphical shift.
        */
    export class VexFlowOctaveShift extends GraphicalOctaveShift {
            /** Defines the note where the octave shift starts */
            startNote: VF.StemmableNote;
            /** Defines the note where the octave shift ends */
            endNote: VF.StemmableNote;
            /**
                * Create a new vexflow ocatve shift
                * @param octaveShift the object read by the ExpressionReader
                * @param parent the bounding box of the parent
                */
            constructor(octaveShift: OctaveShift, parent: BoundingBox);
            /**
                * Set a start note using a staff entry
                * @param graphicalStaffEntry the staff entry that holds the start note
                */
            setStartNote(graphicalStaffEntry: GraphicalStaffEntry): boolean;
            /**
                * Set an end note using a staff entry
                * @param graphicalStaffEntry the staff entry that holds the end note
                */
            setEndNote(graphicalStaffEntry: GraphicalStaffEntry): boolean;
            /**
                * Get the actual vexflow text bracket used for drawing
                */
            getTextBracket(): VF.TextBracket;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowSlur' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { Slur } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Slur";
    export interface ICurveOptions {
        spacing: number;
        thickness: number;
        x_shift: number;
        y_shift: number;
        position: CurvePositionEnum;
        position_end: CurvePositionEnum;
        invert: boolean;
        cps: [{
            x: number;
            y: number;
        }, {
            x: number;
            y: number;
        }];
    }
    export enum CurvePositionEnum {
        NEAR_HEAD = 1,
        NEAR_TOP = 2
    }
    export class VexFlowSlur {
        constructor(parentslur: Slur);
        /**
          * Copy constructor: generate a VexFlowSlur from an existing one
          */
        static createFromVexflowSlur(vfSlur: VexFlowSlur): VexFlowSlur;
        get vfSlur(): Slur;
        vfStartNote: VF.StemmableNote;
        vfEndNote: VF.StemmableNote;
        vfCurve: VF.Curve;
        curve_Options(): ICurveOptions;
        createVexFlowCurve(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowStaffEntry' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { VexFlowMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMeasure";
    import { SourceStaffEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceStaffEntry";
    export class VexFlowStaffEntry extends GraphicalStaffEntry {
            constructor(measure: VexFlowMeasure, sourceStaffEntry: SourceStaffEntry, staffEntryParent: VexFlowStaffEntry);
            vfClefBefore: VF.ClefNote;
            /**
                * Calculates the staff entry positions from the VexFlow stave information and the tickabels inside the staff.
                * This is needed in order to set the OSMD staff entries (which are almost the same as tickables) to the correct positions.
                * It is also needed to be done after formatting!
                */
            calculateXPosition(): void;
            setMaxAccidentals(): number;
            setModifierXOffsets(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowStaffLine' {
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    import { MusicSystem } from "opensheetmusicdisplay/MusicalScore/Graphical/MusicSystem";
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { VexFlowSlur } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowSlur";
    import { AlignmentManager } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/AlignmentManager";
    export class VexFlowStaffLine extends StaffLine {
        constructor(parentSystem: MusicSystem, parentStaff: Staff);
        protected slursInVFStaffLine: VexFlowSlur[];
        protected alignmentManager: AlignmentManager;
        get SlursInVFStaffLine(): VexFlowSlur[];
        addVFSlurToVFStaffline(vfSlur: VexFlowSlur): void;
        get AlignmentManager(): AlignmentManager;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexflowStafflineNoteCalculator' {
    import { IStafflineNoteCalculator } from "opensheetmusicdisplay/MusicalScore/Interfaces/IStafflineNoteCalculator";
    import { GraphicalNote } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalNote";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class VexflowStafflineNoteCalculator implements IStafflineNoteCalculator {
            constructor(rules: EngravingRules);
            /**
                * This method is called for each note during the calc phase. We want to track all possible positions to make decisions
                * during layout about where notes should be positioned.
                * This directly puts notes that share a line to the same position, regardless of voice
                * @param graphicalNote The note to be checked/positioned
                * @param staffIndex The staffline the note is on
                */
            trackNote(graphicalNote: GraphicalNote): void;
            /**
                * This method is called for each note, and should make any necessary position changes based on the number of stafflines, clef, etc.
                * @param graphicalNote The note to be checked/positioned
                * @param staffIndex The staffline that this note exists on
                * @returns the newly positioned note
                */
            positionNote(graphicalNote: GraphicalNote): GraphicalNote;
            /**
                * Get the number of unique "voices" or note positions
                * @param staffIndex The Staffline to get the count of
                */
            getStafflineUniquePositionCount(staffIndex: number): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowTabMeasure' {
    import { Staff } from "opensheetmusicdisplay/MusicalScore/VoiceData/Staff";
    import { SourceMeasure } from "opensheetmusicdisplay/MusicalScore/VoiceData/SourceMeasure";
    import { VexFlowMeasure } from "opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowMeasure";
    import { StaffLine } from "opensheetmusicdisplay/MusicalScore/Graphical/StaffLine";
    export class VexFlowTabMeasure extends VexFlowMeasure {
        constructor(staff: Staff, sourceMeasure?: SourceMeasure, staffLine?: StaffLine);
        /**
          * Reset all the geometric values and parameters of this measure and put it in an initialized state.
          * This is needed to evaluate a measure a second time by system builder.
          */
        resetLayout(): void;
        graphicalMeasureCreatedCalculations(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowTextMeasurer' {
    import { ITextMeasurer } from "opensheetmusicdisplay/MusicalScore/Interfaces/ITextMeasurer";
    import { Fonts } from "opensheetmusicdisplay/Common/Enums/Fonts";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    /**
      * Created by Matthias on 21.06.2016.
      */
    export class VexFlowTextMeasurer implements ITextMeasurer {
        constructor(rules: EngravingRules);
        fontSize: number;
        fontSizeStandard: number;
        computeTextWidthToHeightRatio(text: string, font: Fonts, style: FontStyles, fontFamily?: string, fontSize?: number): number;
        setFontSize(fontSize?: number): number;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/Graphical/VexFlow/VexFlowVoiceEntry' {
    import Vex from "vexflow";
    import VF = Vex.Flow;
    import { VoiceEntry } from "opensheetmusicdisplay/MusicalScore/VoiceData/VoiceEntry";
    import { GraphicalVoiceEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalVoiceEntry";
    import { GraphicalStaffEntry } from "opensheetmusicdisplay/MusicalScore/Graphical/GraphicalStaffEntry";
    import { EngravingRules } from "opensheetmusicdisplay/MusicalScore/Graphical/EngravingRules";
    export class VexFlowVoiceEntry extends GraphicalVoiceEntry {
        vfGhostNotes: VF.GhostNote[];
        constructor(parentVoiceEntry: VoiceEntry, parentStaffEntry: GraphicalStaffEntry, rules?: EngravingRules);
        applyBordersFromVexflow(): void;
        set vfStaveNote(value: VF.StemmableNote);
        get vfStaveNote(): VF.StemmableNote;
        /** (Re-)color notes and stems by setting their Vexflow styles.
          * Could be made redundant by a Vexflow PR, but Vexflow needs more solid and permanent color methods/variables for that
          * See VexFlowConverter.StaveNote()
          */
        color(): void;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MoodExpression' {
    import { PlacementEnum, AbstractExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    export class MoodExpression extends AbstractExpression {
        constructor(label: string, placement: PlacementEnum, staffNumber: number);
        fontStyle: FontStyles;
        static isInputStringMood(inputString: string): boolean;
        get Label(): string;
        set Label(value: string);
        get Mood(): MoodEnum;
        set Mood(value: MoodEnum);
        get StaffNumber(): number;
        set StaffNumber(value: number);
        get Placement(): PlacementEnum;
        set Placement(value: PlacementEnum);
    }
    export enum MoodEnum {
        Affettuoso = 0,
        Agitato = 1,
        Appassionato = 2,
        Animato = 3,
        Brillante = 4,
        Cantabile = 5,
        Dolce = 6,
        Energico = 7,
        Eroico = 8,
        Espressivo = 9,
        Furioso = 10,
        Giocoso = 11,
        Gioioso = 12,
        Lacrimoso = 13,
        Grandioso = 14,
        Grazioso = 15,
        Leggiero = 16,
        Maestoso = 17,
        Malinconico = 18,
        Marcato = 19,
        Marziale = 20,
        Mesto = 21,
        Morendo = 22,
        Nobilmente = 23,
        Patetico = 24,
        Pesante = 25,
        Sautille = 26,
        Saltando = 27,
        Scherzando = 28,
        Sostenuto = 29,
        Spiccato = 30,
        Tenerezza = 31,
        Tranquillamente = 32,
        Trionfante = 33,
        Vivace = 34
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/UnknownExpression' {
    import { PlacementEnum, AbstractExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { TextAlignmentEnum } from "opensheetmusicdisplay/Common/Enums/TextAlignment";
    import { FontStyles } from "opensheetmusicdisplay/Common/Enums/FontStyles";
    export class UnknownExpression extends AbstractExpression {
        constructor(label: string, placement: PlacementEnum, textAlignment: TextAlignmentEnum, staffNumber: number);
        fontStyle: FontStyles;
        defaultYXml: number;
        get Label(): string;
        get Placement(): PlacementEnum;
        set Placement(value: PlacementEnum);
        get StaffNumber(): number;
        set StaffNumber(value: number);
        get TextAlignment(): TextAlignmentEnum;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/Pedal' {
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    export class Pedal {
        constructor(line?: boolean, sign?: boolean);
        StaffNumber: number;
        ParentStartMultiExpression: MultiExpression;
        ParentEndMultiExpression: MultiExpression;
        ChangeEnd: boolean;
        ChangeBegin: boolean;
        /** Whether the pedal ends at the stave end (and not before the endNote) */
        EndsStave: boolean;
        /** Whether the pedal begins at the stave beginning (and not before the startNote - e.g. for whole measure rest) */
        BeginsStave: boolean;
        get IsLine(): boolean;
        get IsSign(): boolean;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/ContinuousExpressions/WavyLine' {
    import { AbstractExpression, PlacementEnum } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/AbstractExpression";
    import { MultiExpression } from "opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/MultiExpression";
    export class WavyLine extends AbstractExpression {
        constructor(placement: PlacementEnum);
        ParentStartMultiExpression: MultiExpression;
        ParentEndMultiExpression: MultiExpression;
    }
}

declare module 'opensheetmusicdisplay/MusicalScore/VoiceData/Expressions/DynamicExpressionSymbolEnum' {
    export enum DynamicExpressionSymbolEnum {
        p = 0,
        f = 1,
        s = 2,
        z = 3,
        m = 4,
        r = 5
    }
}

declare module 'opensheetmusicdisplay/' {
    export * from "opensheetmusicdisplay/OpenSheetMusicDisplay";
    export * from "opensheetmusicdisplay/MusicalScore";
    export * from "opensheetmusicdisplay/Util";
    export * from "opensheetmusicdisplay/Common";
    export * from "opensheetmusicdisplay/Display";
    export * from "opensheetmusicdisplay/Playback";
    export * from "opensheetmusicdisplay/Plugins";
}

